From: thermatk <thermatk@thermatk.com>
Date: Fri, 22 Jun 2018 17:11:38 +0200
Subject: kill GCM

---
 build/secondary/third_party/android_tools/BUILD.gn |   3 -
 chrome/android/BUILD.gn                            |   1 -
 chrome/android/java/AndroidManifest.xml            |  62 ---------
 .../chrome/browser/BackgroundSyncLauncher.java     |  97 --------------
 .../chrome/browser/ChromeBackgroundService.java    |   1 -
 .../invalidation/InvalidationController.java       |  13 --
 .../browser/ntp/snippets/SnippetsLauncher.java     |  44 -------
 .../browser/services/gcm/GCMBackgroundTask.java    |   2 -
 .../gcm/InvalidationGcmUpstreamSender.java         |  15 ---
 chrome/android/java_sources.gni                    |   2 -
 components/background_task_scheduler/BUILD.gn      |   1 -
 .../BackgroundTaskSchedulerGcmNetworkManager.java  | 146 +--------------------
 components/gcm_driver/android/BUILD.gn             |   1 -
 components/gcm_driver/instance_id/android/BUILD.gn |   1 -
 .../gcm_driver/instance_id/InstanceIDBridge.java   |  31 +----
 components/sync/android/BUILD.gn                   |   1 -
 third_party/cacheinvalidation/BUILD.gn             |   6 -
 .../client/contrib/MultiplexingGcmListener.java    |  92 +------------
 .../android2/channel/AndroidNetworkChannel.java    |  18 +--
 19 files changed, 14 insertions(+), 523 deletions(-)

diff --git a/build/secondary/third_party/android_tools/BUILD.gn b/build/secondary/third_party/android_tools/BUILD.gn
--- a/build/secondary/third_party/android_tools/BUILD.gn
+++ b/build/secondary/third_party/android_tools/BUILD.gn
@@ -53,9 +53,6 @@ if (enable_java_templates) {
     testonly = true
     java_files = [ "//third_party/android_tools/sdk/extras/chromium/support/src/org/chromium/android/support/PackageManagerWrapper.java" ]
   }
-  android_java_prebuilt("android_gcm_java") {
-    jar_path = "//third_party/android_tools/sdk/extras/google/gcm/gcm-client/dist/gcm.jar"
-  }
   android_java_prebuilt("emma_device_java") {
     jar_path = "//third_party/android_tools/sdk/tools/lib/emma_device.jar"
     include_java_resources = true
diff --git a/chrome/android/BUILD.gn b/chrome/android/BUILD.gn
--- a/chrome/android/BUILD.gn
+++ b/chrome/android/BUILD.gn
@@ -308,7 +308,6 @@ android_library("chrome_java") {
     "//third_party/android_deps:javax_inject_javax_inject_java",
     "//third_party/android_media:android_media_java",
     "//third_party/android_swipe_refresh:android_swipe_refresh_java",
-    "//third_party/android_tools:android_gcm_java",
     "//third_party/blink/public:android_mojo_bindings_java",
     "//third_party/blink/public:blink_headers_java",
     "//third_party/blink/public/mojom:android_mojo_bindings_java",
diff --git a/chrome/android/java/AndroidManifest.xml b/chrome/android/java/AndroidManifest.xml
--- a/chrome/android/java/AndroidManifest.xml
+++ b/chrome/android/java/AndroidManifest.xml
@@ -77,22 +77,17 @@ by a child template that "extends" this file.
     <permission android:name="{{ manifest_package }}.permission.CHILD_SERVICE" android:protectionLevel="signature" />
     <permission android:name="{{ manifest_package }}.permission.READ_WRITE_BOOKMARK_FOLDERS" android:protectionLevel="signatureOrSystem" />
     <permission android:name="{{ manifest_package }}.TOS_ACKED" android:protectionLevel="signatureOrSystem" />
-    <!-- Only chrome can receive the messages and registration result -->
-    <permission android:name="{{ manifest_package }}.permission.C2D_MESSAGE"
-        android:protectionLevel="signature" />
     <permission android:name="{{ manifest_package }}.permission.DEBUG"
                 android:label="Debug web pages"
                 android:permissionGroup="android.permission-group.DEVELOPMENT_TOOLS"
                 android:protectionLevel="signature" />
 
-    <uses-permission android:name="{{ manifest_package }}.permission.C2D_MESSAGE" />
     <uses-permission android:name="{{ manifest_package }}.permission.READ_WRITE_BOOKMARK_FOLDERS" />
     <uses-permission android:name="{{ manifest_package }}.TOS_ACKED" />
 
     <uses-permission android:name="com.chrome.permission.DEVICE_EXTRAS" />
     <uses-permission android:name="com.android.browser.permission.READ_HISTORY_BOOKMARKS"/>
     <uses-permission android:name="com.android.browser.permission.WRITE_HISTORY_BOOKMARKS"/>
-    <uses-permission android:name="com.google.android.c2dm.permission.RECEIVE" />
     <uses-permission android:name="com.android.launcher.permission.INSTALL_SHORTCUT"/>
 
     <uses-permission android:name="com.google.android.apps.now.CURRENT_ACCOUNT_ACCESS" />
@@ -911,43 +906,6 @@ by a child template that "extends" this file.
             android:configChanges="orientation|keyboardHidden|keyboard|screenSize|mcc|mnc|screenLayout|smallestScreenSize"
             android:hardwareAccelerated="false" />
 
-        <!-- Receiver for GCM messages. -->
-        <receiver android:name="com.google.android.gms.gcm.GcmReceiver"
-            android:exported="true"
-            android:permission="com.google.android.c2dm.permission.SEND">
-            <intent-filter>
-                <action android:name="com.google.android.c2dm.intent.RECEIVE" />
-                <action android:name="com.google.android.c2dm.intent.REGISTRATION" />
-               <category android:name="{{ manifest_package }}"/>
-            </intent-filter>
-        </receiver>
-        <!-- GcmTaskService for registration for Invalidations. -->
-        <service android:name="com.google.ipc.invalidation.ticl.android2.channel.GcmRegistrationTaskService"
-            android:exported="true"
-            android:permission="com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE" >
-            <intent-filter>
-                <action android:name="com.google.android.gms.gcm.ACTION_TASK_READY"/>
-            </intent-filter>
-        </service>
-        <!-- InstanceIDListenerService for token refresh events from GCM. -->
-        <service android:name="com.google.ipc.invalidation.ticl.android2.channel.AndroidInstanceIDListenerService"
-            android:exported="false">
-            <intent-filter>
-                <action android:name="com.google.android.gms.iid.InstanceID"/>
-            </intent-filter>
-        </service>
-        <!-- GcmListenerService for messages from GCM. -->
-        <service android:name="org.chromium.chrome.browser.services.gcm.ChromeGcmListenerService"
-            android:exported="false" >
-            <intent-filter>
-              <action android:name="com.google.android.c2dm.intent.RECEIVE" />
-            </intent-filter>
-        </service>
-        <meta-data android:name="ipc.invalidation.ticl.gcm_upstream_service_class"
-            android:value="org.chromium.chrome.browser.services.gcm.InvalidationGcmUpstreamSender" />
-        <service android:name="org.chromium.chrome.browser.services.gcm.InvalidationGcmUpstreamSender"
-            android:exported="false"/>
-
         <!-- Notification service for sync. -->
         <meta-data android:name="ipc.invalidation.ticl.listener_service_class"
             android:value="org.chromium.chrome.browser.invalidation.ChromeInvalidationClientService"/>
@@ -959,8 +917,6 @@ by a child template that "extends" this file.
         </service>
         <service android:name="com.google.ipc.invalidation.ticl.android2.TiclService"
             android:exported="false"/>
-        <service android:name="com.google.ipc.invalidation.ticl.android2.channel.AndroidMessageSenderService"
-            android:exported="false"/>
         <receiver android:name="com.google.ipc.invalidation.ticl.android2.AndroidInternalScheduler$AlarmReceiver"
             android:exported="false"/>
         <receiver android:name="com.google.ipc.invalidation.external.client.contrib.AndroidListener$AlarmReceiver"
@@ -987,24 +943,6 @@ by a child template that "extends" this file.
             android:exported="false"
             android:permission="android.permission.BIND_JOB_SERVICE"/>
 
-        <!-- Background Task Scheduler GCM task service -->
-        <service android:name="org.chromium.components.background_task_scheduler.BackgroundTaskGcmTaskService"
-            android:permission="com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE"
-            android:exported="true">
-            <intent-filter>
-                <action android:name="com.google.android.gms.gcm.ACTION_TASK_READY" />
-            </intent-filter>
-        </service>
-
-        <!-- GcmTaskService implementation to wake Chrome on scheduled events -->
-        <service android:name="org.chromium.chrome.browser.ChromeBackgroundService"
-            android:permission="com.google.android.gms.permission.BIND_NETWORK_TASK_SERVICE"
-            android:exported="true">
-            <intent-filter>
-                <action android:name="com.google.android.gms.gcm.ACTION_TASK_READY" />
-            </intent-filter>
-        </service>
-
         <service android:name="org.chromium.chrome.browser.prerender.ChromePrerenderService"
             android:exported="true"
             tools:ignore="ExportedService" />
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/BackgroundSyncLauncher.java b/chrome/android/java/src/org/chromium/chrome/browser/BackgroundSyncLauncher.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/BackgroundSyncLauncher.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/BackgroundSyncLauncher.java
@@ -8,10 +8,6 @@ import android.content.Context;
 import android.content.SharedPreferences;
 import android.os.StrictMode;
 
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.OneoffTask;
-import com.google.android.gms.gcm.Task;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
 import org.chromium.base.VisibleForTesting;
@@ -37,8 +33,6 @@ public class BackgroundSyncLauncher {
     // BackgroundSyncLauncherAndroid, if any. If it is non-null then the browser is running.
     private static BackgroundSyncLauncher sInstance;
 
-    private GcmNetworkManager mScheduler;
-
     /**
      * Disables the automatic use of the GCMNetworkManager. When disabled, the methods which
      * interact with GCM can still be used, but will not be called automatically on creation, or by
@@ -124,30 +118,6 @@ public class BackgroundSyncLauncher {
     @VisibleForTesting
     @CalledByNative
     protected void launchBrowserIfStopped(final boolean shouldLaunch, final long minDelayMs) {
-        mLaunchBrowserIfStoppedTask = new AsyncTask<Void>() {
-            @Override
-            protected Void doInBackground() {
-                SharedPreferences prefs = ContextUtils.getAppSharedPreferences();
-                prefs.edit()
-                        .putBoolean(PREF_BACKGROUND_SYNC_LAUNCH_NEXT_ONLINE, shouldLaunch)
-                        .apply();
-                return null;
-            }
-            @Override
-            protected void onPostExecute(Void params) {
-                if (sGCMEnabled) {
-                    if (shouldLaunch) {
-                        RecordHistogram.recordBooleanHistogram(
-                                "BackgroundSync.LaunchTask.ScheduleSuccess",
-                                scheduleLaunchTask(mScheduler, minDelayMs));
-                    } else {
-                        RecordHistogram.recordBooleanHistogram(
-                                "BackgroundSync.LaunchTask.CancelSuccess",
-                                removeScheduledTasks(mScheduler));
-                    }
-                }
-            }
-        }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
     }
 
     /**
@@ -159,7 +129,6 @@ public class BackgroundSyncLauncher {
     }
 
     protected BackgroundSyncLauncher() {
-        mScheduler = GcmNetworkManager.getInstance(ContextUtils.getApplicationContext());
         launchBrowserIfStopped(false, 0);
     }
 
@@ -188,72 +157,6 @@ public class BackgroundSyncLauncher {
         return !sGCMEnabled;
     }
 
-    private static boolean scheduleLaunchTask(GcmNetworkManager scheduler, long minDelayMs) {
-        // Google Play Services may not be up to date, if the application was not installed through
-        // the Play Store. In this case, scheduling the task will fail silently.
-        final long minDelaySecs = minDelayMs / 1000;
-        OneoffTask oneoff = new OneoffTask.Builder()
-                                    .setService(ChromeBackgroundService.class)
-                                    .setTag(TASK_TAG)
-                                    // We have to set a non-zero execution window here
-                                    .setExecutionWindow(minDelaySecs, minDelaySecs + 1)
-                                    .setRequiredNetwork(Task.NETWORK_STATE_CONNECTED)
-                                    .setPersisted(true)
-                                    .setUpdateCurrent(true)
-                                    .build();
-        try {
-            scheduler.schedule(oneoff);
-        } catch (IllegalArgumentException e) {
-            // Disable GCM for the remainder of this session.
-            setGCMEnabled(false);
-            // Return false so that the failure will be logged.
-            return false;
-        }
-        return true;
-    }
-
-    private static boolean removeScheduledTasks(GcmNetworkManager scheduler) {
-        // Third-party code causes broadcast to touch disk. http://crbug.com/614679
-        StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
-        try {
-            scheduler.cancelTask(TASK_TAG, ChromeBackgroundService.class);
-        } catch (IllegalArgumentException e) {
-            // This occurs when BackgroundSyncLauncherService is not found in the application
-            // manifest. This should not happen in code that reaches here, but has been seen in
-            // the past. See https://crbug.com/548314
-            // Disable GCM for the remainder of this session.
-            setGCMEnabled(false);
-            // Return false so that the failure will be logged.
-            return false;
-        } finally {
-            StrictMode.setThreadPolicy(oldPolicy);
-        }
-        return true;
-    }
-
-    /**
-     * Reschedule any required background sync tasks, if they have been removed due to an
-     * application upgrade.
-     *
-     * This method checks the saved preferences, and reschedules the sync tasks as appropriate
-     * to match the preferences.
-     * This method is static so that it can be run without actually instantiating a
-     * BackgroundSyncLauncher.
-     */
-    protected static void rescheduleTasksOnUpgrade(final Context context) {
-        final GcmNetworkManager scheduler = GcmNetworkManager.getInstance(context);
-        BackgroundSyncLauncher.ShouldLaunchCallback callback = shouldLaunch -> {
-            if (shouldLaunch) {
-                // It's unclear what time the sync event was supposed to fire, so fire
-                // without delay and let the browser reschedule if necessary.
-                // TODO(iclelland): If this fails, report the failure via UMA (not now,
-                // since the browser is not running, but on next startup.)
-                scheduleLaunchTask(scheduler, 0);
-            }
-        };
-        BackgroundSyncLauncher.shouldLaunchBrowserIfStopped(callback);
-    }
-
     @VisibleForTesting
     static void setGCMEnabled(boolean enabled) {
         sGCMEnabled = enabled;
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/ChromeBackgroundService.java b/chrome/android/java/src/org/chromium/chrome/browser/ChromeBackgroundService.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/ChromeBackgroundService.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/ChromeBackgroundService.java
@@ -106,7 +106,6 @@ public class ChromeBackgroundService extends GcmTaskService {
 
     @VisibleForTesting
     protected void rescheduleBackgroundSyncTasksOnUpgrade() {
-        BackgroundSyncLauncher.rescheduleTasksOnUpgrade(this);
     }
 
     private void handleSnippetsOnBrowserUpgraded() {
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/invalidation/InvalidationController.java b/chrome/android/java/src/org/chromium/chrome/browser/invalidation/InvalidationController.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/invalidation/InvalidationController.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/invalidation/InvalidationController.java
@@ -10,8 +10,6 @@ import android.os.Build;
 import android.os.Handler;
 import android.os.SystemClock;
 
-import com.google.ipc.invalidation.ticl.android2.channel.AndroidGcmController;
-
 import org.chromium.base.ApplicationState;
 import org.chromium.base.ApplicationStatus;
 import org.chromium.base.ContextUtils;
@@ -198,18 +196,7 @@ public class InvalidationController implements ApplicationStatus.ApplicationStat
      * Registers for Google Cloud Messaging (GCM) for Invalidations.
      */
     private void ensureGcmIsInitialized() {
-        if (mGcmInitialized) return;
         mGcmInitialized = true;
-        new AsyncTask<Void>() {
-            @Override
-            protected Void doInBackground() {
-                boolean useGcmUpstream = true;
-                AndroidGcmController.get(ContextUtils.getApplicationContext())
-                        .initializeGcm(useGcmUpstream);
-                return null;
-            }
-        }
-                .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
     }
 
     @VisibleForTesting
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/ntp/snippets/SnippetsLauncher.java b/chrome/android/java/src/org/chromium/chrome/browser/ntp/snippets/SnippetsLauncher.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/ntp/snippets/SnippetsLauncher.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/ntp/snippets/SnippetsLauncher.java
@@ -7,15 +7,10 @@ package org.chromium.chrome.browser.ntp.snippets;
 import android.content.Context;
 import android.net.ConnectivityManager;
 
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.PeriodicTask;
-import com.google.android.gms.gcm.Task;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
 import org.chromium.base.VisibleForTesting;
 import org.chromium.base.annotations.CalledByNative;
-import org.chromium.chrome.browser.ChromeBackgroundService;
 import org.chromium.chrome.browser.externalauth.ExternalAuthUtils;
 
 /**
@@ -40,8 +35,6 @@ public class SnippetsLauncher {
     // If it is non-null then the browser is running.
     private static SnippetsLauncher sInstance;
 
-    private GcmNetworkManager mScheduler;
-
     private boolean mGCMEnabled = true;
 
     /**
@@ -78,7 +71,6 @@ public class SnippetsLauncher {
 
     protected SnippetsLauncher() {
         checkGCM();
-        mScheduler = GcmNetworkManager.getInstance(ContextUtils.getApplicationContext());
     }
 
     private void checkGCM() {
@@ -89,32 +81,7 @@ public class SnippetsLauncher {
         }
     }
 
-    private static PeriodicTask buildFetchTask(
-            String tag, long periodSeconds, int requiredNetwork) {
-        // Add a bit of "flex" around the target period. This achieves the following:
-        // - It makes sure the task doesn't run (significantly) before its initial period has
-        //   elapsed. In practice, the scheduler seems to behave like that anyway, but it doesn't
-        //   guarantee that, so we shouldn't rely on it.
-        // - It gives the scheduler a bit of room to optimize for battery life.
-        long effectivePeriodSeconds = (long) (periodSeconds * (1.0 + FLEX_FACTOR));
-        long flexSeconds = (long) (periodSeconds * (2.0 * FLEX_FACTOR));
-        return new PeriodicTask.Builder()
-                .setService(ChromeBackgroundService.class)
-                .setTag(tag)
-                .setPeriod(effectivePeriodSeconds)
-                .setFlex(flexSeconds)
-                .setRequiredNetwork(requiredNetwork)
-                .setPersisted(true)
-                .setUpdateCurrent(true)
-                .build();
-    }
-
     private void scheduleOrCancelFetchTask(String taskTag, long period, int requiredNetwork) {
-        if (period > 0) {
-            mScheduler.schedule(buildFetchTask(taskTag, period, requiredNetwork));
-        } else {
-            mScheduler.cancelTask(taskTag, ChromeBackgroundService.class);
-        }
     }
 
     @CalledByNative
@@ -127,23 +94,12 @@ public class SnippetsLauncher {
                 .edit()
                 .putBoolean(PREF_IS_SCHEDULED, isScheduled)
                 .apply();
-
-        // Google Play Services may not be up to date, if the application was not installed through
-        // the Play Store. In this case, scheduling the task will fail silently.
-        try {
-            scheduleOrCancelFetchTask(
-                    TASK_TAG_WIFI, periodWifiSeconds, Task.NETWORK_STATE_UNMETERED);
-            scheduleOrCancelFetchTask(
-                    TASK_TAG_FALLBACK, periodFallbackSeconds, Task.NETWORK_STATE_CONNECTED);
-        } catch (IllegalArgumentException e) {
             // Disable GCM for the remainder of this session.
             mGCMEnabled = false;
 
             ContextUtils.getAppSharedPreferences().edit().remove(PREF_IS_SCHEDULED).apply();
             // Return false so that the failure will be logged.
             return false;
-        }
-        return true;
     }
 
     @CalledByNative
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/services/gcm/GCMBackgroundTask.java b/chrome/android/java/src/org/chromium/chrome/browser/services/gcm/GCMBackgroundTask.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/services/gcm/GCMBackgroundTask.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/services/gcm/GCMBackgroundTask.java
@@ -39,8 +39,6 @@ public class GCMBackgroundTask implements BackgroundTask {
             Log.e(TAG, "The received bundle containing message data could not be validated.");
             return false;
         }
-
-        ChromeGcmListenerService.dispatchMessageToDriver(context, new GCMMessage(extras));
         return false;
     }
 
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/services/gcm/InvalidationGcmUpstreamSender.java b/chrome/android/java/src/org/chromium/chrome/browser/services/gcm/InvalidationGcmUpstreamSender.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/services/gcm/InvalidationGcmUpstreamSender.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/services/gcm/InvalidationGcmUpstreamSender.java
@@ -12,7 +12,6 @@ import android.os.Parcel;
 import android.support.annotation.MainThread;
 import android.util.Log;
 
-import com.google.android.gms.gcm.GoogleCloudMessaging;
 import com.google.ipc.invalidation.ticl.android2.channel.GcmUpstreamSenderService;
 
 import org.chromium.base.ContextUtils;
@@ -96,20 +95,6 @@ public class InvalidationGcmUpstreamSender extends GcmUpstreamSenderService {
      * This function runs on a thread from the AsyncTask.THREAD_POOL_EXECUTOR.
      */
     private void sendUpstreamMessage(String to, Bundle data, String token, Context context) {
-        // Add the OAuth2 token to the bundle. The token should have the prefix Bearer added to it.
-        data.putString("Authorization", "Bearer " + token);
-        if (!isMessageWithinLimit(data)) {
-            GcmUma.recordGcmUpstreamHistogram(context, GcmUma.UMA_UPSTREAM_SIZE_LIMIT_EXCEEDED);
-            return;
-        }
-        String msgId = UUID.randomUUID().toString();
-        try {
-            GoogleCloudMessaging.getInstance(ContextUtils.getApplicationContext())
-                    .send(to, msgId, 1, data);
-        } catch (IOException | IllegalArgumentException exception) {
-            Log.w(TAG, "Send message failed");
-            GcmUma.recordGcmUpstreamHistogram(context, GcmUma.UMA_UPSTREAM_SEND_FAILED);
-        }
     }
 
     private boolean isMessageWithinLimit(Bundle data) {
diff --git a/chrome/android/java_sources.gni b/chrome/android/java_sources.gni
--- a/chrome/android/java_sources.gni
+++ b/chrome/android/java_sources.gni
@@ -27,7 +27,6 @@ chrome_java_sources = [
   "java/src/org/chromium/chrome/browser/ChromeActivity.java",
   "java/src/org/chromium/chrome/browser/ChromeActivitySessionTracker.java",
   "java/src/org/chromium/chrome/browser/ChromeApplication.java",
-  "java/src/org/chromium/chrome/browser/ChromeBackgroundService.java",
   "java/src/org/chromium/chrome/browser/ChromeBackupAgent.java",
   "java/src/org/chromium/chrome/browser/ChromeBackupWatcher.java",
   "java/src/org/chromium/chrome/browser/ChromeFeatureList.java",
@@ -1344,7 +1343,6 @@ chrome_java_sources = [
   "java/src/org/chromium/chrome/browser/services/AndroidEduAndChildAccountHelper.java",
   "java/src/org/chromium/chrome/browser/services/AndroidEduOwnerCheckCallback.java",
   "java/src/org/chromium/chrome/browser/services/GoogleServicesManager.java",
-  "java/src/org/chromium/chrome/browser/services/gcm/ChromeGcmListenerService.java",
   "java/src/org/chromium/chrome/browser/services/gcm/GCMBackgroundTask.java",
   "java/src/org/chromium/chrome/browser/services/gcm/GcmUma.java",
   "java/src/org/chromium/chrome/browser/services/gcm/InvalidationGcmUpstreamSender.java",
diff --git a/components/background_task_scheduler/BUILD.gn b/components/background_task_scheduler/BUILD.gn
--- a/components/background_task_scheduler/BUILD.gn
+++ b/components/background_task_scheduler/BUILD.gn
@@ -30,7 +30,6 @@ if (is_android) {
   android_library("background_task_scheduler_java") {
     java_files = [
       "android/java/src/org/chromium/components/background_task_scheduler/BackgroundTask.java",
-      "android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskGcmTaskService.java",
       "android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskJobService.java",
       "android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskReflection.java",
       "android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskScheduler.java",
diff --git a/components/background_task_scheduler/android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskSchedulerGcmNetworkManager.java b/components/background_task_scheduler/android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskSchedulerGcmNetworkManager.java
--- a/components/background_task_scheduler/android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskSchedulerGcmNetworkManager.java
+++ b/components/background_task_scheduler/android/java/src/org/chromium/components/background_task_scheduler/BackgroundTaskSchedulerGcmNetworkManager.java
@@ -8,14 +8,6 @@ import android.content.Context;
 import android.os.Bundle;
 import android.support.annotation.NonNull;
 
-import com.google.android.gms.common.ConnectionResult;
-import com.google.android.gms.common.GoogleApiAvailability;
-import com.google.android.gms.gcm.GcmNetworkManager;
-import com.google.android.gms.gcm.OneoffTask;
-import com.google.android.gms.gcm.PeriodicTask;
-import com.google.android.gms.gcm.Task;
-import com.google.android.gms.gcm.TaskParams;
-
 import org.chromium.base.Log;
 import org.chromium.base.ThreadUtils;
 import org.chromium.base.VisibleForTesting;
@@ -34,104 +26,6 @@ class BackgroundTaskSchedulerGcmNetworkManager implements BackgroundTaskSchedule
     @VisibleForTesting
     static final String BACKGROUND_TASK_EXTRAS_KEY = "_background_task_extras";
 
-    static BackgroundTask getBackgroundTaskFromTaskParams(@NonNull TaskParams taskParams) {
-        String backgroundTaskClassName = getBackgroundTaskClassFromTaskParams(taskParams);
-        return BackgroundTaskReflection.getBackgroundTaskFromClassName(backgroundTaskClassName);
-    }
-
-    private static String getBackgroundTaskClassFromTaskParams(@NonNull TaskParams taskParams) {
-        Bundle extras = taskParams.getExtras();
-        if (extras == null) return null;
-        return extras.getString(BACKGROUND_TASK_CLASS_KEY);
-    }
-
-    /**
-     * Retrieves the {@link TaskParameters} from the {@link TaskParams}, which are passed as
-     * one of the keys. Only values valid for {@link android.os.BaseBundle} are supported, and other
-     * values are stripped at the time when the task is scheduled.
-     *
-     * @param taskParams the {@link TaskParams} to extract the {@link TaskParameters} from.
-     * @return the {@link TaskParameters} for the current job.
-     */
-    static TaskParameters getTaskParametersFromTaskParams(@NonNull TaskParams taskParams) {
-        int taskId;
-        try {
-            taskId = Integer.parseInt(taskParams.getTag());
-        } catch (NumberFormatException e) {
-            Log.e(TAG, "Cound not parse task ID from task tag: " + taskParams.getTag());
-            return null;
-        }
-
-        TaskParameters.Builder builder = TaskParameters.create(taskId);
-
-        Bundle extras = taskParams.getExtras();
-        Bundle taskExtras = extras.getBundle(BACKGROUND_TASK_EXTRAS_KEY);
-        builder.addExtras(taskExtras);
-
-        return builder.build();
-    }
-
-    @VisibleForTesting
-    static Task createTaskFromTaskInfo(@NonNull TaskInfo taskInfo) {
-        Bundle taskExtras = new Bundle();
-        taskExtras.putString(
-                BACKGROUND_TASK_CLASS_KEY, taskInfo.getBackgroundTaskClass().getName());
-        taskExtras.putBundle(BACKGROUND_TASK_EXTRAS_KEY, taskInfo.getExtras());
-
-        Task.Builder builder;
-        if (taskInfo.isPeriodic()) {
-            builder = getPeriodicTaskBuilder(taskInfo.getPeriodicInfo());
-        } else {
-            builder = getOneOffTaskBuilder(taskInfo.getOneOffInfo());
-        }
-
-        builder.setExtras(taskExtras)
-                .setPersisted(taskInfo.isPersisted())
-                .setRequiredNetwork(getGcmNetworkManagerNetworkTypeFromTypeFromTaskNetworkType(
-                        taskInfo.getRequiredNetworkType()))
-                .setRequiresCharging(taskInfo.requiresCharging())
-                .setService(BackgroundTaskGcmTaskService.class)
-                .setTag(taskIdToTaskTag(taskInfo.getTaskId()))
-                .setUpdateCurrent(taskInfo.shouldUpdateCurrent());
-
-        return builder.build();
-    }
-
-    private static Task.Builder getPeriodicTaskBuilder(TaskInfo.PeriodicInfo periodicInfo) {
-        PeriodicTask.Builder builder = new PeriodicTask.Builder();
-        builder.setPeriod(TimeUnit.MILLISECONDS.toSeconds(periodicInfo.getIntervalMs()));
-        if (periodicInfo.hasFlex()) {
-            builder.setFlex(TimeUnit.MILLISECONDS.toSeconds(periodicInfo.getFlexMs()));
-        }
-        return builder;
-    }
-
-    private static Task.Builder getOneOffTaskBuilder(TaskInfo.OneOffInfo oneOffInfo) {
-        OneoffTask.Builder builder = new OneoffTask.Builder();
-        long windowStartSeconds = oneOffInfo.hasWindowStartTimeConstraint()
-                ? TimeUnit.MILLISECONDS.toSeconds(oneOffInfo.getWindowStartTimeMs())
-                : 0;
-        builder.setExecutionWindow(windowStartSeconds,
-                TimeUnit.MILLISECONDS.toSeconds(oneOffInfo.getWindowEndTimeMs()));
-        return builder;
-    }
-
-    private static int getGcmNetworkManagerNetworkTypeFromTypeFromTaskNetworkType(
-            @TaskInfo.NetworkType int networkType) {
-        switch (networkType) {
-            // This is correct: GcmNM ANY means no network is guaranteed.
-            case TaskInfo.NETWORK_TYPE_NONE:
-                return Task.NETWORK_STATE_ANY;
-            case TaskInfo.NETWORK_TYPE_ANY:
-                return Task.NETWORK_STATE_CONNECTED;
-            case TaskInfo.NETWORK_TYPE_UNMETERED:
-                return Task.NETWORK_STATE_UNMETERED;
-            default:
-                assert false;
-        }
-        return Task.NETWORK_STATE_ANY;
-    }
-
     @Override
     public boolean schedule(Context context, @NonNull TaskInfo taskInfo) {
         ThreadUtils.assertOnUiThread();
@@ -142,50 +36,12 @@ class BackgroundTaskSchedulerGcmNetworkManager implements BackgroundTaskSchedule
                             + " has no parameterless public constructor.");
             return false;
         }
-
-        GcmNetworkManager gcmNetworkManager = getGcmNetworkManager(context);
-        if (gcmNetworkManager == null) {
-            Log.e(TAG, "GcmNetworkManager is not available.");
-            return false;
-        }
-
-        try {
-            Task task = createTaskFromTaskInfo(taskInfo);
-            gcmNetworkManager.schedule(task);
-        } catch (IllegalArgumentException e) {
-            String gcmErrorMessage = e.getMessage() == null ? "null." : e.getMessage();
-            Log.e(TAG,
-                    "GcmNetworkManager failed to schedule task, gcm message: " + gcmErrorMessage);
-            return false;
-        }
-
-        return true;
+        return false;
     }
 
     @Override
     public void cancel(Context context, int taskId) {
         ThreadUtils.assertOnUiThread();
-
-        GcmNetworkManager gcmNetworkManager = getGcmNetworkManager(context);
-        if (gcmNetworkManager == null) {
-            Log.e(TAG, "GcmNetworkManager is not available.");
-            return;
-        }
-
-        try {
-            gcmNetworkManager.cancelTask(
-                    taskIdToTaskTag(taskId), BackgroundTaskGcmTaskService.class);
-        } catch (IllegalArgumentException e) {
-            Log.e(TAG, "GcmNetworkManager failed to cancel task.");
-        }
-    }
-
-    private GcmNetworkManager getGcmNetworkManager(Context context) {
-        if (GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(context)
-                == ConnectionResult.SUCCESS) {
-            return GcmNetworkManager.getInstance(context);
-        }
-        return null;
     }
 
     private static String taskIdToTaskTag(int taskId) {
diff --git a/components/gcm_driver/android/BUILD.gn b/components/gcm_driver/android/BUILD.gn
--- a/components/gcm_driver/android/BUILD.gn
+++ b/components/gcm_driver/android/BUILD.gn
@@ -15,7 +15,6 @@ android_library("gcm_driver_java") {
   deps = [
     "//base:base_java",
     "//content/public/android:content_java",
-    "//third_party/android_tools:android_gcm_java",
     "//third_party/jsr-305:jsr_305_javalib",
   ]
 
diff --git a/components/gcm_driver/instance_id/android/BUILD.gn b/components/gcm_driver/instance_id/android/BUILD.gn
--- a/components/gcm_driver/instance_id/android/BUILD.gn
+++ b/components/gcm_driver/instance_id/android/BUILD.gn
@@ -26,7 +26,6 @@ android_library("instance_id_driver_java") {
 
   java_files = [
     "java/src/org/chromium/components/gcm_driver/instance_id/InstanceIDBridge.java",
-    "java/src/org/chromium/components/gcm_driver/instance_id/InstanceIDWithSubtype.java",
   ]
 }
 
diff --git a/components/gcm_driver/instance_id/android/java/src/org/chromium/components/gcm_driver/instance_id/InstanceIDBridge.java b/components/gcm_driver/instance_id/android/java/src/org/chromium/components/gcm_driver/instance_id/InstanceIDBridge.java
--- a/components/gcm_driver/instance_id/android/java/src/org/chromium/components/gcm_driver/instance_id/InstanceIDBridge.java
+++ b/components/gcm_driver/instance_id/android/java/src/org/chromium/components/gcm_driver/instance_id/InstanceIDBridge.java
@@ -32,7 +32,6 @@ public class InstanceIDBridge {
      * Underlying InstanceIDWithSubtype. May be shared by multiple InstanceIDBridges. Must be
      * initialized on a background thread.
      */
-    private InstanceIDWithSubtype mInstanceID;
 
     private static boolean sBlockOnAsyncTasksForTesting;
 
@@ -108,7 +107,7 @@ public class InstanceIDBridge {
         new BridgeAsyncTask<String>() {
             @Override
             protected String doBackgroundWork() {
-                return mInstanceID.getId();
+                return "";
             }
             @Override
             protected void sendResultToNative(String id) {
@@ -123,7 +122,7 @@ public class InstanceIDBridge {
         new BridgeAsyncTask<Long>() {
             @Override
             protected Long doBackgroundWork() {
-                return mInstanceID.getCreationTime();
+                return 0L;
             }
             @Override
             protected void sendResultToNative(Long creationTime) {
@@ -148,12 +147,7 @@ public class InstanceIDBridge {
         new BridgeAsyncTask<String>() {
             @Override
             protected String doBackgroundWork() {
-                try {
-                    storeLazinessInformation(authorizedEntity, isLazy);
-                    return mInstanceID.getToken(authorizedEntity, scope, extras);
-                } catch (IOException ex) {
-                    return "";
-                }
+                return "";
             }
             @Override
             protected void sendResultToNative(String token) {
@@ -169,12 +163,7 @@ public class InstanceIDBridge {
         new BridgeAsyncTask<Boolean>() {
             @Override
             protected Boolean doBackgroundWork() {
-                try {
-                    mInstanceID.deleteToken(authorizedEntity, scope);
-                    return true;
-                } catch (IOException ex) {
-                    return false;
-                }
+                return true;
             }
             @Override
             protected void sendResultToNative(Boolean success) {
@@ -189,12 +178,7 @@ public class InstanceIDBridge {
         new BridgeAsyncTask<Boolean>() {
             @Override
             protected Boolean doBackgroundWork() {
-                try {
-                    mInstanceID.deleteInstanceID();
-                    return true;
-                } catch (IOException ex) {
-                    return false;
-                }
+                return true;
             }
             @Override
             protected void sendResultToNative(Boolean success) {
@@ -233,11 +217,6 @@ public class InstanceIDBridge {
                 @Override
                 @SuppressWarnings("NoSynchronizedThisCheck") // Only used/accessible by native.
                 protected Result doInBackground() {
-                    synchronized (InstanceIDBridge.this) {
-                        if (mInstanceID == null) {
-                            mInstanceID = InstanceIDWithSubtype.getInstance(mSubtype);
-                        }
-                    }
                     return doBackgroundWork();
                 }
                 @Override
diff --git a/components/sync/android/BUILD.gn b/components/sync/android/BUILD.gn
--- a/components/sync/android/BUILD.gn
+++ b/components/sync/android/BUILD.gn
@@ -11,7 +11,6 @@ android_library("sync_java") {
     "//components/signin/core/browser/android:java",
     "//net/android:net_java",
     "//third_party/android_deps:android_support_annotations_java",
-    "//third_party/android_tools:android_gcm_java",
     "//third_party/cacheinvalidation:cacheinvalidation_javalib",
     "//third_party/cacheinvalidation:cacheinvalidation_proto_java",
     "//third_party/jsr-305:jsr_305_javalib",
diff --git a/third_party/cacheinvalidation/BUILD.gn b/third_party/cacheinvalidation/BUILD.gn
--- a/third_party/cacheinvalidation/BUILD.gn
+++ b/third_party/cacheinvalidation/BUILD.gn
@@ -141,7 +141,6 @@ if (is_android) {
       "$google_play_services_package:google_play_services_iid_java",
       "$google_play_services_package:google_play_services_tasks_java",
       "//third_party/android_protobuf:protobuf_nano_javalib",
-      "//third_party/android_tools:android_gcm_java",
     ]
 
     java_files = [
@@ -207,13 +206,8 @@ if (is_android) {
       "src/java/com/google/ipc/invalidation/ticl/android2/WakeLockManager.java",
       "src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidChannelConstants.java",
       "src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidChannelPreferences.java",
-      "src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidGcmController.java",
-      "src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidInstanceIDListenerService.java",
-      "src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidMessageReceiverService.java",
-      "src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidMessageSenderService.java",
       "src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidNetworkChannel.java",
       "src/java/com/google/ipc/invalidation/ticl/android2/channel/CommonUtils.java",
-      "src/java/com/google/ipc/invalidation/ticl/android2/channel/GcmRegistrationTaskService.java",
       "src/java/com/google/ipc/invalidation/ticl/android2/channel/GcmUpstreamSenderService.java",
       "src/java/com/google/ipc/invalidation/ticl/proto/AndroidChannel.java",
       "src/java/com/google/ipc/invalidation/ticl/proto/AndroidListenerProtocol.java",
diff --git a/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/external/client/contrib/MultiplexingGcmListener.java b/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/external/client/contrib/MultiplexingGcmListener.java
--- a/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/external/client/contrib/MultiplexingGcmListener.java
+++ b/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/external/client/contrib/MultiplexingGcmListener.java
@@ -16,9 +16,6 @@
 
 package com.google.ipc.invalidation.external.client.contrib;
 
-import com.google.android.gcm.GCMBaseIntentService;
-import com.google.android.gcm.GCMBroadcastReceiver;
-import com.google.android.gcm.GCMRegistrar;
 import com.google.ipc.invalidation.external.client.SystemResources.Logger;
 import com.google.ipc.invalidation.external.client.android.service.AndroidLogger;
 import com.google.ipc.invalidation.ticl.android2.WakeLockManager;
@@ -69,7 +66,7 @@ import android.content.pm.ServiceInfo;
  * there is nothing to do except log an error (which this class does).
  *
  */
-public class MultiplexingGcmListener extends GCMBaseIntentService {
+public class MultiplexingGcmListener {
   /* This class is public so that it can be instantiated by the Android runtime. */
 
   /** Constants used in broadcast Intents. */
@@ -106,18 +103,6 @@ public class MultiplexingGcmListener extends GCMBaseIntentService {
   }
 
   /**
-   * {@link GCMBroadcastReceiver} that forwards GCM intents to the {@code MultiplexingGcmListener}
-   * class.
-   */
-  public static class GCMReceiver extends GCMBroadcastReceiver {
-    /* This class is public so that it can be instantiated by the Android runtime. */
-    @Override
-    protected String getGCMIntentServiceClassName(Context context) {
-      return MultiplexingGcmListener.class.getName();
-    }
-  }
-
-  /**
    * Convenience base class for client implementations. It provides base classes for a broadcast
    * receiver and an intent service that work together to handle events from the
    * {@code MultiplexingGcmListener} while holding a wake lock.
@@ -260,85 +245,10 @@ public class MultiplexingGcmListener extends GCMBaseIntentService {
   /** Logger. */
   private static final Logger logger = AndroidLogger.forTag("MplexGcmListener");
 
-  // All onYYY methods work by constructing an appropriate Intent and broadcasting it.
-
-  @Override
-  protected void onMessage(Context context, Intent intent) {
-    Intent newIntent = new Intent();
-    newIntent.putExtra(Intents.EXTRA_OP_MESSAGE, true);
-    newIntent.putExtras(intent);
-    rebroadcast(newIntent);
-  }
-
-  @Override
-  protected void onRegistered(Context context, String registrationId) {
-    Intent intent = new Intent();
-    intent.putExtra(Intents.EXTRA_OP_REGISTERED, true);
-    intent.putExtra(Intents.EXTRA_DATA_REG_ID, registrationId);
-    rebroadcast(intent);
-  }
-
-  @Override
-  protected void onUnregistered(Context context, String registrationId) {
-    Intent intent = new Intent();
-    intent.putExtra(Intents.EXTRA_OP_UNREGISTERED, true);
-    intent.putExtra(Intents.EXTRA_DATA_REG_ID, registrationId);
-    rebroadcast(intent);
-  }
-
-  @Override
-  protected void onDeletedMessages(Context context, int total) {
-    Intent intent = new Intent();
-    intent.putExtra(Intents.EXTRA_OP_DELETED_MESSAGES, true);
-    intent.putExtra(Intents.EXTRA_DATA_NUM_DELETED_MSGS, total);
-    rebroadcast(intent);
-  }
-
-  @Override
-  protected void onError(Context context, String errorId) {
-    // This is called for unrecoverable errors, so just log a warning.
-    logger.warning("GCM error: %s", errorId);
-  }
-
-  @Override
-  protected String[] getSenderIds(Context context) {
-    return readSenderIdsFromManifestOrDie(this);
-  }
-
-  /**
-   * Broadcasts {@code intent} with the action set to {@link Intents#ACTION} and the package name
-   * set to the package name of this service.
-   */
-  private void rebroadcast(Intent intent) {
-    intent.setAction(Intents.ACTION);
-    intent.setPackage(getPackageName());
-    sendBroadcast(intent);
-  }
-
-  /**
-   * Registers with GCM if not already registered. Also verifies that the device supports GCM
-   * and that the manifest is correctly configured. Returns the existing registration id, if one
-   * exists, or the empty string if one does not.
-   *
-   * @throws UnsupportedOperationException if the device does not have all GCM dependencies
-   * @throws IllegalStateException if the manifest is not correctly configured
-   */
-  public static String initializeGcm(Context context) {
-    AndroidChannelPreferences.setGcmChannelType(context, GcmChannelType.DEFAULT);
-    GCMRegistrar.checkDevice(context);
-    GCMRegistrar.checkManifest(context);
-    final String regId = GCMRegistrar.getRegistrationId(context);
-    if (regId.isEmpty()) {
-      GCMRegistrar.register(context, readSenderIdsFromManifestOrDie(context));
-    }
-    return regId;
-  }
-
   /**
    * Returns the GCM sender ids from {@link #GCM_SENDER_IDS_METADATA_KEY} or throws a
    * {@code RuntimeException} if they are not defined.
    */
-  
   static String[] readSenderIdsFromManifestOrDie(Context context) {
     try {
       ServiceInfo serviceInfo = context.getPackageManager().getServiceInfo(
diff --git a/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidNetworkChannel.java b/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidNetworkChannel.java
--- a/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidNetworkChannel.java
+++ b/third_party/cacheinvalidation/src/java/com/google/ipc/invalidation/ticl/android2/channel/AndroidNetworkChannel.java
@@ -48,16 +48,12 @@ public class AndroidNetworkChannel implements TestableNetworkChannel {
     Intent intent = ProtocolIntents.newOutboundMessageIntent(outgoingMessage);
 
     // Select the sender service to use for upstream message.
-    if (AndroidChannelPreferences.getGcmChannelType(context) == GcmChannelType.GCM_UPSTREAM){
-      String upstreamServiceClass = new AndroidTiclManifest(context).getGcmUpstreamServiceClass();
-      if (upstreamServiceClass == null || upstreamServiceClass.isEmpty()) {
-        logger.warning("GcmUpstreamSenderService class not found.");
-        return;
-      }
-      intent.setClassName(context, upstreamServiceClass);
-    } else {
-      intent.setClassName(context, AndroidMessageSenderService.class.getName());
-    }
+	  String upstreamServiceClass = new AndroidTiclManifest(context).getGcmUpstreamServiceClass();
+	  if (upstreamServiceClass == null || upstreamServiceClass.isEmpty()) {
+		logger.warning("GcmUpstreamSenderService class not found.");
+		return;
+	  }
+	  intent.setClassName(context, upstreamServiceClass);
     try {
       context.startService(intent);
     } catch (IllegalStateException exception) {
@@ -77,6 +73,6 @@ public class AndroidNetworkChannel implements TestableNetworkChannel {
 
   @Override
   public NetworkEndpointId getNetworkIdForTest() {
-    return AndroidMessageSenderService.getNetworkEndpointId(context, resources.getLogger());
+    return null;
   }
 }
-- 
2.11.0

