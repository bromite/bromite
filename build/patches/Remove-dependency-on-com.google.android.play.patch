From: Wengling Chen <feiyu2817@gmail.com>
Date: Fri, 1 Nov 2019 23:01:41 +0100
Subject: Remove dependency on com.google.android.play

FILE:Remove-dependency-on-com.google.android.play.patch
---
diff --git a/chrome/android/BUILD.gn b/chrome/android/BUILD.gn
index 9daafb322b..d814ba3d36 100644
--- a/chrome/android/BUILD.gn
+++ b/chrome/android/BUILD.gn
@@ -525,7 +525,6 @@ android_library("chrome_java") {
     "//third_party/blink/public/mojom:android_mojo_bindings_java",
     "//third_party/blink/public/mojom:mojom_platform_java",
     "//third_party/gif_player:gif_player_java",
-    "//third_party/google_android_play_core:com_google_android_play_core_java",
     "//third_party/metrics_proto:metrics_proto_java",
     "//ui/android:ui_java",
     "//ui/base/mojom:mojom_java",
@@ -2203,7 +2202,6 @@ android_library("base_module_java") {
     "//third_party/android_deps:androidx_annotation_annotation_java",
     "//third_party/android_deps:androidx_collection_collection_java",
     "//third_party/android_deps:androidx_fragment_fragment_java",
-    "//third_party/google_android_play_core:com_google_android_play_core_java",
     "//ui/android:ui_no_recycler_view_java",
 
     # Deps needed for child processes.
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/language/AppLocaleUtils.java b/chrome/android/java/src/org/chromium/chrome/browser/language/AppLocaleUtils.java
index 0b6ed7044b..1ded3d4169 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/language/AppLocaleUtils.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/language/AppLocaleUtils.java
@@ -8,11 +8,6 @@ import android.content.Context;
 import android.preference.PreferenceManager;
 import android.text.TextUtils;
 
-import com.google.android.play.core.splitcompat.SplitCompat;
-import com.google.android.play.core.splitinstall.SplitInstallManager;
-import com.google.android.play.core.splitinstall.SplitInstallManagerFactory;
-import com.google.android.play.core.splitinstall.SplitInstallRequest;
-
 import org.chromium.base.BundleUtils;
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
@@ -71,54 +66,5 @@ public class AppLocaleUtils {
     public static void setAppLanguagePref(String languageName) {
         SharedPreferencesManager.getInstance().writeString(
                 ChromePreferenceKeys.APPLICATION_OVERRIDE_LANGUAGE, languageName);
-        if (BundleUtils.isBundle()) {
-            ensureLanguageSplitInstalled(languageName);
-        }
-    }
-
-    /**
-     * Enable access to language split for bundle builds with an override language set.
-     * @param context Activity context to enable downloaded language splits on.
-     */
-    public static void maybeInstallActivitySplitCompat(Context context) {
-        if (GlobalAppLocaleController.getInstance().isOverridden() && BundleUtils.isBundle()) {
-            Log.i(TAG, "maybeInstallActivitySplit isOverridden: %s  isBundle: %s",
-                    GlobalAppLocaleController.getInstance().isOverridden(), BundleUtils.isBundle());
-            Log.i(TAG, "Override Locale: %s", getAppLanguagePref());
-            logInstalledLanguages(context);
-            SplitCompat.installActivity(context);
-            logInstalledLanguages(context);
-        }
-    }
-
-    /**
-     * For bundle builds ensure that the language split for languageName is downloaded.
-     */
-    private static void ensureLanguageSplitInstalled(String languageName) {
-        SplitInstallManager splitInstallManager =
-                SplitInstallManagerFactory.create(ContextUtils.getApplicationContext());
-
-        // TODO(perrier): check if languageName is already installed. https://crbug.com/1103806
-        if (!TextUtils.equals(languageName, SYSTEM_LANGUAGE_VALUE)) {
-            SplitInstallRequest installRequest =
-                    SplitInstallRequest.newBuilder()
-                            .addLanguage(Locale.forLanguageTag(languageName))
-                            .build();
-            splitInstallManager.startInstall(installRequest);
-        }
-    }
-
-    /**
-     * Log list of installed languages for context.
-     * @param context Context to log installed languages on.
-     */
-    private static void logInstalledLanguages(Context context) {
-        if (BundleUtils.isBundle()) {
-            SplitInstallManager splitInstallManager = SplitInstallManagerFactory.create(context);
-            Log.i(TAG, "Installed Languages: %s",
-                    TextUtils.join(", ", splitInstallManager.getInstalledLanguages()));
-        } else {
-            Log.i(TAG, "Installed Languages: None - not a bundle");
-        }
     }
 }
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/omaha/inline/FakeAppUpdateManagerWrapper.java b/chrome/android/java/src/org/chromium/chrome/browser/omaha/inline/FakeAppUpdateManagerWrapper.java
index 34c2c399c1..5d4b8d69e0 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/omaha/inline/FakeAppUpdateManagerWrapper.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/omaha/inline/FakeAppUpdateManagerWrapper.java
@@ -11,11 +11,6 @@ import android.os.Message;
 
 import androidx.annotation.IntDef;
 
-import com.google.android.play.core.appupdate.AppUpdateInfo;
-import com.google.android.play.core.appupdate.testing.FakeAppUpdateManager;
-import com.google.android.play.core.install.model.AppUpdateType;
-import com.google.android.play.core.tasks.Task;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.task.PostTask;
 import org.chromium.chrome.browser.app.ChromeActivity;
@@ -31,7 +26,7 @@ import java.lang.ref.WeakReference;
  * wrapper isn't meant to be used for a full integration test, but simulating all of the possible
  * error cases is a bit easier to do here.
  */
-public class FakeAppUpdateManagerWrapper extends FakeAppUpdateManager {
+public class FakeAppUpdateManagerWrapper {
     private static final int RESULT_IN_APP_UPDATE_FAILED = 1;
     private static final int STEP_DELAY_MS = 5000;
     private static final int TOAST_DURATION_MS = 2000;
@@ -108,15 +103,12 @@ public class FakeAppUpdateManagerWrapper extends FakeAppUpdateManager {
             switch (event) {
                 case Event.UPDATE_AVAILABLE:
                     w.toast("Making app update available.");
-                    w.setUpdateAvailable(10000 /* Figure out a better version? */);
                     return;
                 case Event.USER_ACCEPTS_UPDATE:
                     w.toast("User accepts update.");
-                    w.userAcceptsUpdate();
                     return;
                 case Event.USER_REJECTS_UPDATE:
                     w.toast("User rejects update.");
-                    w.userRejectsUpdate();
                     return;
                 case Event.TRIGGER_DOWNLOAD:
                     w.toast("Triggering download.");
@@ -124,27 +116,21 @@ public class FakeAppUpdateManagerWrapper extends FakeAppUpdateManager {
                     return;
                 case Event.DOWNLOAD_STARTS:
                     w.toast("Download has started.");
-                    w.downloadStarts();
                     return;
                 case Event.DOWNLOAD_FAILS:
                     w.toast("Triggering download failure.");
-                    w.downloadFails();
                     return;
                 case Event.USER_CANCELS_DOWNLOAD:
                     w.toast("Triggering cancellation of download.");
-                    w.userCancelsDownload();
                     return;
                 case Event.DOWNLOAD_COMPLETES:
                     w.toast("Download completes.");
-                    w.downloadCompletes();
                     return;
                 case Event.INSTALL_FAILS:
                     w.toast("Triggering install failure.");
-                    w.installFails();
                     return;
                 case Event.INSTALL_COMPLETES:
                     w.toast("Triggering install completion.");
-                    w.installCompletes();
                     return;
                 default:
                     w.toast("Unknown event.");
@@ -159,56 +145,12 @@ public class FakeAppUpdateManagerWrapper extends FakeAppUpdateManager {
      * @param endState at which point should the inline update flow end.
      */
     FakeAppUpdateManagerWrapper(@Type int endState) {
-        super(ContextUtils.getApplicationContext());
         mType = endState;
         mEventHandler = new EventHandler(this);
 
         if (mType != Type.NONE) execute(Event.UPDATE_AVAILABLE);
     }
 
-    // FakeAppUpdateManager implementation.
-    @Override
-    public boolean startUpdateFlowForResult(AppUpdateInfo appUpdateInfo,
-            @AppUpdateType int appUpdateType, Activity activity, int requestCode) {
-        toast("Starting update flow.");
-        // TODO(dtrainor): Simulate exceptions being thrown or returning false from the super call.
-        boolean success =
-                super.startUpdateFlowForResult(appUpdateInfo, appUpdateType, activity, requestCode);
-        if (!success) return false;
-
-        assert activity instanceof ChromeActivity : "Unexpected triggering activity.";
-
-        final int resultCode;
-        if (mType == Type.FAIL_DIALOG_CANCEL) {
-            resultCode = Activity.RESULT_CANCELED;
-        } else if (mType == Type.FAIL_DIALOG_UPDATE_FAILED) {
-            resultCode = RESULT_IN_APP_UPDATE_FAILED;
-        } else {
-            resultCode = Activity.RESULT_OK;
-        }
-
-        PostTask.postDelayedTask(UiThreadTaskTraits.DEFAULT, () -> {
-            triggerDialogResponse((ChromeActivity) activity, requestCode, resultCode);
-        }, STEP_DELAY_MS);
-
-        return true;
-    }
-
-    @Override
-    public Task<Void> completeUpdate() {
-        toast("Completing update.");
-        Task<Void> result = super.completeUpdate();
-
-        if (mType == Type.FAIL_INSTALL) {
-            postDelayedEvent(Event.INSTALL_FAILS);
-        } else {
-            postDelayedEvent(Event.INSTALL_COMPLETES);
-            // This doesn't actually restart Chrome in this case.
-        }
-
-        return result;
-    }
-
     private void triggerDialogResponse(ChromeActivity activity, int requestCode, int resultCode) {
         if (resultCode == Activity.RESULT_OK) {
             execute(Event.USER_ACCEPTS_UPDATE);
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/omaha/inline/InlineUpdateControllerFactory.java b/chrome/android/java/src/org/chromium/chrome/browser/omaha/inline/InlineUpdateControllerFactory.java
index 94e56084b6..70248ff38c 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/omaha/inline/InlineUpdateControllerFactory.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/omaha/inline/InlineUpdateControllerFactory.java
@@ -4,8 +4,6 @@
 
 package org.chromium.chrome.browser.omaha.inline;
 
-import com.google.android.play.core.appupdate.AppUpdateManagerFactory;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.chrome.browser.flags.ChromeFeatureList;
 import org.chromium.chrome.browser.omaha.UpdateConfigs;
@@ -20,20 +18,6 @@ public class InlineUpdateControllerFactory {
     public static InlineUpdateController create(Runnable callback) {
         @FakeAppUpdateManagerWrapper.Type
         int mockInlineEndState = UpdateConfigs.getMockInlineScenarioEndState();
-        if (mockInlineEndState != FakeAppUpdateManagerWrapper.Type.NO_SIMULATION) {
-            // The config requires to run through a test controller, using the
-            // PlayInlineUpdateController, but with a fake Google Play backend that automatically
-            // goes through a scenario flow.
-            return new PlayInlineUpdateController(
-                    callback, new FakeAppUpdateManagerWrapper(mockInlineEndState));
-        }
-
-        if (ChromeFeatureList.isEnabled(ChromeFeatureList.INLINE_UPDATE_FLOW)) {
-            // The application configuration requires to use the real Google Play backend for inline
-            // updates.
-            return new PlayInlineUpdateController(
-                    callback, AppUpdateManagerFactory.create(ContextUtils.getApplicationContext()));
-        }
 
         // No test scenario was in place, and the inline flow has not been enabled, so use a
         // controller with no functionality.
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/omaha/inline/PlayInlineUpdateController.java b/chrome/android/java/src/org/chromium/chrome/browser/omaha/inline/PlayInlineUpdateController.java
index e376e8176d..0c2a71ea16 100644
--- a/chrome/android/java/src/org/chromium/chrome/browser/omaha/inline/PlayInlineUpdateController.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/omaha/inline/PlayInlineUpdateController.java
@@ -10,15 +10,6 @@ import android.content.IntentSender.SendIntentException;
 import androidx.annotation.IntDef;
 import androidx.annotation.Nullable;
 
-import com.google.android.play.core.appupdate.AppUpdateInfo;
-import com.google.android.play.core.appupdate.AppUpdateManager;
-import com.google.android.play.core.install.InstallState;
-import com.google.android.play.core.install.InstallStateUpdatedListener;
-import com.google.android.play.core.install.model.AppUpdateType;
-import com.google.android.play.core.install.model.InstallErrorCode;
-import com.google.android.play.core.install.model.InstallStatus;
-import com.google.android.play.core.install.model.UpdateAvailability;
-
 import org.chromium.base.Log;
 import org.chromium.base.metrics.RecordHistogram;
 import org.chromium.chrome.browser.omaha.UpdateStatusProvider.UpdateState;
@@ -32,7 +23,7 @@ import java.lang.annotation.RetentionPolicy;
  * in the foreground.
  */
 public class PlayInlineUpdateController
-        implements InlineUpdateController, InstallStateUpdatedListener {
+        implements InlineUpdateController {
     /**
      * Converts Play's InstallErrorCode enum to a stable monotomically incrementing Chrome enum.
      * This is used for metric stability.
@@ -127,26 +118,9 @@ public class PlayInlineUpdateController
     private static final int RESULT_IN_APP_UPDATE_FAILED = 1;
     private static final int REQUEST_CODE = 8123;
 
-    private final Runnable mCallback;
-    private final AppUpdateManager mAppUpdateManager;
-
     private boolean mEnabled;
     private @Nullable @UpdateState Integer mUpdateState;
 
-    private AppUpdateInfo mAppUpdateInfo;
-    private @Nullable @UpdateAvailability Integer mUpdateAvailability;
-    private @Nullable @InstallStatus Integer mInstallStatus;
-
-    /**
-     * Builds an instance of {@link PlayInlineUpdateController}.
-     * @param callback The {@link Runnable} to notify when an inline update state change occurs.
-     */
-    PlayInlineUpdateController(Runnable callback, AppUpdateManager appUpdateManager) {
-        mCallback = callback;
-        mAppUpdateManager = appUpdateManager;
-        setEnabled(true);
-    }
-
     // InlineUpdateController implementation.
     @Override
     public void setEnabled(boolean enabled) {
@@ -155,10 +129,8 @@ public class PlayInlineUpdateController
 
         if (mEnabled) {
             mUpdateState = UpdateState.NONE;
-            mAppUpdateManager.registerListener(this);
             pullCurrentState();
         } else {
-            mAppUpdateManager.unregisterListener(this);
         }
     }
 
@@ -169,220 +141,26 @@ public class PlayInlineUpdateController
 
     @Override
     public void startUpdate(Activity activity) {
-        try {
-            boolean success = mAppUpdateManager.startUpdateFlowForResult(
-                    mAppUpdateInfo, AppUpdateType.FLEXIBLE, activity, REQUEST_CODE);
-            Log.i(TAG, "startUpdateFlowForResult() returned " + success);
-
-            if (!success) recordCallFailure(CallFailure.START_FAILED);
-        } catch (SendIntentException exception) {
-            mInstallStatus = InstallStatus.FAILED;
-            Log.i(TAG, "startUpdateFlowForResult() threw an exception.");
-            recordCallFailure(CallFailure.START_EXCEPTION);
-        }
-        // TODO(dtrainor): Use success.
     }
 
     @Override
     public void completeUpdate() {
-        mAppUpdateManager.completeUpdate()
-                .addOnSuccessListener(unused -> {
-                    Log.i(TAG, "completeUpdate() success.");
-                    pushStatus();
-                })
-                .addOnFailureListener(exception -> {
-                    Log.i(TAG, "completeUpdate() failed.");
-                    recordCallFailure(CallFailure.COMPLETE_FAILED);
-                    mInstallStatus = InstallStatus.FAILED;
-                    pushStatus();
-                });
-    }
-
-    // InstallStateUpdatedListener implementation.
-    @Override
-    public void onStateUpdate(InstallState state) {
-        Log.i(TAG,
-                "onStateUpdate(" + state.installStatus() + ", " + state.installErrorCode() + ")");
-
-        if (state.installStatus() != mInstallStatus) {
-            RecordHistogram.recordEnumeratedHistogram("GoogleUpdate.Inline.StateChange.Error."
-                            + installStatusToEnumSuffix(state.installStatus()),
-                    installErrorCodeToMetrics(state.installErrorCode()),
-                    InstallErrorCodeMetrics.NUM_ENTRIES);
-        }
-
-        mInstallStatus = state.installStatus();
-        pushStatus();
     }
 
     private void pullCurrentState() {
-        mAppUpdateManager.getAppUpdateInfo()
-                .addOnSuccessListener(info -> {
-                    mAppUpdateInfo = info;
-                    mUpdateAvailability = info.updateAvailability();
-                    mInstallStatus = info.installStatus();
-                    Log.i(TAG,
-                            "pullCurrentState(" + mUpdateAvailability + ", " + mInstallStatus
-                                    + ") success.");
-                    recordOnAppUpdateInfo(info);
-                    pushStatus();
-                })
-                .addOnFailureListener(exception -> {
-                    mAppUpdateInfo = null;
-                    mUpdateAvailability = UpdateAvailability.UNKNOWN;
-                    mInstallStatus = InstallStatus.UNKNOWN;
-                    Log.i(TAG, "pullCurrentState() failed.");
-                    recordCallFailure(CallFailure.QUERY_FAILED);
-                    pushStatus();
-                });
     }
 
     private void pushStatus() {
-        if (!mEnabled || mUpdateAvailability == null || mInstallStatus == null) return;
-
-        @UpdateState
-        int newState = toUpdateState(mUpdateAvailability, mInstallStatus);
-        if (mUpdateState != null && mUpdateState == newState) return;
-
-        Log.i(TAG, "Pushing inline update state to " + newState);
-        mUpdateState = newState;
-        mCallback.run();
     }
 
     private static @UpdateState int toUpdateState(
-            @UpdateAvailability int updateAvailability, @InstallStatus int installStatus) {
+            int updateAvailability, int installStatus) {
         @UpdateState
         int newStatus = UpdateState.NONE;
 
-        // Note, use InstallStatus first then UpdateAvailability if InstallStatus doesn't indicate
-        // a currently active install.
-        switch (installStatus) {
-            case InstallStatus.PENDING:
-                // Intentional fall through.
-            case InstallStatus.DOWNLOADING:
-                newStatus = UpdateState.INLINE_UPDATE_DOWNLOADING;
-                break;
-            case InstallStatus.DOWNLOADED:
-                newStatus = UpdateState.INLINE_UPDATE_READY;
-                break;
-            case InstallStatus.FAILED:
-                newStatus = UpdateState.INLINE_UPDATE_FAILED;
-                break;
-        }
-
-        if (newStatus == UpdateState.NONE) {
-            switch (updateAvailability) {
-                case UpdateAvailability.UPDATE_AVAILABLE:
-                    newStatus = UpdateState.INLINE_UPDATE_AVAILABLE;
-                    break;
-            }
-        }
-
         return newStatus;
     }
 
-    private static String installStatusToEnumSuffix(@InstallStatus int status) {
-        switch (status) {
-            case InstallStatus.UNKNOWN:
-                return "Unknown";
-            case InstallStatus.REQUIRES_UI_INTENT:
-                return "RequiresUiIntent";
-            case InstallStatus.PENDING:
-                return "Pending";
-            case InstallStatus.DOWNLOADING:
-                return "Downloading";
-            case InstallStatus.DOWNLOADED:
-                return "Downloaded";
-            case InstallStatus.INSTALLING:
-                return "Installing";
-            case InstallStatus.INSTALLED:
-                return "Installed";
-            case InstallStatus.FAILED:
-                return "Failed";
-            case InstallStatus.CANCELED:
-                return "Canceled";
-            default:
-                return "Untracked";
-        }
-    }
-
-    private static @InstallErrorCodeMetrics int installErrorCodeToMetrics(
-            @InstallErrorCode int error) {
-        switch (error) {
-            case InstallErrorCode.NO_ERROR:
-                return InstallErrorCodeMetrics.NO_ERROR;
-            case InstallErrorCode.NO_ERROR_PARTIALLY_ALLOWED:
-                return InstallErrorCodeMetrics.NO_ERROR_PARTIALLY_ALLOWED;
-            case InstallErrorCode.ERROR_UNKNOWN:
-                return InstallErrorCodeMetrics.ERROR_UNKNOWN;
-            case InstallErrorCode.ERROR_API_NOT_AVAILABLE:
-                return InstallErrorCodeMetrics.ERROR_API_NOT_AVAILABLE;
-            case InstallErrorCode.ERROR_INVALID_REQUEST:
-                return InstallErrorCodeMetrics.ERROR_INVALID_REQUEST;
-            case InstallErrorCode.ERROR_INSTALL_UNAVAILABLE:
-                return InstallErrorCodeMetrics.ERROR_INSTALL_UNAVAILABLE;
-            case InstallErrorCode.ERROR_INSTALL_NOT_ALLOWED:
-                return InstallErrorCodeMetrics.ERROR_INSTALL_NOT_ALLOWED;
-            case InstallErrorCode.ERROR_DOWNLOAD_NOT_PRESENT:
-                return InstallErrorCodeMetrics.ERROR_DOWNLOAD_NOT_PRESENT;
-            case InstallErrorCode.ERROR_INTERNAL_ERROR:
-                return InstallErrorCodeMetrics.ERROR_INTERNAL_ERROR;
-            default:
-                return InstallErrorCodeMetrics.ERROR_UNTRACKED;
-        }
-    }
-
-    private static @UpdateAvailabilityMetric int updateAvailabilityToMetrics(
-            @UpdateAvailability int updateAvailability) {
-        switch (updateAvailability) {
-            case UpdateAvailability.UNKNOWN:
-                return UpdateAvailabilityMetric.UNKNOWN;
-            case UpdateAvailability.UPDATE_NOT_AVAILABLE:
-                return UpdateAvailabilityMetric.UPDATE_NOT_AVAILABLE;
-            case UpdateAvailability.UPDATE_AVAILABLE:
-                return UpdateAvailabilityMetric.UPDATE_AVAILABLE;
-            case UpdateAvailability.DEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS:
-                return UpdateAvailabilityMetric.DEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS;
-            default:
-                return UpdateAvailabilityMetric.UNTRACKED;
-        }
-    }
-
-    private static @InstallStatusMetric int installStatusToMetrics(
-            @InstallStatus int installStatus) {
-        switch (installStatus) {
-            case InstallStatus.UNKNOWN:
-                return InstallStatusMetric.UNKNOWN;
-            case InstallStatus.REQUIRES_UI_INTENT:
-                return InstallStatusMetric.REQUIRES_UI_INTENT;
-            case InstallStatus.PENDING:
-                return InstallStatusMetric.PENDING;
-            case InstallStatus.DOWNLOADING:
-                return InstallStatusMetric.DOWNLOADING;
-            case InstallStatus.DOWNLOADED:
-                return InstallStatusMetric.DOWNLOADED;
-            case InstallStatus.INSTALLING:
-                return InstallStatusMetric.INSTALLING;
-            case InstallStatus.INSTALLED:
-                return InstallStatusMetric.INSTALLED;
-            case InstallStatus.FAILED:
-                return InstallStatusMetric.FAILED;
-            case InstallStatus.CANCELED:
-                return InstallStatusMetric.CANCELED;
-            default:
-                return InstallStatusMetric.UNTRACKED;
-        }
-    }
-
-    private static void recordOnAppUpdateInfo(AppUpdateInfo info) {
-        RecordHistogram.recordEnumeratedHistogram(
-                "GoogleUpdate.Inline.AppUpdateInfo.UpdateAvailability",
-                updateAvailabilityToMetrics(info.updateAvailability()),
-                UpdateAvailabilityMetric.NUM_ENTRIES);
-        RecordHistogram.recordEnumeratedHistogram("GoogleUpdate.Inline.AppUpdateInfo.InstallStatus",
-                installStatusToMetrics(info.installStatus()), InstallStatusMetric.NUM_ENTRIES);
-    }
-
     private static void recordCallFailure(@CallFailure int failure) {
         RecordHistogram.recordEnumeratedHistogram(
                 "GoogleUpdate.Inline.CallFailure", failure, CallFailure.NUM_ENTRIES);
diff --git a/components/module_installer/android/BUILD.gn b/components/module_installer/android/BUILD.gn
index 67028f66c5..64d19aade7 100644
--- a/components/module_installer/android/BUILD.gn
+++ b/components/module_installer/android/BUILD.gn
@@ -37,7 +37,6 @@ android_library("module_installer_java") {
     "//base:jni_java",
     "//components/crash/android:java",
     "//third_party/android_deps:androidx_annotation_annotation_java",
-    "//third_party/google_android_play_core:com_google_android_play_core_java",
   ]
 
   annotation_processor_deps = [ "//base/android/jni_generator:jni_processor" ]
@@ -60,7 +59,6 @@ junit_binary("module_installer_junit_tests") {
     "//base:base_java",
     "//base:base_java_test_support",
     "//base:base_junit_test_support",
-    "//third_party/google_android_play_core:com_google_android_play_core_java",
     "//third_party/hamcrest:hamcrest_java",
   ]
 }
diff --git a/components/module_installer/android/java/src/org/chromium/components/module_installer/engine/FakeEngine.java b/components/module_installer/android/java/src/org/chromium/components/module_installer/engine/FakeEngine.java
index c129ce772c..1aacbc81b5 100644
--- a/components/module_installer/android/java/src/org/chromium/components/module_installer/engine/FakeEngine.java
+++ b/components/module_installer/android/java/src/org/chromium/components/module_installer/engine/FakeEngine.java
@@ -7,9 +7,6 @@ package org.chromium.components.module_installer.engine;
 import android.content.Context;
 import android.content.pm.PackageManager;
 
-import com.google.android.play.core.splitcompat.SplitCompat;
-import com.google.android.play.core.splitcompat.ingestion.Verifier;
-
 import org.chromium.base.BuildInfo;
 import org.chromium.base.ContextUtils;
 import org.chromium.base.Log;
@@ -54,7 +51,6 @@ class FakeEngine extends SplitCompatEngine {
 
             @Override
             protected void onPostExecute(Boolean success) {
-                notifyListener(listener, success);
             }
         }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
     }
@@ -129,18 +125,8 @@ class FakeEngine extends SplitCompatEngine {
             return false;
         }
 
-        // Check that the module's signature matches Chrome's.
-        try {
-            Verifier verifier = new Verifier(context);
-            if (!verifier.verifySplits()) {
-                return false;
-            }
-        } catch (IOException | PackageManager.NameNotFoundException e) {
-            return false;
-        }
-
         // Tell SplitCompat to do a full emulation of the module.
-        return SplitCompat.fullInstall(context);
+        return false;
     }
 
     private File joinPaths(String... paths) {
diff --git a/components/module_installer/android/java/src/org/chromium/components/module_installer/engine/SplitCompatEngine.java b/components/module_installer/android/java/src/org/chromium/components/module_installer/engine/SplitCompatEngine.java
index 0a942452f5..5170666ae5 100644
--- a/components/module_installer/android/java/src/org/chromium/components/module_installer/engine/SplitCompatEngine.java
+++ b/components/module_installer/android/java/src/org/chromium/components/module_installer/engine/SplitCompatEngine.java
@@ -8,11 +8,6 @@ import android.app.Activity;
 
 import androidx.annotation.VisibleForTesting;
 
-import com.google.android.play.core.splitinstall.SplitInstallException;
-import com.google.android.play.core.splitinstall.SplitInstallRequest;
-import com.google.android.play.core.splitinstall.SplitInstallStateUpdatedListener;
-import com.google.android.play.core.splitinstall.model.SplitInstallSessionStatus;
-
 import org.chromium.base.ThreadUtils;
 
 import java.util.ArrayList;
@@ -28,7 +23,6 @@ import java.util.Set;
  */
 class SplitCompatEngine implements InstallEngine {
     private final SplitCompatEngineFacade mFacade;
-    private final SplitInstallStateUpdatedListener mUpdateListener = getStatusUpdateListener();
     private static final Map<String, List<InstallListener>> sSessions = new HashMap<>();
 
     public SplitCompatEngine() {
@@ -46,99 +40,17 @@ class SplitCompatEngine implements InstallEngine {
 
     @Override
     public boolean isInstalled(String moduleName) {
-        Set<String> installedModules = mFacade.getSplitManager().getInstalledModules();
-        return installedModules.contains(moduleName);
+        return false;
     }
 
     @Override
     public void installDeferred(String moduleName) {
-        mFacade.getSplitManager().deferredInstall(Collections.singletonList(moduleName));
         mFacade.getLogger().logRequestDeferredStart(moduleName);
     }
 
     @Override
     public void install(String moduleName, InstallListener listener) {
         ThreadUtils.assertOnUiThread();
-
-        if (sSessions.containsKey(moduleName)) {
-            sSessions.get(moduleName).add(listener);
-            return;
-        }
-
-        registerUpdateListener();
-
-        sSessions.put(moduleName, new ArrayList<InstallListener>() {
-            { add(listener); }
-        });
-
-        SplitInstallRequest request = mFacade.createSplitInstallRequest(moduleName);
-
-        mFacade.getSplitManager().startInstall(request).addOnFailureListener(ex -> {
-            // TODO(fredmello): look into potential issues with mixing split error code
-            // with our logger codes - fix accordingly.
-            mFacade.getLogger().logRequestFailure(moduleName,
-                    ex instanceof SplitInstallException
-                            ? ((SplitInstallException) ex).getErrorCode()
-                            : mFacade.getLogger().getUnknownRequestErrorCode());
-
-            String message = String.format(Locale.US, "Request Exception: %s", ex.getMessage());
-            notifyListeners(moduleName, false);
-        });
-
-        mFacade.getLogger().logRequestStart(moduleName);
-    }
-
-    private SplitInstallStateUpdatedListener getStatusUpdateListener() {
-        return state -> {
-            if (state.moduleNames().size() != 1) {
-                throw new UnsupportedOperationException("Only one module supported.");
-            }
-
-            int status = state.status();
-            String moduleName = state.moduleNames().get(0);
-
-            switch (status) {
-                case SplitInstallSessionStatus.INSTALLED:
-                    mFacade.updateCrashKeys();
-                    notifyListeners(moduleName, true);
-                    break;
-                case SplitInstallSessionStatus.FAILED:
-                    notifyListeners(moduleName, false);
-                    mFacade.getLogger().logStatusFailure(moduleName, state.errorCode());
-                    break;
-            }
-
-            mFacade.getLogger().logStatus(moduleName, status);
-        };
-    }
-
-    private void notifyListeners(String moduleName, Boolean success) {
-        for (InstallListener listener : sSessions.get(moduleName)) {
-            notifyListener(listener, success);
-        }
-
-        sSessions.remove(moduleName);
-        unregisterUpdateListener();
-    }
-
-    protected void notifyListener(InstallListener listener, Boolean success) {
-        if (success) {
-            mFacade.notifyObservers();
-        }
-
-        listener.onComplete(success);
-    }
-
-    private void registerUpdateListener() {
-        if (sSessions.size() == 0) {
-            mFacade.getSplitManager().registerListener(mUpdateListener);
-        }
-    }
-
-    private void unregisterUpdateListener() {
-        if (sSessions.size() == 0) {
-            mFacade.getSplitManager().unregisterListener(mUpdateListener);
-        }
     }
 
     @VisibleForTesting
diff --git a/components/module_installer/android/java/src/org/chromium/components/module_installer/engine/SplitCompatEngineFacade.java b/components/module_installer/android/java/src/org/chromium/components/module_installer/engine/SplitCompatEngineFacade.java
index 8ede45fa86..5ec404d59d 100644
--- a/components/module_installer/android/java/src/org/chromium/components/module_installer/engine/SplitCompatEngineFacade.java
+++ b/components/module_installer/android/java/src/org/chromium/components/module_installer/engine/SplitCompatEngineFacade.java
@@ -6,11 +6,6 @@ package org.chromium.components.module_installer.engine;
 
 import android.app.Activity;
 
-import com.google.android.play.core.splitcompat.SplitCompat;
-import com.google.android.play.core.splitinstall.SplitInstallManager;
-import com.google.android.play.core.splitinstall.SplitInstallManagerFactory;
-import com.google.android.play.core.splitinstall.SplitInstallRequest;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.components.module_installer.logger.Logger;
 import org.chromium.components.module_installer.logger.PlayCoreLogger;
@@ -21,16 +16,13 @@ import org.chromium.components.module_installer.util.ModuleUtil;
  * cannot be easily mocked and simplify the engine's design.
  */
 class SplitCompatEngineFacade {
-    private final SplitInstallManager mSplitManager;
     private final Logger mLogger;
 
     public SplitCompatEngineFacade() {
-        this(SplitInstallManagerFactory.create(ContextUtils.getApplicationContext()),
-                new PlayCoreLogger());
+        this(new PlayCoreLogger());
     }
 
-    public SplitCompatEngineFacade(SplitInstallManager manager, Logger umaLogger) {
-        mSplitManager = manager;
+    public SplitCompatEngineFacade(Logger umaLogger) {
         mLogger = umaLogger;
     }
 
@@ -38,24 +30,15 @@ class SplitCompatEngineFacade {
         return mLogger;
     }
 
-    public SplitInstallManager getSplitManager() {
-        return mSplitManager;
-    }
-
     public void installActivity(Activity activity) {
         // Note that SplitCompat (install) needs to be called on the Application Context prior
         // to calling this method - this is guaranteed by the behavior of SplitCompatEngine.
-        SplitCompat.installActivity(activity);
     }
 
     public void notifyObservers() {
         ModuleUtil.notifyModuleInstalled();
     }
 
-    public SplitInstallRequest createSplitInstallRequest(String moduleName) {
-        return SplitInstallRequest.newBuilder().addModule(moduleName).build();
-    }
-
     public void updateCrashKeys() {
         ModuleUtil.updateCrashKeys();
     }
diff --git a/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/Logger.java b/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/Logger.java
index 3c08215015..eb506cd7cd 100644
--- a/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/Logger.java
+++ b/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/Logger.java
@@ -4,9 +4,6 @@
 
 package org.chromium.components.module_installer.logger;
 
-import com.google.android.play.core.splitinstall.model.SplitInstallErrorCode;
-import com.google.android.play.core.splitinstall.model.SplitInstallSessionStatus;
-
 /**
  * Logger for SplitCompat Engine.
  */
@@ -17,7 +14,7 @@ public interface Logger {
      * @param moduleName The module name.
      * @param errorCode The error code.
      */
-    void logRequestFailure(String moduleName, @SplitInstallErrorCode int errorCode);
+    void logRequestFailure(String moduleName, int errorCode);
 
     /**
      * Logs exceptions that happen during the installation process.
@@ -25,7 +22,7 @@ public interface Logger {
      * @param moduleName The module name.
      * @param errorCode The error code.
      */
-    void logStatusFailure(String moduleName, @SplitInstallErrorCode int errorCode);
+    void logStatusFailure(String moduleName, int errorCode);
 
     /**
      * Logs the status count and duration during a module installation process.
@@ -33,7 +30,7 @@ public interface Logger {
      * @param moduleName The module name
      * @param status The status code
      */
-    void logStatus(String moduleName, @SplitInstallSessionStatus int status);
+    void logStatus(String moduleName, int status);
 
     /**
      * Logs the request start time.
diff --git a/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/PlayCoreLogger.java b/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/PlayCoreLogger.java
index 12a4a303a7..f82e39c45b 100644
--- a/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/PlayCoreLogger.java
+++ b/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/PlayCoreLogger.java
@@ -4,9 +4,6 @@
 
 package org.chromium.components.module_installer.logger;
 
-import com.google.android.play.core.splitinstall.model.SplitInstallErrorCode;
-import com.google.android.play.core.splitinstall.model.SplitInstallSessionStatus;
-
 /**
  * Concrete Logger for SplitCompat Installers (proxy to specific loggers).
  */
@@ -28,32 +25,19 @@ public class PlayCoreLogger implements Logger {
     }
 
     @Override
-    public void logRequestFailure(String moduleName, @SplitInstallErrorCode int errorCode) {
+    public void logRequestFailure(String moduleName, int errorCode) {
         mFailureLogger.logRequestFailure(moduleName, errorCode);
     }
 
     @Override
-    public void logStatusFailure(String moduleName, @SplitInstallErrorCode int errorCode) {
+    public void logStatusFailure(String moduleName, int errorCode) {
         mFailureLogger.logStatusFailure(moduleName, errorCode);
     }
 
     @Override
-    public void logStatus(String moduleName, @SplitInstallSessionStatus int status) {
+    public void logStatus(String moduleName, int status) {
         mStatusLogger.logStatusChange(moduleName, status);
-
-        if (status == SplitInstallSessionStatus.INSTALLED) {
-            mAvailabilityLogger.storeModuleInstalled(moduleName, status);
-            mAvailabilityLogger.logInstallTimes(moduleName);
-
-            // Keep old behavior where we log a 'success' bit with all other failures.
-            mFailureLogger.logStatusSuccess(moduleName);
-        } else if (status == SplitInstallSessionStatus.CANCELED) {
-            // Keep old behavior where we log a 'canceled' bit with all other failures.
-            mFailureLogger.logStatusCanceled(moduleName);
-        } else if (status == SplitInstallSessionStatus.DOWNLOADED) {
-            // Keep old behavior where we log a 'no split compat' bit with all other failures.
-            mFailureLogger.logStatusNoSplitCompat(moduleName);
-        }
+        mFailureLogger.logStatusCanceled(moduleName);
     }
 
     @Override
diff --git a/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/SplitAvailabilityLogger.java b/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/SplitAvailabilityLogger.java
index d0b2cf84a8..9266d053c1 100644
--- a/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/SplitAvailabilityLogger.java
+++ b/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/SplitAvailabilityLogger.java
@@ -9,10 +9,6 @@ import android.content.SharedPreferences;
 import android.os.SystemClock;
 import android.util.SparseLongArray;
 
-import com.google.android.play.core.splitinstall.SplitInstallManager;
-import com.google.android.play.core.splitinstall.SplitInstallManagerFactory;
-import com.google.android.play.core.splitinstall.model.SplitInstallSessionStatus;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.metrics.RecordHistogram;
 
@@ -48,25 +44,6 @@ public class SplitAvailabilityLogger {
      * Records via UMA all modules that have been requested and are currently installed.
      */
     public static void logModuleAvailability() {
-        SharedPreferences prefs = ContextUtils.getAppSharedPreferences();
-        Set<String> requestedModules = new HashSet<>();
-        requestedModules.addAll(prefs.getStringSet(ONDEMAND_REQ_PREV, new HashSet<>()));
-        requestedModules.addAll(prefs.getStringSet(DEFERRED_REQ_PREV, new HashSet<>()));
-
-        Context context = ContextUtils.getApplicationContext();
-        SplitInstallManager manager = SplitInstallManagerFactory.create(context);
-        Set<String> installedModules = manager.getInstalledModules();
-
-        for (String name : requestedModules) {
-            recordAvailabilityStatus(
-                    name, installedModules.contains(name) ? INSTALLED_REQUESTED : REQUESTED);
-        }
-
-        for (String name : installedModules) {
-            if (!requestedModules.contains(name)) {
-                recordAvailabilityStatus(name, INSTALLED_UNREQUESTED);
-            }
-        }
     }
 
     private static void recordAvailabilityStatus(String moduleName, int status) {
@@ -80,14 +57,6 @@ public class SplitAvailabilityLogger {
      * @param moduleName The module name.
      */
     public void logInstallTimes(String moduleName) {
-        recordInstallTime(moduleName, "", SplitInstallSessionStatus.UNKNOWN,
-                SplitInstallSessionStatus.INSTALLED);
-        recordInstallTime(moduleName, ".PendingDownload", SplitInstallSessionStatus.UNKNOWN,
-                SplitInstallSessionStatus.DOWNLOADING);
-        recordInstallTime(moduleName, ".Download", SplitInstallSessionStatus.DOWNLOADING,
-                SplitInstallSessionStatus.INSTALLING);
-        recordInstallTime(moduleName, ".Installing", SplitInstallSessionStatus.INSTALLING,
-                SplitInstallSessionStatus.INSTALLED);
     }
 
     /**
@@ -167,7 +136,6 @@ public class SplitAvailabilityLogger {
 
         public InstallTimes(boolean isCached) {
             mIsCached = isCached;
-            mInstallTimes.put(SplitInstallSessionStatus.UNKNOWN, SystemClock.uptimeMillis());
         }
     }
 }
diff --git a/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/SplitInstallFailureLogger.java b/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/SplitInstallFailureLogger.java
index 5114b9bb10..c0f5daa6dc 100644
--- a/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/SplitInstallFailureLogger.java
+++ b/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/SplitInstallFailureLogger.java
@@ -4,8 +4,6 @@
 
 package org.chromium.components.module_installer.logger;
 
-import com.google.android.play.core.splitinstall.model.SplitInstallErrorCode;
-
 import org.chromium.base.metrics.RecordHistogram;
 
 class SplitInstallFailureLogger {
@@ -38,40 +36,7 @@ class SplitInstallFailureLogger {
     // Keep this one at the end and increment appropriately when adding new status.
     private static final int COUNT = 22;
 
-    private int getHistogramCode(@SplitInstallErrorCode int errorCode) {
-        switch (errorCode) {
-            case SplitInstallErrorCode.NO_ERROR:
-                return NO_ERROR;
-            case SplitInstallErrorCode.ACTIVE_SESSIONS_LIMIT_EXCEEDED:
-                return ACTIVE_SESSIONS_LIMIT_EXCEEDED;
-            case SplitInstallErrorCode.MODULE_UNAVAILABLE:
-                return MODULE_UNAVAILABLE;
-            case SplitInstallErrorCode.INVALID_REQUEST:
-                return INVALID_REQUEST;
-            case SplitInstallErrorCode.SESSION_NOT_FOUND:
-                return SESSION_NOT_FOUND;
-            case SplitInstallErrorCode.API_NOT_AVAILABLE:
-                return API_NOT_AVAILABLE;
-            case SplitInstallErrorCode.NETWORK_ERROR:
-                return NETWORK_ERROR;
-            case SplitInstallErrorCode.ACCESS_DENIED:
-                return ACCESS_DENIED;
-            case SplitInstallErrorCode.INCOMPATIBLE_WITH_EXISTING_SESSION:
-                return INCOMPATIBLE_WITH_EXISTING_SESSION;
-            case SplitInstallErrorCode.SERVICE_DIED:
-                return SERVICE_DIED;
-            case SplitInstallErrorCode.INSUFFICIENT_STORAGE:
-                return INSUFFICIENT_STORAGE;
-            case SplitInstallErrorCode.SPLITCOMPAT_VERIFICATION_ERROR:
-                return SPLITCOMPAT_VERIFICATION_ERROR;
-            case SplitInstallErrorCode.SPLITCOMPAT_EMULATION_ERROR:
-                return SPLITCOMPAT_EMULATION_ERROR;
-            case SplitInstallErrorCode.SPLITCOMPAT_COPY_ERROR:
-                return SPLITCOMPAT_COPY_ERROR;
-            case SplitInstallErrorCode.INTERNAL_ERROR:
-                return INTERNAL_ERROR;
-        }
-
+    private int getHistogramCode(int errorCode) {
         return -1;
     }
 
@@ -87,12 +52,12 @@ class SplitInstallFailureLogger {
         log(moduleName, NO_SPLITCOMPAT);
     }
 
-    public void logStatusFailure(String moduleName, @SplitInstallErrorCode int errorCode) {
+    public void logStatusFailure(String moduleName, int errorCode) {
         Integer code = getHistogramCode(errorCode);
         log(moduleName, code == -1 ? UNKNOWN_SPLITINSTALL_ERROR : code);
     }
 
-    public void logRequestFailure(String moduleName, @SplitInstallErrorCode int errorCode) {
+    public void logRequestFailure(String moduleName, int errorCode) {
         Integer code = getHistogramCode(errorCode);
         log(moduleName, code == -1 ? UNKNOWN_REQUEST_ERROR : code);
     }
diff --git a/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/SplitInstallStatusLogger.java b/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/SplitInstallStatusLogger.java
index ddc8f7d0b8..0124b5c52a 100644
--- a/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/SplitInstallStatusLogger.java
+++ b/components/module_installer/android/java/src/org/chromium/components/module_installer/logger/SplitInstallStatusLogger.java
@@ -4,8 +4,6 @@
 
 package org.chromium.components.module_installer.logger;
 
-import com.google.android.play.core.splitinstall.model.SplitInstallSessionStatus;
-
 import org.chromium.base.metrics.RecordHistogram;
 
 class SplitInstallStatusLogger {
@@ -28,32 +26,11 @@ class SplitInstallStatusLogger {
     // Keep this one at the end and increment appropriately when adding new status.
     private static final int COUNT = 12;
 
-    private int getHistogramCode(@SplitInstallSessionStatus int code) {
-        switch (code) {
-            case SplitInstallSessionStatus.PENDING:
-                return PENDING;
-            case SplitInstallSessionStatus.DOWNLOADING:
-                return DOWNLOADING;
-            case SplitInstallSessionStatus.DOWNLOADED:
-                return DOWNLOADED;
-            case SplitInstallSessionStatus.INSTALLING:
-                return INSTALLING;
-            case SplitInstallSessionStatus.INSTALLED:
-                return INSTALLED;
-            case SplitInstallSessionStatus.FAILED:
-                return FAILED;
-            case SplitInstallSessionStatus.CANCELING:
-                return CANCELING;
-            case SplitInstallSessionStatus.CANCELED:
-                return CANCELED;
-            case SplitInstallSessionStatus.REQUIRES_USER_CONFIRMATION:
-                return REQUIRES_USER_CONFIRMATION;
-        }
-
+    private int getHistogramCode(int code) {
         return UNKNOWN_CODE;
     }
 
-    public void logStatusChange(String moduleName, @SplitInstallSessionStatus int status) {
+    public void logStatusChange(String moduleName, int status) {
         recordInstallStatus(moduleName, getHistogramCode(status));
     }
 
diff --git a/components/module_installer/android/java/src/org/chromium/components/module_installer/util/CrashKeyRecorder.java b/components/module_installer/android/java/src/org/chromium/components/module_installer/util/CrashKeyRecorder.java
index be7ab573cf..b72e4c9d1f 100644
--- a/components/module_installer/android/java/src/org/chromium/components/module_installer/util/CrashKeyRecorder.java
+++ b/components/module_installer/android/java/src/org/chromium/components/module_installer/util/CrashKeyRecorder.java
@@ -10,9 +10,6 @@ import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
 import android.text.TextUtils;
 
-import com.google.android.play.core.splitinstall.SplitInstallManager;
-import com.google.android.play.core.splitinstall.SplitInstallManagerFactory;
-
 import org.chromium.base.BuildInfo;
 import org.chromium.base.ContextUtils;
 import org.chromium.components.crash.CrashKeyIndex;
@@ -50,9 +47,6 @@ class CrashKeyRecorder {
         // are emulated. Therefore, use an empty set in that case.
         Set<String> emulatedModules = new TreeSet<>();
         if (SplitCompatInitializer.isInitialized()) {
-            SplitInstallManager manager = SplitInstallManagerFactory.create(context);
-            emulatedModules.addAll(manager.getInstalledModules());
-            emulatedModules.removeAll(fullyInstalledModules);
         }
 
         ck.set(CrashKeyIndex.INSTALLED_MODULES, encodeCrashKeyValue(fullyInstalledModules));
diff --git a/components/module_installer/android/java/src/org/chromium/components/module_installer/util/SplitCompatInitializer.java b/components/module_installer/android/java/src/org/chromium/components/module_installer/util/SplitCompatInitializer.java
index 4c73f0b4f1..beb1444066 100644
--- a/components/module_installer/android/java/src/org/chromium/components/module_installer/util/SplitCompatInitializer.java
+++ b/components/module_installer/android/java/src/org/chromium/components/module_installer/util/SplitCompatInitializer.java
@@ -4,8 +4,6 @@
 
 package org.chromium.components.module_installer.util;
 
-import com.google.android.play.core.splitcompat.SplitCompat;
-
 import org.chromium.base.ContextUtils;
 import org.chromium.base.StrictModeContext;
 import org.chromium.base.ThreadUtils;
@@ -23,10 +21,6 @@ class SplitCompatInitializer {
             return;
         }
 
-        // SplitCompat.install may copy modules into Chrome's internal folder or clean them up.
-        try (StrictModeContext ignored = StrictModeContext.allowDiskWrites()) {
-            SplitCompat.install(ContextUtils.getApplicationContext());
-        }
         sIsInitialized = true;
     }
 
diff --git a/third_party/google_android_play_core/BUILD.gn b/third_party/google_android_play_core/BUILD.gn
index d053015958..a8ac72ea45 100644
--- a/third_party/google_android_play_core/BUILD.gn
+++ b/third_party/google_android_play_core/BUILD.gn
@@ -3,8 +3,3 @@
 # found in the LICENSE file.
 
 import("//build/config/android/rules.gni")
-
-android_aar_prebuilt("com_google_android_play_core_java") {
-  aar_path = "core-1.6.4.aar"
-  info_path = "com_google_android_play_core.info"
-}
