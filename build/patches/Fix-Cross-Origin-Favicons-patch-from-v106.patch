From: Ari Chivukula <arichiv@chromium.org>
Date: Thu, 11 Aug 2022 00:39:04 +0000
Subject: Fix Cross-Origin Favicons
see https://bugs.chromium.org/p/chromium/issues/detail?id=1300214

---
 components/favicon/core/favicon_backend.cc  | 24 +++++++++++++-----
 components/favicon/core/favicon_database.cc | 27 +++++++++++++++++++++
 components/favicon/core/favicon_database.h  | 20 ++++++++++++---
 3 files changed, 62 insertions(+), 9 deletions(-)

diff --git a/components/favicon/core/favicon_backend.cc b/components/favicon/core/favicon_backend.cc
--- a/components/favicon/core/favicon_backend.cc
+++ b/components/favicon/core/favicon_backend.cc
@@ -17,6 +17,7 @@
 #include "components/favicon_base/select_favicon_frames.h"
 #include "third_party/skia/include/core/SkBitmap.h"
 #include "ui/gfx/codec/png_codec.h"
+#include "url/origin.h"
 
 namespace favicon {
 
@@ -211,20 +212,31 @@ UpdateFaviconMappingsResult FaviconBackend::UpdateFaviconMappingsAndFetch(
     favicon_base::IconType icon_type,
     const std::vector<int>& desired_sizes) {
   UpdateFaviconMappingsResult result;
-  const favicon_base::FaviconID favicon_id =
-      db_->GetFaviconIDForFaviconURL(icon_url, icon_type);
+  const auto favicon_id = db_->GetFaviconIDForFaviconURL(icon_url, icon_type);
   if (!favicon_id)
     return result;
+  bool per_origin_favicon_id_found = false;
 
   for (const GURL& page_url : page_urls) {
-    bool mappings_updated =
-        SetFaviconMappingsForPageAndRedirects(page_url, icon_type, favicon_id);
+    // We check per-origin so that we don't cross-origin load from the cache.
+    // See crbug.com/1300214 for more context.
+    const auto per_origin_favicon_id = db_->GetFaviconIDForFaviconURL(
+        icon_url, icon_type, url::Origin::Create(page_url));
+    if (!per_origin_favicon_id)
+      continue;
+    per_origin_favicon_id_found = true;
+    bool mappings_updated = SetFaviconMappingsForPageAndRedirects(
+        page_url, icon_type, per_origin_favicon_id);
     if (mappings_updated)
       result.updated_page_urls.insert(page_url);
   }
 
-  result.bitmap_results =
-      GetFaviconBitmapResultsForBestMatch({favicon_id}, desired_sizes);
+  // We add the favicon if at least one origin saw it *or* if this was loaded
+  // without linking the favicon to any page url (used by history service).
+  if (per_origin_favicon_id_found || page_urls.empty()) {
+    result.bitmap_results =
+        GetFaviconBitmapResultsForBestMatch({favicon_id}, desired_sizes);
+  }
   return result;
 }
 
diff --git a/components/favicon/core/favicon_database.cc b/components/favicon/core/favicon_database.cc
--- a/components/favicon/core/favicon_database.cc
+++ b/components/favicon/core/favicon_database.cc
@@ -29,6 +29,7 @@
 #include "sql/statement.h"
 #include "sql/transaction.h"
 #include "third_party/sqlite/sqlite3.h"
+#include "url/origin.h"
 
 #if BUILDFLAG(IS_APPLE)
 #include "base/mac/backup_util.h"
@@ -666,6 +667,32 @@ bool FaviconDatabase::GetFaviconLastUpdatedTime(favicon_base::FaviconID icon_id,
   return true;
 }
 
+favicon_base::FaviconID FaviconDatabase::GetFaviconIDForFaviconURL(
+    const GURL& icon_url,
+    favicon_base::IconType icon_type,
+    const url::Origin& page_origin) {
+  // Look to see if there even is any relevant cached entry.
+  auto const icon_id = GetFaviconIDForFaviconURL(icon_url, icon_type);
+  if (!icon_id) {
+    return icon_id;
+  }
+
+  // Check existing mappings to see if any are for the same origin.
+  sql::Statement statement(db_.GetCachedStatement(
+      SQL_FROM_HERE, "SELECT page_url FROM icon_mapping WHERE icon_id=?"));
+  statement.BindInt64(0, icon_id);
+  while (statement.Step()) {
+    const auto candidate_origin =
+        url::Origin::Create(GURL(statement.ColumnString(0)));
+    if (candidate_origin == page_origin) {
+      return icon_id;
+    }
+  }
+
+  // Act as if there is no entry in the cache if no mapping exists.
+  return 0;
+}
+
 favicon_base::FaviconID FaviconDatabase::GetFaviconIDForFaviconURL(
     const GURL& icon_url,
     favicon_base::IconType icon_type) {
diff --git a/components/favicon/core/favicon_database.h b/components/favicon/core/favicon_database.h
--- a/components/favicon/core/favicon_database.h
+++ b/components/favicon/core/favicon_database.h
@@ -22,6 +22,10 @@ class RefCountedMemory;
 class Time;
 }  // namespace base
 
+namespace url {
+class Origin;
+}  // namespace url
+
 namespace favicon {
 
 // The minimum number of days after which last_requested field gets updated.
@@ -146,9 +150,19 @@ class FaviconDatabase {
   // Returns true if successful.
   bool TouchOnDemandFavicon(const GURL& icon_url, base::Time time);
 
-  // Returns the id of the entry in the favicon database with the specified url
-  // and icon type.
-  // Returns 0 if no entry exists for the specified url.
+  // Returns the id of the entry in the favicon database with the specified
+  // `icon_url` and `icon_type` that has an existing mapping to `page_origin`
+  // (and 0 if no entry exists). See crbug.com/1300214 for more context.
+  favicon_base::FaviconID GetFaviconIDForFaviconURL(
+      const GURL& icon_url,
+      favicon_base::IconType icon_type,
+      const url::Origin& page_origin);
+
+  // Returns the id of the entry in the favicon database with the specified
+  // `icon_url` and `icon_type` (and 0 if no entry exists). This function does
+  // not respect cross-origin partitioning and returns an entry from the cache
+  // without verifying it was stored for the origin requesting it. This can leak
+  // navigation history, see crbug.com/1300214 for more context.
   favicon_base::FaviconID GetFaviconIDForFaviconURL(
       const GURL& icon_url,
       favicon_base::IconType icon_type);
--
2.25.1
