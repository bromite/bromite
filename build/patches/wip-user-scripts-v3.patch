From: root <root@ubuntu.cabponte>
Date: Sun, 6 Dec 2020 09:14:36 +0000
Subject: user scripts

---
 chrome/browser/BUILD.gn                       |    1 +
 chrome/browser/browser_process_impl.cc        |    3 +
 .../chrome_download_manager_delegate.cc       |    2 +
 ...hrome_browser_main_extra_parts_profiles.cc |    4 +
 chrome/browser/profiles/profile_manager.cc    |    9 +
 chrome/renderer/BUILD.gn                      |    1 +
 .../chrome_content_renderer_client.cc         |   11 +
 components/user_scripts/browser/BUILD.gn      |  801 +++++++++++
 .../browser/extension_file_task_runner.cc     |   40 +
 .../browser/extension_file_task_runner.h      |   32 +
 .../browser/extensions_browser_client.cc      |  175 +++
 .../browser/extensions_browser_client.h       |  389 ++++++
 .../browser/na/convert_user_script.cc         |  193 +++
 .../browser/na/convert_user_script.h          |   35 +
 .../user_scripts/browser/na/crx_installer.cc  | 1226 +++++++++++++++++
 .../user_scripts/browser/na/crx_installer.h   |  548 ++++++++
 .../browser/na/extension_system.cc            |   26 +
 .../browser/na/extension_system.h             |  169 +++
 .../na/extension_user_script_loader.cc        |  347 +++++
 .../browser/na/extension_user_script_loader.h |   88 ++
 .../browser/user_script_loader.cc             |  618 +++++++++
 .../user_scripts/browser/user_script_loader.h |  191 +++
 components/user_scripts/common/BUILD.gn       |  541 ++++++++
 components/user_scripts/common/constants.cc   |  196 +++
 components/user_scripts/common/constants.h    |  304 ++++
 components/user_scripts/common/error_utils.cc |   85 ++
 components/user_scripts/common/error_utils.h  |   45 +
 components/user_scripts/common/extension_id.h |   23 +
 .../common/extension_message_generator.cc     |   29 +
 .../common/extension_message_generator.h      |   16 +
 .../user_scripts/common/extension_messages.cc |  358 +++++
 .../user_scripts/common/extension_messages.h  | 1128 +++++++++++++++
 components/user_scripts/common/host_id.cc     |   31 +
 components/user_scripts/common/host_id.h      |   35 +
 .../user_scripts/common/script_constants.h    |   33 +
 components/user_scripts/common/url_pattern.cc |  807 +++++++++++
 components/user_scripts/common/url_pattern.h  |  301 ++++
 .../user_scripts/common/url_pattern_set.cc    |  327 +++++
 .../user_scripts/common/url_pattern_set.h     |  161 +++
 components/user_scripts/common/user_script.cc |  337 +++++
 components/user_scripts/common/user_script.h  |  364 +++++
 components/user_scripts/common/view_type.cc   |   39 +
 components/user_scripts/common/view_type.h    |   48 +
 components/user_scripts/renderer/BUILD.gn     |   98 ++
 .../renderer/extension_frame_helper.cc        |  531 +++++++
 .../renderer/extension_frame_helper.h         |  204 +++
 .../user_scripts/renderer/injection_host.cc   |   12 +
 .../user_scripts/renderer/injection_host.h    |   50 +
 .../renderer/resources/greasemonkey_api.js    |   82 ++
 .../user_scripts_renderer_resources.grd       |   14 +
 .../user_scripts/renderer/script_context.cc   |  665 +++++++++
 .../user_scripts/renderer/script_context.h    |  332 +++++
 .../user_scripts/renderer/script_injection.cc |  412 ++++++
 .../user_scripts/renderer/script_injection.h  |  160 +++
 .../renderer/script_injection_callback.cc     |   26 +
 .../renderer/script_injection_callback.h      |   38 +
 .../renderer/script_injection_manager.cc      |  550 ++++++++
 .../renderer/script_injection_manager.h       |  119 ++
 .../user_scripts/renderer/script_injector.h   |  103 ++
 .../user_scripts/renderer/scripts_run_info.cc |   78 ++
 .../user_scripts/renderer/scripts_run_info.h  |   70 +
 .../renderer/user_script_injector.cc          |  284 ++++
 .../renderer/user_script_injector.h           |   98 ++
 .../user_scripts/renderer/user_script_set.cc  |  293 ++++
 .../user_scripts/renderer/user_script_set.h   |  113 ++
 .../renderer/user_script_set_manager.cc       |  179 +++
 .../renderer/user_script_set_manager.h        |   76 +
 .../renderer/user_scripts_dispatcher.cc       |   61 +
 .../renderer/user_scripts_dispatcher.h        |   51 +
 .../renderer/user_scripts_renderer_client.cc  |   72 +
 .../renderer/user_scripts_renderer_client.h   |   33 +
 .../renderer/web_ui_injection_host.cc         |   35 +
 .../renderer/web_ui_injection_host.h          |   33 +
 tools/gritsettings/resource_ids.spec          |    3 +
 74 files changed, 14992 insertions(+)
 create mode 100755 components/user_scripts/browser/BUILD.gn
 create mode 100755 components/user_scripts/browser/extension_file_task_runner.cc
 create mode 100755 components/user_scripts/browser/extension_file_task_runner.h
 create mode 100755 components/user_scripts/browser/extensions_browser_client.cc
 create mode 100755 components/user_scripts/browser/extensions_browser_client.h
 create mode 100755 components/user_scripts/browser/na/convert_user_script.cc
 create mode 100755 components/user_scripts/browser/na/convert_user_script.h
 create mode 100755 components/user_scripts/browser/na/crx_installer.cc
 create mode 100755 components/user_scripts/browser/na/crx_installer.h
 create mode 100755 components/user_scripts/browser/na/extension_system.cc
 create mode 100755 components/user_scripts/browser/na/extension_system.h
 create mode 100755 components/user_scripts/browser/na/extension_user_script_loader.cc
 create mode 100755 components/user_scripts/browser/na/extension_user_script_loader.h
 create mode 100755 components/user_scripts/browser/user_script_loader.cc
 create mode 100755 components/user_scripts/browser/user_script_loader.h
 create mode 100755 components/user_scripts/common/BUILD.gn
 create mode 100755 components/user_scripts/common/constants.cc
 create mode 100755 components/user_scripts/common/constants.h
 create mode 100755 components/user_scripts/common/error_utils.cc
 create mode 100755 components/user_scripts/common/error_utils.h
 create mode 100755 components/user_scripts/common/extension_id.h
 create mode 100755 components/user_scripts/common/extension_message_generator.cc
 create mode 100755 components/user_scripts/common/extension_message_generator.h
 create mode 100755 components/user_scripts/common/extension_messages.cc
 create mode 100755 components/user_scripts/common/extension_messages.h
 create mode 100755 components/user_scripts/common/host_id.cc
 create mode 100755 components/user_scripts/common/host_id.h
 create mode 100755 components/user_scripts/common/script_constants.h
 create mode 100755 components/user_scripts/common/url_pattern.cc
 create mode 100755 components/user_scripts/common/url_pattern.h
 create mode 100755 components/user_scripts/common/url_pattern_set.cc
 create mode 100755 components/user_scripts/common/url_pattern_set.h
 create mode 100755 components/user_scripts/common/user_script.cc
 create mode 100755 components/user_scripts/common/user_script.h
 create mode 100755 components/user_scripts/common/view_type.cc
 create mode 100755 components/user_scripts/common/view_type.h
 create mode 100755 components/user_scripts/renderer/BUILD.gn
 create mode 100755 components/user_scripts/renderer/extension_frame_helper.cc
 create mode 100755 components/user_scripts/renderer/extension_frame_helper.h
 create mode 100755 components/user_scripts/renderer/injection_host.cc
 create mode 100755 components/user_scripts/renderer/injection_host.h
 create mode 100755 components/user_scripts/renderer/resources/greasemonkey_api.js
 create mode 100755 components/user_scripts/renderer/resources/user_scripts_renderer_resources.grd
 create mode 100755 components/user_scripts/renderer/script_context.cc
 create mode 100755 components/user_scripts/renderer/script_context.h
 create mode 100755 components/user_scripts/renderer/script_injection.cc
 create mode 100755 components/user_scripts/renderer/script_injection.h
 create mode 100755 components/user_scripts/renderer/script_injection_callback.cc
 create mode 100755 components/user_scripts/renderer/script_injection_callback.h
 create mode 100755 components/user_scripts/renderer/script_injection_manager.cc
 create mode 100755 components/user_scripts/renderer/script_injection_manager.h
 create mode 100755 components/user_scripts/renderer/script_injector.h
 create mode 100755 components/user_scripts/renderer/scripts_run_info.cc
 create mode 100755 components/user_scripts/renderer/scripts_run_info.h
 create mode 100755 components/user_scripts/renderer/user_script_injector.cc
 create mode 100755 components/user_scripts/renderer/user_script_injector.h
 create mode 100755 components/user_scripts/renderer/user_script_set.cc
 create mode 100755 components/user_scripts/renderer/user_script_set.h
 create mode 100755 components/user_scripts/renderer/user_script_set_manager.cc
 create mode 100755 components/user_scripts/renderer/user_script_set_manager.h
 create mode 100755 components/user_scripts/renderer/user_scripts_dispatcher.cc
 create mode 100755 components/user_scripts/renderer/user_scripts_dispatcher.h
 create mode 100755 components/user_scripts/renderer/user_scripts_renderer_client.cc
 create mode 100755 components/user_scripts/renderer/user_scripts_renderer_client.h
 create mode 100755 components/user_scripts/renderer/web_ui_injection_host.cc
 create mode 100755 components/user_scripts/renderer/web_ui_injection_host.h

diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -3238,6 +3238,7 @@ static_library("browser") {
       ]
       deps += [ "//chrome/android/modules/dev_ui/provider:native" ]
     }
+    deps += [ "//components/user_scripts/browser" ]
   } else {  #!is_android
     sources += [
       "accessibility/caption_controller.cc",
diff --git a/chrome/browser/browser_process_impl.cc b/chrome/browser/browser_process_impl.cc
--- a/chrome/browser/browser_process_impl.cc
+++ b/chrome/browser/browser_process_impl.cc
@@ -138,6 +138,7 @@
 #include "ui/base/idle/idle.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/base/ui_base_features.h"
+#include "components/user_scripts/browser/extensions_browser_client.h"
 
 #if defined(OS_WIN)
 #include "base/win/windows_version.h"
@@ -284,6 +285,8 @@ void BrowserProcessImpl::Init() {
   extensions::ExtensionsBrowserClient::Set(extensions_browser_client_.get());
 #endif
 
+  // user_scripts::UserScriptsBrowserClient::GetInstance();
+
 #if !defined(OS_CHROMEOS)
   message_center::MessageCenter::Initialize();
   // Set the system notification source display name ("Google Chrome" or
diff --git a/chrome/browser/download/chrome_download_manager_delegate.cc b/chrome/browser/download/chrome_download_manager_delegate.cc
--- a/chrome/browser/download/chrome_download_manager_delegate.cc
+++ b/chrome/browser/download/chrome_download_manager_delegate.cc
@@ -674,6 +674,8 @@ bool ChromeDownloadManagerDelegate::ShouldOpenDownload(
   }
 #endif
 
+//
+
   return true;
 }
 
diff --git a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
--- a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
+++ b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
@@ -179,6 +179,8 @@
 #include "chrome/browser/nearby_sharing/nearby_sharing_service_factory.h"
 #endif
 
+#include "components/user_scripts/browser/extensions_browser_client.h"
+
 namespace chrome {
 
 void AddProfilesExtraParts(ChromeBrowserMainParts* main_parts) {
@@ -403,6 +405,8 @@ void ChromeBrowserMainExtraPartsProfiles::
 #endif
   WebDataServiceFactory::GetInstance();
   webrtc_event_logging::WebRtcEventLogManagerKeyedServiceFactory::GetInstance();
+
+  user_scripts::UserScriptsBrowserClient::GetInstance();
 }
 
 void ChromeBrowserMainExtraPartsProfiles::PreProfileInit() {
diff --git a/chrome/browser/profiles/profile_manager.cc b/chrome/browser/profiles/profile_manager.cc
--- a/chrome/browser/profiles/profile_manager.cc
+++ b/chrome/browser/profiles/profile_manager.cc
@@ -109,6 +109,8 @@
 #include "extensions/common/manifest.h"
 #endif
 
+#include "components/user_scripts/browser/extensions_browser_client.h"
+
 #if BUILDFLAG(ENABLE_SESSION_SERVICE)
 #include "chrome/browser/sessions/session_service_factory.h"
 #endif
@@ -1287,6 +1289,13 @@ void ProfileManager::DoFinalInitForServices(Profile* profile,
   }
 
 #endif
+
+  user_scripts::UserScriptsBrowserClient* userscript_client =
+    user_scripts::UserScriptsBrowserClient::GetInstance();
+  if(userscript_client) {
+    userscript_client->SetProfile(profile);
+  }
+
 #if BUILDFLAG(ENABLE_SUPERVISED_USERS)
   // Initialization needs to happen after extension system initialization (for
   // extension::ManagementPolicy) and InitProfileUserPrefs (for setting the
diff --git a/chrome/renderer/BUILD.gn b/chrome/renderer/BUILD.gn
--- a/chrome/renderer/BUILD.gn
+++ b/chrome/renderer/BUILD.gn
@@ -154,6 +154,7 @@ static_library("renderer") {
     "//components/contextual_search/content:renderer",
     "//components/data_reduction_proxy/core/common",
     "//components/dom_distiller/content/renderer",
+    "//components/user_scripts/renderer",
     "//components/network_hints/renderer",
     "//components/omnibox/common",
     "//components/page_image_annotation/content/renderer",
diff --git a/chrome/renderer/chrome_content_renderer_client.cc b/chrome/renderer/chrome_content_renderer_client.cc
--- a/chrome/renderer/chrome_content_renderer_client.cc
+++ b/chrome/renderer/chrome_content_renderer_client.cc
@@ -166,6 +166,7 @@
 
 #if defined(OS_ANDROID)
 #include "chrome/renderer/sandbox_status_extension_android.h"
+#include "components/user_scripts/renderer/user_scripts_renderer_client.h"
 #else
 #include "chrome/renderer/media/chrome_speech_recognition_client.h"
 #include "chrome/renderer/searchbox/search_bouncer.h"
@@ -363,6 +364,8 @@ void ChromeContentRendererClient::RenderThreadStarted() {
   ChromeExtensionsRendererClient::GetInstance()->RenderThreadStarted();
 #endif
 
+  user_scripts::UserScriptsRendererClient::GetInstance()->RenderThreadStarted();
+
 #if BUILDFLAG(ENABLE_SPELLCHECK)
   if (!spellcheck_)
     InitSpellCheck();
@@ -501,6 +504,8 @@ void ChromeContentRendererClient::RenderFrameCreated(
   ChromeExtensionsRendererClient::GetInstance()->RenderFrameCreated(
       render_frame, registry);
 #endif
+  user_scripts::UserScriptsRendererClient::GetInstance()->RenderFrameCreated(
+      render_frame, registry);
 
 #if BUILDFLAG(ENABLE_PLUGINS)
   new PepperHelper(render_frame);
@@ -1442,6 +1447,8 @@ void ChromeContentRendererClient::RunScriptsAtDocumentStart(
       render_frame);
   // |render_frame| might be dead by now.
 #endif
+  user_scripts::UserScriptsRendererClient::GetInstance()->RunScriptsAtDocumentStart(
+      render_frame);
 }
 
 void ChromeContentRendererClient::RunScriptsAtDocumentEnd(
@@ -1451,6 +1458,8 @@ void ChromeContentRendererClient::RunScriptsAtDocumentEnd(
       render_frame);
   // |render_frame| might be dead by now.
 #endif
+  user_scripts::UserScriptsRendererClient::GetInstance()->RunScriptsAtDocumentEnd(
+      render_frame);
 }
 
 void ChromeContentRendererClient::RunScriptsAtDocumentIdle(
@@ -1460,6 +1469,8 @@ void ChromeContentRendererClient::RunScriptsAtDocumentIdle(
       render_frame);
   // |render_frame| might be dead by now.
 #endif
+  user_scripts::UserScriptsRendererClient::GetInstance()->RunScriptsAtDocumentIdle(
+      render_frame);
 }
 
 void ChromeContentRendererClient::
diff --git a/components/user_scripts/browser/BUILD.gn b/components/user_scripts/browser/BUILD.gn
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/browser/BUILD.gn
@@ -0,0 +1,801 @@
+# Copyright 2014 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/features.gni")
+# import("//extensions/buildflags/buildflags.gni")
+
+# This file depends on the legacy global sources assignment filter. It should
+# be converted to check target platform before assigning source files to the
+# sources variable. Remove this import and set_sources_assignment_filter call
+# when the file has been converted. See https://crbug.com/1018739 for details.
+# import("//build/config/deprecated_default_sources_assignment_filter.gni")
+# set_sources_assignment_filter(deprecated_default_sources_assignment_filter)
+
+# assert(enable_extensions)
+
+group("browser") {
+  public_deps = [
+    # "//extensions/browser:browser_context_keyed_service_factories",
+    "//components/user_scripts/browser:browser_sources",
+    # "//extensions/browser/api:api_registration",
+  ]
+
+  # Includes all API implementations and the ExtensionsApiClient
+  # interface. Moving an API from src/chrome to src/extensions implies
+  # it can be cleanly disabled with enable_extensions=false.
+  # public_deps += [ "//extensions/browser/api" ]
+}
+
+# Isolate the instantiation of BrowserContextKeyedServiceFactories.
+# source_set("browser_context_keyed_service_factories") {
+#   visibility = [ ":*" ]
+
+#   sources = [
+#     "browser_context_keyed_service_factories.cc",
+#     "browser_context_keyed_service_factories.h",
+#   ]
+
+#   configs += [ "//build/config/compiler:wexit_time_destructors" ]
+
+#   deps = [
+#     "//extensions/browser:browser_sources",
+#     "//extensions/browser/api",
+#   ]
+# }
+
+source_set("browser_sources") {
+  visibility = [ "./*" ]
+
+  sources = [
+    "extension_file_task_runner.cc",
+    "extension_file_task_runner.h",
+    "extensions_browser_client.cc",
+    "extensions_browser_client.h",
+    "user_script_loader.cc",
+    "user_script_loader.h",
+    # "activity.cc",
+    # "activity.h",
+    # "api_activity_monitor.cc",
+    # "api_activity_monitor.h",
+    # "app_sorting.h",
+    # "app_window/app_delegate.h",
+    # "app_window/app_web_contents_helper.cc",
+    # "app_window/app_web_contents_helper.h",
+    # "app_window/app_window.cc",
+    # "app_window/app_window.h",
+    # "app_window/app_window_client.cc",
+    # "app_window/app_window_client.h",
+    # "app_window/app_window_contents.cc",
+    # "app_window/app_window_contents.h",
+    # "app_window/app_window_geometry_cache.cc",
+    # "app_window/app_window_geometry_cache.h",
+    # "app_window/app_window_registry.cc",
+    # "app_window/app_window_registry.h",
+    # "app_window/native_app_window.h",
+    # "app_window/size_constraints.cc",
+    # "app_window/size_constraints.h",
+    # "bad_message.cc",
+    # "bad_message.h",
+    # "blob_holder.cc",
+    # "blob_holder.h",
+    # "blob_reader.cc",
+    # "blob_reader.h",
+    # "blocked_action_type.h",
+    # "blocklist_state.h",
+    # "browser_context_keyed_api_factory.h",
+    # "component_extension_resource_manager.h",
+    # "computed_hashes.cc",
+    # "computed_hashes.h",
+    # "content_hash_fetcher.cc",
+    # "content_hash_fetcher.h",
+    # "content_hash_reader.cc",
+    # "content_hash_reader.h",
+    # "content_hash_tree.cc",
+    # "content_hash_tree.h",
+    # "content_verifier.cc",
+    # "content_verifier.h",
+    # "content_verifier/content_hash.cc",
+    # "content_verifier/content_hash.h",
+    # "content_verifier/content_verifier_key.h",
+    # "content_verifier/content_verifier_utils.cc",
+    # "content_verifier/content_verifier_utils.h",
+    # "content_verifier/scoped_uma_recorder.h",
+    # "content_verifier_delegate.h",
+    # "content_verifier_io_data.cc",
+    # "content_verifier_io_data.h",
+    # "content_verify_job.cc",
+    # "content_verify_job.h",
+    # "crx_file_info.cc",
+    # "crx_file_info.h",
+    # "declarative_user_script_manager.cc",
+    # "declarative_user_script_manager.h",
+    # "declarative_user_script_manager_factory.cc",
+    # "declarative_user_script_manager_factory.h",
+    # "declarative_user_script_set.cc",
+    # "declarative_user_script_set.h",
+    # "deferred_start_render_host.h",
+    # "device_local_account_util.cc",
+    # "device_local_account_util.h",
+    # "disable_reason.h",
+    # "error_map.cc",
+    # "error_map.h",
+    # "event_listener_map.cc",
+    # "event_listener_map.h",
+    # "event_page_tracker.h",
+    # "event_router.cc",
+    # "event_router.h",
+    # "event_router_factory.cc",
+    # "event_router_factory.h",
+    # "events/event_ack_data.cc",
+    # "events/event_ack_data.h",
+    # "events/lazy_event_dispatch_util.cc",
+    # "events/lazy_event_dispatch_util.h",
+    # "events/lazy_event_dispatcher.cc",
+    # "events/lazy_event_dispatcher.h",
+    # "extension_action.cc",
+    # "extension_action.h",
+    # "extension_action_manager.cc",
+    # "extension_action_manager.h",
+    # "extension_api_frame_id_map.cc",
+    # "extension_api_frame_id_map.h",
+    # "extension_creator.cc",
+    # "extension_creator.h",
+    # "extension_creator_filter.cc",
+    # "extension_creator_filter.h",
+    # "extension_dialog_auto_confirm.cc",
+    # "extension_dialog_auto_confirm.h",
+    # "extension_error.cc",
+    # "extension_error.h",
+    # "extension_file_task_runner.cc",
+    # "extension_file_task_runner.h",
+    # "extension_function.cc",
+    # "extension_function.h",
+    # "extension_function_constants.cc",
+    # "extension_function_constants.h",
+    # "extension_function_dispatcher.cc",
+    # "extension_function_dispatcher.h",
+    # "extension_function_registry.cc",
+    # "extension_function_registry.h",
+    # "extension_host.cc",
+    # "extension_host.h",
+    # "extension_host_delegate.h",
+    # "extension_host_observer.h",
+    # "extension_host_queue.cc",
+    # "extension_host_queue.h",
+    # "extension_icon_image.cc",
+    # "extension_icon_image.h",
+    # "extension_icon_placeholder.cc",
+    # "extension_icon_placeholder.h",
+    # "extension_message_filter.cc",
+    # "extension_message_filter.h",
+    # "extension_navigation_throttle.cc",
+    # "extension_navigation_throttle.h",
+    # "extension_navigation_ui_data.cc",
+    # "extension_navigation_ui_data.h",
+    # "extension_pref_store.cc",
+    # "extension_pref_store.h",
+    # "extension_pref_value_map.cc",
+    # "extension_pref_value_map.h",
+    # "extension_pref_value_map_factory.cc",
+    # "extension_pref_value_map_factory.h",
+    # "extension_prefs.cc",
+    # "extension_prefs.h",
+    # "extension_prefs_factory.cc",
+    # "extension_prefs_factory.h",
+    # "extension_prefs_observer.h",
+    # "extension_prefs_scope.h",
+    # "extension_protocols.cc",
+    # "extension_protocols.h",
+    # "extension_registrar.cc",
+    # "extension_registrar.h",
+    # "extension_registry.cc",
+    # "extension_registry.h",
+    # "extension_registry_factory.cc",
+    # "extension_registry_factory.h",
+    # "extension_registry_observer.h",
+    # "extension_service_worker_message_filter.cc",
+    # "extension_service_worker_message_filter.h",
+    # "extension_system.cc",
+    # "extension_system.h",
+    # "extension_system_provider.cc",
+    # "extension_system_provider.h",
+    # "extension_user_script_loader.cc",
+    # "extension_user_script_loader.h",
+    # "extension_util.cc",
+    # "extension_util.h",
+    # "extension_web_contents_observer.cc",
+    # "extension_web_contents_observer.h",
+    # "extension_zoom_request_client.cc",
+    # "extension_zoom_request_client.h",
+    # "extensions_browser_api_provider.h",
+    # "extensions_browser_interface_binders.cc",
+    # "extensions_browser_interface_binders.h",
+    # "external_install_info.cc",
+    # "external_install_info.h",
+    # "external_provider_interface.h",
+    # "file_highlighter.cc",
+    # "file_highlighter.h",
+    # "file_reader.cc",
+    # "file_reader.h",
+    # "granted_file_entry.cc",
+    # "granted_file_entry.h",
+    # "guest_view/app_view/app_view_constants.cc",
+    # "guest_view/app_view/app_view_constants.h",
+    # "guest_view/app_view/app_view_guest.cc",
+    # "guest_view/app_view/app_view_guest.h",
+    # "guest_view/app_view/app_view_guest_delegate.cc",
+    # "guest_view/app_view/app_view_guest_delegate.h",
+    # "guest_view/extension_options/extension_options_constants.cc",
+    # "guest_view/extension_options/extension_options_constants.h",
+    # "guest_view/extension_options/extension_options_guest.cc",
+    # "guest_view/extension_options/extension_options_guest.h",
+    # "guest_view/extension_options/extension_options_guest_delegate.cc",
+    # "guest_view/extension_options/extension_options_guest_delegate.h",
+    # "guest_view/extensions_guest_view_manager_delegate.cc",
+    # "guest_view/extensions_guest_view_manager_delegate.h",
+    # "guest_view/extensions_guest_view_message_filter.cc",
+    # "guest_view/extensions_guest_view_message_filter.h",
+    # "guest_view/guest_view_events.cc",
+    # "guest_view/guest_view_events.h",
+    # "guest_view/mime_handler_view/mime_handler_stream_manager.cc",
+    # "guest_view/mime_handler_view/mime_handler_stream_manager.h",
+    # "guest_view/mime_handler_view/mime_handler_view_attach_helper.cc",
+    # "guest_view/mime_handler_view/mime_handler_view_attach_helper.h",
+    # "guest_view/mime_handler_view/mime_handler_view_constants.cc",
+    # "guest_view/mime_handler_view/mime_handler_view_constants.h",
+    # "guest_view/mime_handler_view/mime_handler_view_embedder.cc",
+    # "guest_view/mime_handler_view/mime_handler_view_embedder.h",
+    # "guest_view/mime_handler_view/mime_handler_view_guest.cc",
+    # "guest_view/mime_handler_view/mime_handler_view_guest.h",
+    # "guest_view/mime_handler_view/mime_handler_view_guest_delegate.cc",
+    # "guest_view/mime_handler_view/mime_handler_view_guest_delegate.h",
+
+    # # TODO(crbug.com/730220): Ideally web_view should be a separate target on
+    # # which the extension system depends.
+    # "guest_view/web_view/javascript_dialog_helper.cc",
+    # "guest_view/web_view/javascript_dialog_helper.h",
+    # "guest_view/web_view/web_view_constants.cc",
+    # "guest_view/web_view/web_view_constants.h",
+    # "guest_view/web_view/web_view_content_script_manager.cc",
+    # "guest_view/web_view/web_view_content_script_manager.h",
+    # "guest_view/web_view/web_view_find_helper.cc",
+    # "guest_view/web_view/web_view_find_helper.h",
+    # "guest_view/web_view/web_view_guest.cc",
+    # "guest_view/web_view/web_view_guest.h",
+    # "guest_view/web_view/web_view_guest_delegate.h",
+    # "guest_view/web_view/web_view_permission_helper.cc",
+    # "guest_view/web_view/web_view_permission_helper.h",
+    # "guest_view/web_view/web_view_permission_helper_delegate.cc",
+    # "guest_view/web_view/web_view_permission_helper_delegate.h",
+    # "guest_view/web_view/web_view_permission_types.h",
+    # "guest_view/web_view/web_view_renderer_state.cc",
+    # "guest_view/web_view/web_view_renderer_state.h",
+    # "image_loader.cc",
+    # "image_loader.h",
+    # "image_loader_factory.cc",
+    # "image_loader_factory.h",
+    # "image_sanitizer.cc",
+    # "image_sanitizer.h",
+    # "info_map.cc",
+    # "info_map.h",
+    # "install_flag.h",
+    # "install_stage.h",
+    # "json_file_sanitizer.cc",
+    # "json_file_sanitizer.h",
+    # "lazy_background_task_queue.cc",
+    # "lazy_background_task_queue.h",
+    # "lazy_background_task_queue_factory.cc",
+    # "lazy_background_task_queue_factory.h",
+    # "lazy_context_id.cc",
+    # "lazy_context_id.h",
+    # "lazy_context_task_queue.cc",
+    # "lazy_context_task_queue.h",
+    # "management_policy.cc",
+    # "management_policy.h",
+    # "media_capture_util.cc",
+    # "media_capture_util.h",
+    # "media_router_extension_access_logger.cc",
+    # "media_router_extension_access_logger.h",
+    # "mojo/keep_alive_impl.cc",
+    # "mojo/keep_alive_impl.h",
+    # "notification_types.h",
+    # "null_app_sorting.cc",
+    # "null_app_sorting.h",
+    # "path_util.cc",
+    # "path_util.h",
+    # "policy_check.cc",
+    # "policy_check.h",
+    # "pref_names.cc",
+    # "pref_names.h",
+    # "pref_types.cc",
+    # "pref_types.h",
+    # "preload_check.cc",
+    # "preload_check.h",
+    # "preload_check_group.cc",
+    # "preload_check_group.h",
+    # "process_manager.cc",
+    # "process_manager.h",
+    # "process_manager_delegate.h",
+    # "process_manager_factory.cc",
+    # "process_manager_factory.h",
+    # "process_manager_observer.h",
+    # "process_map.cc",
+    # "process_map.h",
+    # "process_map_factory.cc",
+    # "process_map_factory.h",
+    # "quota_service.cc",
+    # "quota_service.h",
+    # "renderer_startup_helper.cc",
+    # "renderer_startup_helper.h",
+    # "requirements_checker.cc",
+    # "requirements_checker.h",
+    # "runtime_data.cc",
+    # "runtime_data.h",
+    # "sandboxed_unpacker.cc",
+    # "sandboxed_unpacker.h",
+    # "script_executor.cc",
+    # "script_executor.h",
+    # "service_worker/worker_id.cc",
+    # "service_worker/worker_id.h",
+    # "service_worker/worker_id_set.cc",
+    # "service_worker/worker_id_set.h",
+    # "service_worker_manager.cc",
+    # "service_worker_manager.h",
+    # "service_worker_task_queue.cc",
+    # "service_worker_task_queue.h",
+    # "service_worker_task_queue_factory.cc",
+    # "service_worker_task_queue_factory.h",
+    # "shared_user_script_manager.cc",
+    # "shared_user_script_manager.h",
+    # "state_store.cc",
+    # "state_store.h",
+    # "suggest_permission_util.cc",
+    # "suggest_permission_util.h",
+    # "supervised_user_extensions_delegate.h",
+    # "task_queue_util.cc",
+    # "task_queue_util.h",
+    # "ui_util.cc",
+    # "ui_util.h",
+    # "uninstall_ping_sender.cc",
+    # "uninstall_ping_sender.h",
+    # "uninstall_reason.h",
+    # "unloaded_extension_reason.h",
+    # "update_observer.h",
+    # "url_loader_factory_manager.cc",
+    # "url_loader_factory_manager.h",
+    # "url_request_util.cc",
+    # "url_request_util.h",
+    # "user_script_loader.cc",
+    # "user_script_loader.h",
+    # "verified_contents.cc",
+    # "verified_contents.h",
+    # "view_type_utils.cc",
+    # "view_type_utils.h",
+    # "warning_service.cc",
+    # "warning_service.h",
+    # "warning_service_factory.cc",
+    # "warning_service_factory.h",
+    # "warning_set.cc",
+    # "warning_set.h",
+    # "web_ui_user_script_loader.cc",
+    # "web_ui_user_script_loader.h",
+    # "zipfile_installer.cc",
+    # "zipfile_installer.h",
+  ]
+
+  deps = [
+    "//base:i18n",
+    # "//components/cast_certificate",
+    # "//components/cast_channel",
+    # "//components/crx_file",
+    # "//components/crx_file:crx_creator",
+    # "//components/guest_view/browser",
+    "//components/keyed_service/content",
+    "//components/keyed_service/core",
+    "//components/pref_registry",
+    "//components/prefs",
+    # "//components/services/unzip/content",
+    # "//components/services/unzip/public/cpp",
+    # "//components/sessions",
+    # "//components/sync",
+    # "//components/update_client",
+    # "//components/variations",
+    # "//components/version_info",
+    # "//components/web_cache/browser",
+    # "//components/web_modal",
+    # "//components/zoom",
+    "//content/public/browser",
+    "//crypto:platform",
+    # "//crypto:platform",
+    # # "//extensions:extensions_browser_resources",
+    # "//extensions/browser/api/declarative_net_request:core",
+    # "//extensions/browser/guest_view/web_view/web_ui",
+    # "//extensions/buildflags",
+    "//components/user_scripts/common",
+    # "//extensions/common/api",
+    # "//extensions/strings",
+    # "//google_apis",
+    # "//ppapi/buildflags",
+    "//services/device/public/mojom",
+    "//services/preferences/public/cpp",
+    "//services/service_manager/public/cpp",
+    "//third_party/blink/public/common",
+    "//third_party/blink/public/mojom/frame",
+    "//ui/display",
+  ]
+
+  public_deps = [
+    "//content/public/common",
+    # "//extensions/browser/install",
+    # "//extensions/browser/kiosk",
+    # "//extensions/browser/updater",
+    # "//extensions/browser/value_store",
+    # "//ipc",
+  ]
+
+  # if (is_mac) {
+  #   # For LSCopyDisplayNameForURL, path_util.cc.
+  #   frameworks = [ "CoreServices.framework" ]
+  # }
+
+  configs += [
+    "//build/config:precompiled_headers",
+
+    # TODO(jschuh): crbug.com/167187 fix size_t to int truncations.
+    "//build/config/compiler:no_size_t_to_int_warning",
+    "//build/config/compiler:wexit_time_destructors",
+  ]
+}
+
+# NOTE: This is separate from ":browser" because it depends on
+# //extensions/browser/api:api_registration, which in turn depends on
+# :browser.
+# source_set("core_api_provider") {
+#   sources = [
+#     "core_extensions_browser_api_provider.cc",
+#     "core_extensions_browser_api_provider.h",
+#   ]
+
+#   deps = [
+#     ":browser",
+#     "//extensions/browser/api:api_registration",
+#   ]
+# }
+
+# source_set("browser_tests") {
+#   testonly = true
+#   sources = [
+#     # TODO(michaelpg): bluetooth_appshell_test.cc is a crutch until we have a
+#     # better system for testing APIs in both app_shell and chrome. See
+#     # crbug.com/650835.
+#     "api/bluetooth/bluetooth_appshell_test.cc",
+#     "api/bluetooth_socket/bluetooth_socket_apitest.cc",
+#     "api/display_source/display_source_apitest.cc",
+#     "api/display_source/display_source_apitestbase.cc",
+#     "api/display_source/display_source_apitestbase.h",
+#     "api/dns/dns_apitest.cc",
+#     "api/feedback_private/feedback_private_apitest.cc",
+#     "api/hid/hid_apitest.cc",
+#     "api/printer_provider/printer_provider_apitest.cc",
+#     "api/socket/socket_apitest.cc",
+#     "api/sockets_tcp/sockets_tcp_apitest.cc",
+#     "api/sockets_tcp_server/sockets_tcp_server_apitest.cc",
+#     "api/sockets_udp/sockets_udp_apitest.cc",
+#     "api/system_cpu/system_cpu_apitest.cc",
+#     "api/system_display/system_display_apitest.cc",
+#     "api/system_memory/system_memory_apitest.cc",
+#     "api/system_network/system_network_apitest.cc",
+#     "api/system_storage/storage_api_test_util.cc",
+#     "api/system_storage/storage_api_test_util.h",
+#     "api/system_storage/system_storage_apitest.cc",
+#     "api/system_storage/system_storage_eject_apitest.cc",
+#     "api/usb/usb_apitest.cc",
+#     "browsertest_util_browsertest.cc",
+#     "guest_view/app_view/app_view_apitest.cc",
+#     "guest_view/web_view/web_view_apitest.cc",
+#     "guest_view/web_view/web_view_apitest.h",
+#     "guest_view/web_view/web_view_media_access_apitest.cc",
+#     "url_loader_factory_manager_browsertest.cc",
+#   ]
+
+#   defines = [ "HAS_OUT_OF_PROC_TEST_RUNNER" ]
+
+#   deps = [
+#     ":browser",
+#     "//base",
+#     "//components/guest_view/browser:test_support",
+#     "//components/storage_monitor:test_support",
+#     "//content/test:test_support",
+#     "//device/bluetooth:mocks",
+#     "//extensions:test_support",
+#     "//extensions/browser:test_support",
+#     "//extensions/common",
+#     "//extensions/common/api",
+#     "//extensions/shell:app_shell_lib",
+#     "//extensions/shell:browser_tests",
+#     "//net:test_support",
+#     "//services/device/public/cpp:test_support",
+#     "//services/device/public/cpp/hid",
+#     "//services/device/public/cpp/hid:test_support",
+#     "//services/device/public/mojom",
+#     "//services/network:test_support",
+#     "//services/service_manager/public/cpp",
+#     "//ui/display:test_support",
+#   ]
+
+#   if (is_chromeos) {
+#     sources += [
+#       "api/audio/audio_apitest_chromeos.cc",
+#       "api/cec_private/cec_private_apitest.cc",
+#       "api/crash_report_private/crash_report_private_apitest.cc",
+#       "api/media_perception_private/media_perception_private_apitest.cc",
+#       "api/system_power_source/system_power_source_apitest.cc",
+#       "api/virtual_keyboard/virtual_keyboard_apitest.cc",
+#     ]
+
+#     deps += [
+#       "//chromeos/audio",
+#       "//chromeos/dbus:test_support",
+#       "//chromeos/dbus/audio",
+#       "//chromeos/dbus/media_analytics",
+#       "//chromeos/dbus/media_analytics:media_perception_proto",
+#       "//chromeos/dbus/permission_broker",
+#       "//chromeos/dbus/power",
+#       "//chromeos/dbus/power:power_manager_proto",
+#       "//chromeos/dbus/upstart",
+#       "//chromeos/login/login_state",
+#       "//chromeos/network",
+#       "//components/crash/content/browser/error_reporting:mock_crash_endpoint",
+#     ]
+#   }
+# }
+
+# source_set("test_support") {
+#   testonly = true
+#   sources = [
+#     "browsertest_util.cc",
+#     "browsertest_util.h",
+#     "preload_check_test_util.cc",
+#     "preload_check_test_util.h",
+#     "service_worker/service_worker_test_utils.cc",
+#     "service_worker/service_worker_test_utils.h",
+#     "test_event_router_observer.cc",
+#     "test_event_router_observer.h",
+#     "updater/extension_cache_fake.cc",
+#     "updater/extension_cache_fake.h",
+#     "updater/extension_downloader_test_helper.cc",
+#     "updater/extension_downloader_test_helper.h",
+#     "value_store/test_value_store_factory.cc",
+#     "value_store/test_value_store_factory.h",
+#     "value_store/testing_value_store.cc",
+#     "value_store/testing_value_store.h",
+#   ]
+
+#   deps = [
+#     "//base",
+#     "//base/test:test_support",
+#     "//content/public/browser",
+#     "//content/test:test_support",
+#     "//extensions/browser",
+#     "//extensions/common",
+#     "//extensions/common:test_support",
+#     "//services/data_decoder:lib",
+#     "//services/data_decoder/public/cpp:test_support",
+#     "//services/network:test_support",
+#     "//testing/gmock",
+#     "//testing/gtest",
+#   ]
+
+#   public_deps =
+#       [ "//extensions/browser/api/declarative_net_request:test_support" ]
+
+#   if (is_chromeos) {
+#     sources += [
+#       "api/feedback_private/mock_feedback_service.cc",
+#       "api/feedback_private/mock_feedback_service.h",
+#     ]
+#     deps += [
+#       "//components/crash/core/app:app",
+#       "//net:test_support",
+#     ]
+#   }
+# }
+
+# source_set("value_store_test_support") {
+#   testonly = true
+#   sources = [
+#     "value_store/value_store_unittest.cc",
+#     "value_store/value_store_unittest.h",
+#   ]
+
+#   deps = [
+#     "//base",
+#     "//base/test:test_support",
+#     "//content/test:test_support",
+#     "//extensions/browser",
+#     "//testing/gtest",
+#   ]
+# }
+
+# source_set("unit_tests") {
+#   testonly = true
+#   sources = [
+#     "api/alarms/alarms_api_unittest.cc",
+#     "api/api_resource_manager_unittest.cc",
+#     "api/bluetooth/bluetooth_event_router_unittest.cc",
+#     "api/bluetooth_socket/bluetooth_socket_api_unittest.cc",
+#     "api/cast_channel/cast_channel_api_unittest.cc",
+#     "api/cast_channel/cast_channel_enum_util_unittest.cc",
+#     "api/declarative/declarative_rule_unittest.cc",
+#     "api/declarative/deduping_factory_unittest.cc",
+#     "api/declarative/rules_registry_unittest.cc",
+#     "api/declarative_net_request/composite_matcher_unittest.cc",
+#     "api/declarative_net_request/file_sequence_helper_unittest.cc",
+#     "api/declarative_net_request/flat_ruleset_indexer_unittest.cc",
+#     "api/declarative_net_request/indexed_rule_unittest.cc",
+#     "api/declarative_net_request/indexed_ruleset_format_version_unittest.cc",
+#     "api/declarative_net_request/ruleset_matcher_unittest.cc",
+#     "api/declarative_webrequest/webrequest_condition_attribute_unittest.cc",
+#     "api/declarative_webrequest/webrequest_condition_unittest.cc",
+#     "api/file_handlers/app_file_handler_util_unittest.cc",
+#     "api/file_handlers/directory_util_unittest.cc",
+#     "api/file_handlers/mime_util_unittest.cc",
+#     "api/idle/idle_api_unittest.cc",
+#     "api/networking_config/networking_config_service_chromeos_unittest.cc",
+#     "api/networking_private/networking_private_chromeos_unittest.cc",
+#     "api/power/power_api_unittest.cc",
+#     "api/runtime/restart_after_delay_api_unittest.cc",
+#     "api/socket/mojo_data_pump_unittest.cc",
+#     "api/sockets_tcp/sockets_tcp_api_unittest.cc",
+#     "api/sockets_udp/sockets_udp_api_unittest.cc",
+#     "api/storage/settings_quota_unittest.cc",
+#     "api/storage/storage_api_unittest.cc",
+#     "api/storage/storage_frontend_unittest.cc",
+#     "api/system_info/system_info_api_unittest.cc",
+#     "api/system_network/system_network_api_unittest.cc",
+#     "api/web_request/form_data_parser_unittest.cc",
+#     "api/web_request/upload_data_presenter_unittest.cc",
+#     "api/web_request/web_request_info_unittest.cc",
+#     "api/web_request/web_request_permissions_unittest.cc",
+#     "api/web_request/web_request_time_tracker_unittest.cc",
+#     "app_window/app_window_geometry_cache_unittest.cc",
+#     "computed_hashes_unittest.cc",
+#     "content_hash_fetcher_unittest.cc",
+#     "content_hash_tree_unittest.cc",
+#     "content_verifier/content_hash_unittest.cc",
+#     "content_verifier_unittest.cc",
+#     "content_verify_job_unittest.cc",
+#     "error_map_unittest.cc",
+#     "event_listener_map_unittest.cc",
+#     "event_router_unittest.cc",
+#     "extension_action_manager_unittest.cc",
+#     "extension_action_unittest.cc",
+#     "extension_creator_filter_unittest.cc",
+#     "extension_creator_unittest.cc",
+#     "extension_event_histogram_value_unittest.cc",
+#     "extension_function_histogram_value_unittest.cc",
+#     "extension_icon_image_unittest.cc",
+#     "extension_pref_value_map_unittest.cc",
+#     "extension_registrar_unittest.cc",
+#     "extension_registry_unittest.cc",
+#     "extension_util_unittest.cc",
+#     "file_highlighter_unittest.cc",
+#     "file_reader_unittest.cc",
+#     "image_loader_unittest.cc",
+#     "image_sanitizer_unittest.cc",
+#     "info_map_unittest.cc",
+#     "json_file_sanitizer_unittest.cc",
+#     "lazy_background_task_queue_unittest.cc",
+#     "management_policy_unittest.cc",
+#     "mojo/keep_alive_impl_unittest.cc",
+#     "path_util_unittest.cc",
+#     "policy_check_unittest.cc",
+#     "preload_check_group_unittest.cc",
+#     "process_manager_unittest.cc",
+#     "process_map_unittest.cc",
+#     "quota_service_unittest.cc",
+#     "renderer_startup_helper_unittest.cc",
+#     "requirements_checker_unittest.cc",
+#     "runtime_data_unittest.cc",
+#     "sandboxed_unpacker_unittest.cc",
+#     "service_worker/worker_id_set_unittest.cc",
+#     "updater/extension_downloader_unittest.cc",
+#     "updater/extension_installer_unittest.cc",
+#     "updater/safe_manifest_parser_unittest.cc",
+#     "updater/update_data_provider_unittest.cc",
+#     "updater/update_service_unittest.cc",
+#     "value_store/leveldb_scoped_database_unittest.cc",
+#     "value_store/leveldb_value_store_unittest.cc",
+#     "value_store/testing_value_store_unittest.cc",
+#     "value_store/value_store_change_unittest.cc",
+#     "value_store/value_store_frontend_unittest.cc",
+#     "verified_contents_unittest.cc",
+#     "warning_service_unittest.cc",
+#   ]
+
+#   deps = [
+#     ":browser",
+#     ":test_support",
+#     ":value_store_test_support",
+#     "//base",
+#     "//base/test:test_support",
+#     "//components/cast_certificate",
+#     "//components/cast_certificate:test_support",
+#     "//components/crx_file",
+#     "//components/keyed_service/content",
+#     "//components/onc",
+#     "//components/pref_registry:pref_registry",
+#     "//components/prefs:test_support",
+#     "//components/services/unzip:in_process",
+#     "//components/services/unzip/content",
+#     "//components/storage_monitor:test_support",
+#     "//components/sync_preferences:test_support",
+#     "//components/update_client",
+#     "//components/url_matcher",
+#     "//components/user_prefs",
+#     "//components/version_info",
+#     "//content/test:test_support",
+#     "//device/bluetooth:mocks",
+#     "//extensions:extensions_browser_resources",
+#     "//extensions:test_support",
+#     "//extensions/browser/api/declarative_net_request/filter_list_converter:unit_tests",
+#     "//extensions/buildflags",
+#     "//extensions/common",
+#     "//extensions/common:test_support",
+#     "//extensions/common/api",
+#     "//extensions/strings",
+#     "//ipc:test_support",
+#     "//net:test_support",
+#     "//services/data_decoder:lib",
+#     "//services/data_decoder/public/cpp:test_support",
+#     "//services/device/public/mojom",
+#     "//services/network:test_support",
+#     "//services/network/public/cpp",
+#     "//services/service_manager/public/cpp/test:test_support",
+#     "//storage/browser:test_support",
+#     "//third_party/leveldatabase",
+#     "//third_party/openscreen/src/cast/common/certificate/proto:certificate_unittest_proto",
+#     "//third_party/zlib/google:zip",
+#   ]
+
+#   if (is_chromeos) {
+#     sources += [
+#       "api/audio/audio_device_id_calculator_unittest.cc",
+#       "api/feedback_private/access_rate_limiter_chromeos_unittest.cc",
+#       "api/feedback_private/feedback_private_api_chromeos_unittest.cc",
+#       "api/feedback_private/feedback_private_api_unittest_base_chromeos.cc",
+#       "api/feedback_private/feedback_private_api_unittest_base_chromeos.h",
+#       "api/feedback_private/log_source_access_manager_chromeos_unittest.cc",
+#       "api/lock_screen_data/data_item_unittest.cc",
+#       "api/lock_screen_data/lock_screen_item_storage_unittest.cc",
+#       "api/lock_screen_data/lock_screen_value_store_migrator_impl_unittest.cc",
+#       "api/media_perception_private/conversion_utils_unittest.cc",
+#       "api/media_perception_private/media_perception_api_manager_unittest.cc",
+#       "api/system_power_source/system_power_source_api_unittest.cc",
+#       "api/virtual_keyboard_private/virtual_keyboard_private_api_unittest.cc",
+#       "api/webcam_private/visca_webcam_unittest.cc",
+#     ]
+
+#     deps += [
+#       "//chromeos:test_support",
+#       "//chromeos/dbus:test_support",
+#       "//chromeos/dbus/audio",
+#       "//chromeos/dbus/media_analytics",
+#       "//chromeos/dbus/media_analytics:media_perception_proto",
+#       "//chromeos/dbus/power",
+#       "//chromeos/dbus/upstart",
+#       "//chromeos/login/login_state",
+#       "//chromeos/network:test_support",
+#       "//components/feedback",
+#       "//extensions/shell:app_shell_lib",
+#     ]
+#   }
+
+#   data = [
+#     "//extensions/browser/extension_event_histogram_value.h",
+#     "//extensions/browser/extension_function_histogram_value.h",
+#     "//tools/metrics/histograms/enums.xml",
+#     "//extensions/browser/api/declarative_net_request/flat/extension_ruleset.fbs",
+#   ]
+# }
diff --git a/components/user_scripts/browser/extension_file_task_runner.cc b/components/user_scripts/browser/extension_file_task_runner.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/browser/extension_file_task_runner.cc
@@ -0,0 +1,40 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "extension_file_task_runner.h"
+
+#include "base/sequenced_task_runner.h"
+#include "base/task/lazy_thread_pool_task_runner.h"
+#include "base/task/task_traits.h"
+
+namespace user_scripts {
+
+namespace {
+
+// Note: All tasks posted to a single task runner have the same priority. This
+// is unfortunate, since some file-related tasks are high priority (like serving
+// a file from the extension protocols or loading an extension in response to a
+// user action), and others are low priority (like garbage collection). Split
+// the difference and use USER_VISIBLE, which is the default priority and what a
+// task posted to a named thread (like the FILE thread) would receive.
+base::LazyThreadPoolSequencedTaskRunner g_us_task_runner =
+    LAZY_THREAD_POOL_SEQUENCED_TASK_RUNNER_INITIALIZER(
+        base::TaskTraits(base::MayBlock(),
+                         base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN,
+                         base::TaskPriority::USER_VISIBLE));
+
+}  // namespace
+
+scoped_refptr<base::SequencedTaskRunner> GetUserScriptsFileTaskRunner() {
+  return g_us_task_runner.Get();
+}
+
+scoped_refptr<base::SequencedTaskRunner> GetOneShotFileTaskRunner(
+    base::TaskPriority priority) {
+  return base::ThreadPool::CreateSequencedTaskRunner(
+      {base::MayBlock(), base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN,
+       priority});
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/browser/extension_file_task_runner.h b/components/user_scripts/browser/extension_file_task_runner.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/browser/extension_file_task_runner.h
@@ -0,0 +1,32 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_BROWSER_EXTENSION_FILE_TASK_RUNNER_H_
+#define EXTENSIONS_BROWSER_EXTENSION_FILE_TASK_RUNNER_H_
+
+#include "base/memory/ref_counted.h"
+#include "base/task/task_traits.h"
+
+namespace base {
+class SequencedTaskRunner;
+}
+
+namespace user_scripts {
+
+// Returns the singleton instance of the task runner to be used for most
+// extension-related tasks that read, modify, or delete files. All these tasks
+// must be posted to this task runner, even if it is only reading the file,
+// since other tasks may be modifying it.
+scoped_refptr<base::SequencedTaskRunner> GetUserScriptsFileTaskRunner();
+
+// Returns a non-singleton task runner, for tasks that touch files, but won't
+// race with each other. Currently, this is used to unpack multiple extensions
+// in parallel. They each touch a different set of files, which avoids potential
+// race conditions.
+scoped_refptr<base::SequencedTaskRunner> GetOneShotFileTaskRunner(
+    base::TaskPriority priority);
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_BROWSER_EXTENSION_FILE_TASK_RUNNER_H_
diff --git a/components/user_scripts/browser/extensions_browser_client.cc b/components/user_scripts/browser/extensions_browser_client.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/browser/extensions_browser_client.cc
@@ -0,0 +1,175 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "extensions_browser_client.h"
+
+#include "base/logging.h"
+
+#include "chrome/browser/browser_process.h"
+
+#include "storage/common/file_system/file_system_util.h"
+
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/browser/profiles/profile_manager.h"
+
+#include "user_script_loader.h"
+#include "extension_file_task_runner.h"
+//#include "components/update_client/update_client.h"
+//#include "extensions/browser/extension_api_frame_id_map.h"
+//#include "extensions/browser/extension_error.h"
+
+namespace user_scripts {
+
+namespace {
+
+// was ExtensionsBrowserClient
+UserScriptsBrowserClient* g_userscripts_browser_client = NULL;
+//std::unique_ptr<user_scripts::UserScriptsBrowserClient> g_userscripts_browser_client_ptr_;
+
+//static const char kRootName[] = "/";
+//static const char file_system_id[] = "snippets";
+}  // namespace
+
+UserScriptsBrowserClient::UserScriptsBrowserClient() {
+  // chrome/browser/devtools/devtools_file_helper.cc
+  
+  LOG(INFO) << "---Starting UserScriptsBrowserClient";
+}
+
+UserScriptsBrowserClient::~UserScriptsBrowserClient() = default;
+
+// static
+UserScriptsBrowserClient* UserScriptsBrowserClient::GetInstance() {
+  LOG(INFO) << "---UserScriptsBrowserClient::GetInstance()";
+
+  // only for browser process
+  if(!g_browser_process)
+    return NULL;
+
+  // singleton
+  if(g_userscripts_browser_client)
+    return g_userscripts_browser_client;
+
+  // make file task runner
+  GetUserScriptsFileTaskRunner().get();
+
+  // instance singleton
+  // g_userscripts_browser_client_ptr_ =
+  //    std::make_unique<user_scripts::UserScriptsBrowserClient>();
+  g_userscripts_browser_client = new UserScriptsBrowserClient(); //userscripts_browser_client_.get();
+
+  return g_userscripts_browser_client;
+}
+
+void UserScriptsBrowserClient::SetProfile(content::BrowserContext* context) {
+  LOG(INFO) << "---UserScriptsBrowserClient::SetProfile()";
+  browser_context_ = context;
+  userscript_loader_ = 
+    std::make_unique<user_scripts::UserScriptLoader>(browser_context_); 
+    //  HostID(HostID::HostType::WEBUI, "test"));
+  userscript_loader_->SetReady(true);
+  LOG(INFO) << "---UserScriptsBrowserClient::SetProfile() done";
+}
+
+// void UserScriptsBrowserClient::Set(UserScriptsBrowserClient* client) {
+//    g_userscripts_browser_client = client;
+// }
+
+// void ExtensionsBrowserClient::RegisterExtensionFunctions(
+//     ExtensionFunctionRegistry* registry) {
+//   for (const auto& provider : providers_)
+//     provider->RegisterExtensionFunctions(registry);
+// }
+
+// void ExtensionsBrowserClient::AddAPIProvider(
+//     std::unique_ptr<ExtensionsBrowserAPIProvider> provider) {
+//   providers_.push_back(std::move(provider));
+// }
+
+// scoped_refptr<update_client::UpdateClient>
+// ExtensionsBrowserClient::CreateUpdateClient(content::BrowserContext* context) {
+//   return scoped_refptr<update_client::UpdateClient>(nullptr);
+// }
+
+// std::unique_ptr<content::BluetoothChooser>
+// ExtensionsBrowserClient::CreateBluetoothChooser(
+//     content::RenderFrameHost* frame,
+//     const content::BluetoothChooser::EventHandler& event_handler) {
+//   return nullptr;
+// }
+
+// void ExtensionsBrowserClient::ReportError(
+//     content::BrowserContext* context,
+//     std::unique_ptr<ExtensionError> error) {
+//   LOG(ERROR) << error->GetDebugString();
+// }
+
+// bool ExtensionsBrowserClient::IsActivityLoggingEnabled(
+//     content::BrowserContext* context) {
+//   return false;
+// }
+
+// void ExtensionsBrowserClient::GetTabAndWindowIdForWebContents(
+//     content::WebContents* web_contents,
+//     int* tab_id,
+//     int* window_id) {
+//   *tab_id = -1;
+//   *window_id = -1;
+// }
+
+// bool ExtensionsBrowserClient::IsExtensionEnabled(
+//     const std::string& extension_id,
+//     content::BrowserContext* context) const {
+//   return false;
+// }
+
+// bool ExtensionsBrowserClient::IsWebUIAllowedToMakeNetworkRequests(
+//     const url::Origin& origin) {
+//   return false;
+// }
+
+// network::mojom::NetworkContext*
+// ExtensionsBrowserClient::GetSystemNetworkContext() {
+//   return nullptr;
+// }
+
+// UserScriptListener* ExtensionsBrowserClient::GetUserScriptListener() {
+//   return nullptr;
+// }
+
+// std::string ExtensionsBrowserClient::GetUserAgent() const {
+//   return std::string();
+// }
+
+// bool ExtensionsBrowserClient::ShouldSchemeBypassNavigationChecks(
+//     const std::string& scheme) const {
+//   return false;
+// }
+
+// base::FilePath ExtensionsBrowserClient::GetSaveFilePath(
+//     content::BrowserContext* context) {
+//   return base::FilePath();
+// }
+
+// void ExtensionsBrowserClient::SetLastSaveFilePath(
+//     content::BrowserContext* context,
+//     const base::FilePath& path) {}
+
+// const MediaRouterExtensionAccessLogger*
+// ExtensionsBrowserClient::GetMediaRouterAccessLogger() const {
+//   return nullptr;
+// }
+
+// bool ExtensionsBrowserClient::HasIsolatedStorage(
+//     const std::string& extension_id,
+//     content::BrowserContext* context) {
+//   return false;
+// }
+
+// bool ExtensionsBrowserClient::IsScreenshotRestricted(
+//     content::WebContents* web_contents) const {
+//   return false;
+// }
+
+}  // namespace extensions
diff --git a/components/user_scripts/browser/extensions_browser_client.h b/components/user_scripts/browser/extensions_browser_client.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/browser/extensions_browser_client.h
@@ -0,0 +1,389 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef USERSCRIPTS_BROWSER_USERSCRIPTS_BROWSER_CLIENT_H_
+#define USERSCRIPTS_BROWSER_USERSCRIPTS_BROWSER_CLIENT_H_
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "content/public/browser/browser_context.h"
+
+#include "user_script_loader.h"
+#include "../common/user_script.h"
+
+// #include "base/memory/ref_counted.h"
+// #include "build/build_config.h"
+// #include "content/public/browser/bluetooth_chooser.h"
+// #include "content/public/browser/storage_partition_config.h"
+// #include "extensions/browser/extension_event_histogram_value.h"
+// #include "extensions/browser/extension_prefs_observer.h"
+// #include "extensions/browser/extensions_browser_api_provider.h"
+// #include "extensions/common/extension_id.h"
+// #include "extensions/common/view_type.h"
+// #include "mojo/public/cpp/bindings/binder_map.h"
+// #include "mojo/public/cpp/bindings/pending_receiver.h"
+// #include "mojo/public/cpp/bindings/pending_remote.h"
+// #include "services/network/public/mojom/url_loader.mojom-forward.h"
+// #include "third_party/blink/public/mojom/loader/resource_load_info.mojom-shared.h"
+// #include "ui/base/page_transition_types.h"
+
+// class ExtensionFunctionRegistry;
+// class GURL;
+// class PrefService;
+
+// namespace base {
+// class CommandLine;
+// class FilePath;
+// class ListValue;
+// }  // namespace base
+
+// namespace content {
+// class BrowserContext;
+// class RenderFrameHost;
+// class WebContents;
+// }  // namespace content
+
+// namespace network {
+// struct ResourceRequest;
+// namespace mojom {
+// class NetworkContext;
+// }
+// }  // namespace network
+
+// namespace update_client {
+// class UpdateClient;
+// }
+
+// namespace url {
+// class Origin;
+// }
+
+namespace user_scripts {
+
+// class ComponentExtensionResourceManager;
+// class Extension;
+// class ExtensionCache;
+// class ExtensionError;
+// class ExtensionHostDelegate;
+// class ExtensionSet;
+// class ExtensionSystem;
+// class ExtensionSystemProvider;
+// class ExtensionWebContentsObserver;
+// class KioskDelegate;
+// class MediaRouterExtensionAccessLogger;
+// class ProcessManagerDelegate;
+// class ProcessMap;
+// class RuntimeAPIDelegate;
+// class UserScriptListener;
+
+// Interface to allow the extensions module to make browser-process-specific
+// queries of the embedder. Should be Set() once in the browser process.
+//
+// NOTE: Methods that do not require knowledge of browser concepts should be
+// added in ExtensionsClient (extensions/common/extensions_client.h) even if
+// they are only used in the browser process.
+class UserScriptsBrowserClient {
+ public:
+  UserScriptsBrowserClient();
+  UserScriptsBrowserClient(const UserScriptsBrowserClient&) = delete;
+  UserScriptsBrowserClient& operator=(const UserScriptsBrowserClient&) = delete;
+  virtual ~UserScriptsBrowserClient();
+
+  // Returns the single instance of |this|.
+  static UserScriptsBrowserClient* GetInstance();
+
+  // Sets and initializes the single instance.
+  //static void Set(UserScriptsBrowserClient* client);
+
+  void SetProfile(content::BrowserContext* context);
+
+//   // Registers all extension functions.
+//   void RegisterExtensionFunctions(ExtensionFunctionRegistry* registry);
+
+//   // Adds a new API provider to the client.
+//   void AddAPIProvider(std::unique_ptr<ExtensionsBrowserAPIProvider> provider);
+
+//   /////////////////////////////////////////////////////////////////////////////
+//   // Virtual Methods
+
+//   // Returns true if the embedder has started shutting down.
+//   virtual bool IsShuttingDown() = 0;
+
+//   // Returns true if extensions have been disabled (e.g. via a command-line flag
+//   // or preference).
+//   virtual bool AreExtensionsDisabled(const base::CommandLine& command_line,
+//                                      content::BrowserContext* context) = 0;
+
+//   // Returns true if the |context| is known to the embedder.
+//   virtual bool IsValidContext(content::BrowserContext* context) = 0;
+
+//   // Returns true if the BrowserContexts could be considered equivalent, for
+//   // example, if one is an off-the-record context owned by the other.
+//   virtual bool IsSameContext(content::BrowserContext* first,
+//                              content::BrowserContext* second) = 0;
+
+//   // Returns true if |context| has an off-the-record context associated with it.
+//   virtual bool HasOffTheRecordContext(content::BrowserContext* context) = 0;
+
+//   // Returns the off-the-record context associated with |context|. If |context|
+//   // is already off-the-record, returns |context|.
+//   // WARNING: This may create a new off-the-record context. To avoid creating
+//   // another context, check HasOffTheRecordContext() first.
+//   virtual content::BrowserContext* GetOffTheRecordContext(
+//       content::BrowserContext* context) = 0;
+
+//   // Returns the original "recording" context. This method returns |context| if
+//   // |context| is not incognito.
+//   virtual content::BrowserContext* GetOriginalContext(
+//       content::BrowserContext* context) = 0;
+
+// #if defined(OS_CHROMEOS)
+//   // Returns a user id hash from |context| or an empty string if no hash could
+//   // be extracted.
+//   virtual std::string GetUserIdHashFromContext(
+//       content::BrowserContext* context) = 0;
+// #endif
+
+//   // Returns true if |context| corresponds to a guest session.
+//   virtual bool IsGuestSession(content::BrowserContext* context) const = 0;
+
+//   // Returns true if |extension_id| can run in an incognito window.
+//   virtual bool IsExtensionIncognitoEnabled(
+//       const std::string& extension_id,
+//       content::BrowserContext* context) const = 0;
+
+//   // Returns true if |extension| can see events and data from another
+//   // sub-profile (incognito to original profile, or vice versa).
+//   virtual bool CanExtensionCrossIncognito(
+//       const extensions::Extension* extension,
+//       content::BrowserContext* context) const = 0;
+
+//   // Return the resource relative path and id for the given request.
+//   virtual base::FilePath GetBundleResourcePath(
+//       const network::ResourceRequest& request,
+//       const base::FilePath& extension_resources_path,
+//       int* resource_id) const = 0;
+
+//   // Creates and starts a URLLoader to load an extension resource from the
+//   // embedder's resource bundle (.pak) files. Used for component extensions.
+//   virtual void LoadResourceFromResourceBundle(
+//       const network::ResourceRequest& request,
+//       mojo::PendingReceiver<network::mojom::URLLoader> loader,
+//       const base::FilePath& resource_relative_path,
+//       int resource_id,
+//       const std::string& content_security_policy,
+//       mojo::PendingRemote<network::mojom::URLLoaderClient> client,
+//       bool send_cors_header) = 0;
+
+//   // Returns true if the embedder wants to allow a chrome-extension:// resource
+//   // request coming from renderer A to access a resource in an extension running
+//   // in renderer B. For example, Chrome overrides this to provide support for
+//   // webview and dev tools. May be called on either the UI or IO thread.
+//   virtual bool AllowCrossRendererResourceLoad(
+//       const GURL& url,
+//       blink::mojom::ResourceType resource_type,
+//       ui::PageTransition page_transition,
+//       int child_id,
+//       bool is_incognito,
+//       const Extension* extension,
+//       const ExtensionSet& extensions,
+//       const ProcessMap& process_map) = 0;
+
+//   // Returns the PrefService associated with |context|.
+//   virtual PrefService* GetPrefServiceForContext(
+//       content::BrowserContext* context) = 0;
+
+//   // Populates a list of ExtensionPrefs observers to be attached to each
+//   // BrowserContext's ExtensionPrefs upon construction. These observers
+//   // are not owned by ExtensionPrefs.
+//   virtual void GetEarlyExtensionPrefsObservers(
+//       content::BrowserContext* context,
+//       std::vector<EarlyExtensionPrefsObserver*>* observers) const = 0;
+
+//   // Returns the ProcessManagerDelegate shared across all BrowserContexts. May
+//   // return NULL in tests or for simple embedders.
+//   virtual ProcessManagerDelegate* GetProcessManagerDelegate() const = 0;
+
+//   // Creates a new ExtensionHostDelegate instance.
+//   virtual std::unique_ptr<ExtensionHostDelegate>
+//   CreateExtensionHostDelegate() = 0;
+
+//   // Returns true if the client version has updated since the last run. Called
+//   // once each time the extensions system is loaded per browser_context. The
+//   // implementation may wish to use the BrowserContext to record the current
+//   // version for later comparison.
+//   virtual bool DidVersionUpdate(content::BrowserContext* context) = 0;
+
+//   // Permits an external protocol handler to be launched. See
+//   // ExternalProtocolHandler::PermitLaunchUrl() in Chrome.
+//   virtual void PermitExternalProtocolHandler() = 0;
+
+//   // Return true if the device is enrolled in Demo Mode.
+//   virtual bool IsInDemoMode() = 0;
+
+//   // Return true if |app_id| matches the screensaver and the device is enrolled
+//   // in Demo Mode.
+//   virtual bool IsScreensaverInDemoMode(const std::string& app_id) = 0;
+
+//   // Return true if the system is run in forced app mode.
+//   virtual bool IsRunningInForcedAppMode() = 0;
+
+//   // Returns whether the system is run in forced app mode for app with the
+//   // provided extension ID.
+//   virtual bool IsAppModeForcedForApp(const ExtensionId& id) = 0;
+
+//   // Return true if the user is logged in as a public session.
+//   virtual bool IsLoggedInAsPublicAccount() = 0;
+
+//   // Returns the factory that provides an ExtensionSystem to be returned from
+//   // ExtensionSystem::Get.
+//   virtual ExtensionSystemProvider* GetExtensionSystemFactory() = 0;
+
+//   // Registers additional interfaces to a binder map for a browser interface
+//   // broker.
+//   virtual void RegisterBrowserInterfaceBindersForFrame(
+//       mojo::BinderMapWithContext<content::RenderFrameHost*>* binder_map,
+//       content::RenderFrameHost* render_frame_host,
+//       const Extension* extension) const = 0;
+
+//   // Creates a RuntimeAPIDelegate responsible for handling extensions
+//   // management-related events such as update and installation on behalf of the
+//   // core runtime API implementation.
+//   virtual std::unique_ptr<RuntimeAPIDelegate> CreateRuntimeAPIDelegate(
+//       content::BrowserContext* context) const = 0;
+
+//   // Returns the manager of resource bundles used in extensions. Returns NULL if
+//   // the manager doesn't exist.
+//   virtual const ComponentExtensionResourceManager*
+//   GetComponentExtensionResourceManager() = 0;
+
+//   // Propagate a event to all the renderers in every browser context. The
+//   // implementation must be safe to call from any thread.
+//   virtual void BroadcastEventToRenderers(
+//       events::HistogramValue histogram_value,
+//       const std::string& event_name,
+//       std::unique_ptr<base::ListValue> args,
+//       bool dispatch_to_off_the_record_profiles) = 0;
+
+//   // Gets the single ExtensionCache instance shared across the browser process.
+//   virtual ExtensionCache* GetExtensionCache() = 0;
+
+//   // Indicates whether extension update checks should be allowed.
+//   virtual bool IsBackgroundUpdateAllowed() = 0;
+
+//   // Indicates whether an extension update which specifies its minimum browser
+//   // version as |min_version| can be installed by the client. Not all extensions
+//   // embedders share the same versioning model, so interpretation of the string
+//   // is left up to the embedder.
+//   virtual bool IsMinBrowserVersionSupported(const std::string& min_version) = 0;
+
+//   // Embedders can override this function to handle extension errors.
+//   virtual void ReportError(content::BrowserContext* context,
+//                            std::unique_ptr<ExtensionError> error);
+
+//   // Returns the ExtensionWebContentsObserver for the given |web_contents|.
+//   virtual ExtensionWebContentsObserver* GetExtensionWebContentsObserver(
+//       content::WebContents* web_contents) = 0;
+
+//   // Cleans up browser-side state associated with a WebView that is being
+//   // destroyed.
+//   virtual void CleanUpWebView(content::BrowserContext* browser_context,
+//                               int embedder_process_id,
+//                               int view_instance_id) {}
+
+//   // Attaches the task manager extension tag to |web_contents|, if needed based
+//   // on |view_type|, so that its corresponding task shows up in the task
+//   // manager.
+//   virtual void AttachExtensionTaskManagerTag(content::WebContents* web_contents,
+//                                              ViewType view_type) {}
+
+//   // Returns a new UpdateClient.
+//   virtual scoped_refptr<update_client::UpdateClient> CreateUpdateClient(
+//       content::BrowserContext* context);
+
+//   virtual std::unique_ptr<content::BluetoothChooser> CreateBluetoothChooser(
+//       content::RenderFrameHost* frame,
+//       const content::BluetoothChooser::EventHandler& event_handler);
+
+//   // Returns true if activity logging is enabled for the given |context|.
+//   virtual bool IsActivityLoggingEnabled(content::BrowserContext* context);
+
+//   // Retrives the embedder's notion of tab and window ID for a given
+//   // WebContents. May return -1 for either or both values if the embedder does
+//   // not implement any such concepts. This is used to support the WebRequest API
+//   // exposing such numbers to callers.
+//   virtual void GetTabAndWindowIdForWebContents(
+//       content::WebContents* web_contents,
+//       int* tab_id,
+//       int* window_id);
+
+//   // Returns a delegate that provides kiosk mode functionality.
+//   virtual KioskDelegate* GetKioskDelegate() = 0;
+
+//   // Whether the browser context is associated with Chrome OS lock screen.
+//   virtual bool IsLockScreenContext(content::BrowserContext* context) = 0;
+
+//   // Returns the locale used by the application.
+//   virtual std::string GetApplicationLocale() = 0;
+
+//   // Returns whether |extension_id| is currently enabled.
+//   // This will only return a valid answer for installed extensions (regardless
+//   // of whether it is currently loaded or not) under the provided |context|.
+//   // Loaded extensions return true if they are currently loaded or terminated.
+//   // Unloaded extensions will return true if they are not blocked, disabled,
+//   // blocklisted or uninstalled (for external extensions). The default return
+//   // value of this function is false.
+//   virtual bool IsExtensionEnabled(const std::string& extension_id,
+//                                   content::BrowserContext* context) const;
+
+//   // http://crbug.com/829412
+//   // Renderers with WebUI bindings shouldn't make http(s) requests for security
+//   // reasons (e.g. to avoid malicious responses being able to run code in
+//   // priviliged renderers). Fix these webui's to make requests through C++
+//   // code instead.
+//   virtual bool IsWebUIAllowedToMakeNetworkRequests(const url::Origin& origin);
+
+//   virtual network::mojom::NetworkContext* GetSystemNetworkContext();
+
+//   virtual UserScriptListener* GetUserScriptListener();
+
+//   // Returns the user agent used by the content module.
+//   virtual std::string GetUserAgent() const;
+
+//   // Returns whether |scheme| should bypass extension-specific navigation checks
+//   // (e.g. whether the |scheme| is allowed to initiate navigations to extension
+//   // resources that are not declared as web accessible).
+//   virtual bool ShouldSchemeBypassNavigationChecks(
+//       const std::string& scheme) const;
+
+//   // Gets and sets the last save (download) path for a given context.
+//   virtual base::FilePath GetSaveFilePath(content::BrowserContext* context);
+//   virtual void SetLastSaveFilePath(content::BrowserContext* context,
+//                                    const base::FilePath& path);
+
+//   // Retrieves the media router access logger for this session.
+//   virtual const MediaRouterExtensionAccessLogger* GetMediaRouterAccessLogger()
+//       const;
+
+//   // Returns true if the |extension_id| requires its own isolated storage
+//   // partition.
+//   virtual bool HasIsolatedStorage(const std::string& extension_id,
+//                                   content::BrowserContext* context);
+
+//   // Returns whether screenshot of |web_contents| is restricted due to Data Leak
+//   // Protection policy.
+//   virtual bool IsScreenshotRestricted(content::WebContents* web_contents) const;
+
+  private:
+//   std::vector<std::unique_ptr<ExtensionsBrowserAPIProvider>> providers_;
+    std::unique_ptr<UserScriptList> scripts_;
+    content::BrowserContext* browser_context_;
+    std::unique_ptr<user_scripts::UserScriptLoader> userscript_loader_;
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_BROWSER_EXTENSIONS_BROWSER_CLIENT_H_
diff --git a/components/user_scripts/browser/na/convert_user_script.cc b/components/user_scripts/browser/na/convert_user_script.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/browser/na/convert_user_script.cc
@@ -0,0 +1,193 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/convert_user_script.h"
+
+#include <stddef.h>
+
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/base64.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/files/scoped_temp_dir.h"
+#include "base/json/json_file_value_serializer.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/values.h"
+#include "chrome/common/chrome_paths.h"
+#include "crypto/sha2.h"
+#include "extensions/browser/extension_user_script_loader.h"
+#include "extensions/common/constants.h"
+#include "extensions/common/extension.h"
+#include "extensions/common/file_util.h"
+#include "extensions/common/manifest_constants.h"
+#include "extensions/common/user_script.h"
+#include "url/gurl.h"
+
+namespace user_scripts {
+
+scoped_refptr<Extension> ConvertUserScriptToExtension(
+    const base::FilePath& user_script_path, const GURL& original_url,
+    const base::FilePath& extensions_dir, base::string16* error) {
+  std::string content;
+  if (!base::ReadFileToString(user_script_path, &content)) {
+    *error = base::ASCIIToUTF16("Could not read source file.");
+    return nullptr;
+  }
+
+  if (!base::IsStringUTF8(content)) {
+    *error = base::ASCIIToUTF16("User script must be UTF8 encoded.");
+    return nullptr;
+  }
+
+  UserScript script;
+  if (!UserScriptLoader::ParseMetadataHeader(content, &script)) {
+    *error = base::ASCIIToUTF16("Invalid script header.");
+    return nullptr;
+  }
+
+  base::FilePath install_temp_dir =
+      file_util::GetInstallTempDir(extensions_dir);
+  if (install_temp_dir.empty()) {
+    *error = base::ASCIIToUTF16(
+        "Could not get path to profile temporary directory.");
+    return nullptr;
+  }
+
+  base::ScopedTempDir temp_dir;
+  if (!temp_dir.CreateUniqueTempDirUnderPath(install_temp_dir)) {
+    *error = base::ASCIIToUTF16("Could not create temporary directory.");
+    return nullptr;
+  }
+
+  // Create the manifest
+  std::unique_ptr<base::DictionaryValue> root(new base::DictionaryValue);
+  std::string script_name;
+  if (!script.name().empty() && !script.name_space().empty())
+    script_name = script.name_space() + "/" + script.name();
+  else
+    script_name = original_url.spec();
+
+  // Create the public key.
+  // User scripts are not signed, but the public key for an extension doubles as
+  // its unique identity, and we need one of those. A user script's unique
+  // identity is its namespace+name, so we hash that to create a public key.
+  // There will be no corresponding private key, which means user scripts cannot
+  // be auto-updated, or claimed in the gallery.
+  char raw[crypto::kSHA256Length] = {0};
+  std::string key;
+  crypto::SHA256HashString(script_name, raw, crypto::kSHA256Length);
+  base::Base64Encode(base::StringPiece(raw, crypto::kSHA256Length), &key);
+
+  // The script may not have a name field, but we need one for an extension. If
+  // it is missing, use the filename of the original URL.
+  if (!script.name().empty())
+    root->SetString(manifest_keys::kName, script.name());
+  else
+    root->SetString(manifest_keys::kName, original_url.ExtractFileName());
+
+  // Not all scripts have a version, but we need one. Default to 1.0 if it is
+  // missing.
+  if (!script.version().empty())
+    root->SetString(manifest_keys::kVersion, script.version());
+  else
+    root->SetString(manifest_keys::kVersion, "1.0");
+
+  root->SetString(manifest_keys::kDescription, script.description());
+  root->SetString(manifest_keys::kPublicKey, key);
+  root->SetBoolean(manifest_keys::kConvertedFromUserScript, true);
+
+  auto js_files = std::make_unique<base::ListValue>();
+  js_files->AppendString("script.js");
+
+  // If the script provides its own match patterns, we use those. Otherwise, we
+  // generate some using the include globs.
+  auto matches = std::make_unique<base::ListValue>();
+  if (!script.url_patterns().is_empty()) {
+    for (auto i = script.url_patterns().begin();
+         i != script.url_patterns().end(); ++i) {
+      matches->AppendString(i->GetAsString());
+    }
+  } else {
+    // TODO(aa): Derive tighter matches where possible.
+    matches->AppendString("http://*/*");
+    matches->AppendString("https://*/*");
+  }
+
+  // Read the exclude matches, if any are present.
+  auto exclude_matches = std::make_unique<base::ListValue>();
+  if (!script.exclude_url_patterns().is_empty()) {
+    for (auto i = script.exclude_url_patterns().begin();
+         i != script.exclude_url_patterns().end(); ++i) {
+      exclude_matches->AppendString(i->GetAsString());
+    }
+  }
+
+  auto includes = std::make_unique<base::ListValue>();
+  for (size_t i = 0; i < script.globs().size(); ++i)
+    includes->AppendString(script.globs().at(i));
+
+  auto excludes = std::make_unique<base::ListValue>();
+  for (size_t i = 0; i < script.exclude_globs().size(); ++i)
+    excludes->AppendString(script.exclude_globs().at(i));
+
+  auto content_script = std::make_unique<base::DictionaryValue>();
+  content_script->Set(manifest_keys::kMatches, std::move(matches));
+  content_script->Set(manifest_keys::kExcludeMatches,
+                      std::move(exclude_matches));
+  content_script->Set(manifest_keys::kIncludeGlobs, std::move(includes));
+  content_script->Set(manifest_keys::kExcludeGlobs, std::move(excludes));
+  content_script->Set(manifest_keys::kJs, std::move(js_files));
+
+  if (script.run_location() == UserScript::DOCUMENT_START)
+    content_script->SetString(manifest_keys::kRunAt,
+                              manifest_values::kRunAtDocumentStart);
+  else if (script.run_location() == UserScript::DOCUMENT_END)
+    content_script->SetString(manifest_keys::kRunAt,
+                              manifest_values::kRunAtDocumentEnd);
+  else if (script.run_location() == UserScript::DOCUMENT_IDLE)
+    // This is the default, but store it just in case we change that.
+    content_script->SetString(manifest_keys::kRunAt,
+                              manifest_values::kRunAtDocumentIdle);
+
+  auto content_scripts = std::make_unique<base::ListValue>();
+  content_scripts->Append(std::move(content_script));
+
+  root->Set(manifest_keys::kContentScripts, std::move(content_scripts));
+
+  base::FilePath manifest_path = temp_dir.GetPath().Append(kManifestFilename);
+  JSONFileValueSerializer serializer(manifest_path);
+  if (!serializer.Serialize(*root)) {
+    *error = base::ASCIIToUTF16("Could not write JSON.");
+    return nullptr;
+  }
+
+  // Write the script file.
+  if (!base::CopyFile(user_script_path,
+                      temp_dir.GetPath().AppendASCII("script.js"))) {
+    *error = base::ASCIIToUTF16("Could not copy script file.");
+    return nullptr;
+  }
+
+  // TODO(rdevlin.cronin): Continue removing std::string errors and replacing
+  // with base::string16
+  std::string utf8_error;
+  scoped_refptr<Extension> extension =
+      Extension::Create(temp_dir.GetPath(), Manifest::INTERNAL, *root,
+                        Extension::NO_FLAGS, &utf8_error);
+  *error = base::UTF8ToUTF16(utf8_error);
+  if (!extension.get()) {
+    NOTREACHED() << "Could not init extension " << *error;
+    return nullptr;
+  }
+
+  temp_dir.Take();  // The caller takes ownership of the directory.
+  return extension;
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/browser/na/convert_user_script.h b/components/user_scripts/browser/na/convert_user_script.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/browser/na/convert_user_script.h
@@ -0,0 +1,35 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_CONVERT_USER_SCRIPT_H_
+#define CHROME_BROWSER_EXTENSIONS_CONVERT_USER_SCRIPT_H_
+
+#include <string>
+
+#include "base/memory/ref_counted.h"
+#include "base/strings/string16.h"
+
+class GURL;
+
+namespace base {
+class FilePath;
+}
+
+namespace extensions {
+class Extension;
+
+// Wraps the specified user script in an extension. The extension is created
+// unpacked in the system temp dir. Returns a valid extension that the caller
+// should take ownership on success, or NULL and |error| on failure.
+//
+// NOTE: This function does file IO and should not be called on the UI thread.
+// NOTE: The caller takes ownership of the directory at extension->path() on the
+// returned object.
+scoped_refptr<extensions::Extension> ConvertUserScriptToExtension(
+    const base::FilePath& user_script, const GURL& original_url,
+    const base::FilePath& extensions_dir, base::string16* error);
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_CONVERT_USER_SCRIPT_H_
diff --git a/components/user_scripts/browser/na/crx_installer.cc b/components/user_scripts/browser/na/crx_installer.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/browser/na/crx_installer.cc
@@ -0,0 +1,1226 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "chrome/browser/extensions/crx_installer.h"
+
+#include <map>
+#include <set>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/command_line.h"
+#include "base/files/file_util.h"
+#include "base/files/scoped_temp_dir.h"
+#include "base/lazy_instance.h"
+#include "base/macros.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/sequenced_task_runner.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/threading/thread_restrictions.h"
+#include "base/time/time.h"
+#include "base/version.h"
+#include "build/build_config.h"
+#include "chrome/browser/extensions/blocklist_check.h"
+#include "chrome/browser/extensions/convert_user_script.h"
+#include "chrome/browser/extensions/convert_web_app.h"
+#include "chrome/browser/extensions/extension_assets_manager.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/extensions/forced_extensions/install_stage_tracker.h"
+#include "chrome/browser/extensions/install_tracker.h"
+#include "chrome/browser/extensions/install_tracker_factory.h"
+#include "chrome/browser/extensions/load_error_reporter.h"
+#include "chrome/browser/extensions/permissions_updater.h"
+#include "chrome/browser/extensions/webstore_installer.h"
+#include "chrome/browser/profiles/profile.h"
+#include "chrome/common/chrome_paths.h"
+#include "chrome/common/chrome_switches.h"
+#include "chrome/common/extensions/extension_constants.h"
+#include "chrome/common/web_application_info.h"
+#include "chrome/grit/generated_resources.h"
+#include "components/crx_file/crx_verifier.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/notification_service.h"
+#include "extensions/browser/content_verifier.h"
+#include "extensions/browser/extension_file_task_runner.h"
+#include "extensions/browser/extension_prefs.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/install/crx_install_error.h"
+#include "extensions/browser/install/extension_install_ui.h"
+#include "extensions/browser/install_flag.h"
+#include "extensions/browser/install_stage.h"
+#include "extensions/browser/notification_types.h"
+#include "extensions/browser/policy_check.h"
+#include "extensions/browser/preload_check_group.h"
+#include "extensions/browser/requirements_checker.h"
+#include "extensions/common/extension_icon_set.h"
+#include "extensions/common/file_util.h"
+#include "extensions/common/manifest.h"
+#include "extensions/common/manifest_handlers/kiosk_mode_info.h"
+#include "extensions/common/manifest_handlers/shared_module_info.h"
+#include "extensions/common/manifest_url_handlers.h"
+#include "extensions/common/permissions/permission_message_provider.h"
+#include "extensions/common/permissions/permission_set.h"
+#include "extensions/common/permissions/permissions_data.h"
+#include "extensions/common/user_script.h"
+#include "extensions/common/verifier_formats.h"
+#include "extensions/strings/grit/extensions_strings.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/l10n/l10n_util.h"
+
+#if defined(OS_CHROMEOS)
+#include "components/user_manager/user_manager.h"
+#endif
+
+using content::BrowserThread;
+
+namespace extensions {
+
+// static
+scoped_refptr<CrxInstaller> CrxInstaller::CreateSilent(
+    ExtensionService* frontend) {
+  return new CrxInstaller(frontend->AsWeakPtr(),
+                          std::unique_ptr<ExtensionInstallPrompt>(), NULL);
+}
+
+// static
+scoped_refptr<CrxInstaller> CrxInstaller::Create(
+    ExtensionService* frontend,
+    std::unique_ptr<ExtensionInstallPrompt> client) {
+  return new CrxInstaller(frontend->AsWeakPtr(), std::move(client), NULL);
+}
+
+// static
+scoped_refptr<CrxInstaller> CrxInstaller::Create(
+    ExtensionService* service,
+    std::unique_ptr<ExtensionInstallPrompt> client,
+    const WebstoreInstaller::Approval* approval) {
+  return new CrxInstaller(service->AsWeakPtr(), std::move(client), approval);
+}
+
+CrxInstaller::CrxInstaller(base::WeakPtr<ExtensionService> service_weak,
+                           std::unique_ptr<ExtensionInstallPrompt> client,
+                           const WebstoreInstaller::Approval* approval)
+    : profile_(service_weak->profile()),
+      install_directory_(service_weak->install_directory()),
+      install_source_(Manifest::INTERNAL),
+      approved_(false),
+      verification_check_failed_(false),
+      expected_manifest_check_level_(
+          WebstoreInstaller::MANIFEST_CHECK_LEVEL_STRICT),
+      fail_install_if_unexpected_version_(false),
+      extensions_enabled_(service_weak->extensions_enabled()),
+      delete_source_(false),
+      service_weak_(service_weak),
+      // See header file comment on |client_| for why we use a raw pointer here.
+      client_(client.release()),
+      apps_require_extension_mime_type_(false),
+      allow_silent_install_(false),
+      grant_permissions_(true),
+      install_cause_(extension_misc::INSTALL_CAUSE_UNSET),
+      creation_flags_(Extension::NO_FLAGS),
+      off_store_install_allow_reason_(OffStoreInstallDisallowed),
+      did_handle_successfully_(true),
+      error_on_unsupported_requirements_(false),
+      shared_file_task_runner_(GetExtensionFileTaskRunner()),
+      update_from_settings_page_(false),
+      install_flags_(kInstallFlagNone) {
+  if (!approval)
+    return;
+
+  CHECK(profile()->IsSameOrParent(approval->profile));
+  if (client_) {
+    client_->install_ui()->SetUseAppInstalledBubble(
+        approval->use_app_installed_bubble);
+    client_->install_ui()->SetSkipPostInstallUI(approval->skip_post_install_ui);
+  }
+
+  if (approval->skip_install_dialog) {
+    // Mark the extension as approved, but save the expected manifest and ID
+    // so we can check that they match the CRX's.
+    approved_ = true;
+    expected_manifest_check_level_ = approval->manifest_check_level;
+    if (expected_manifest_check_level_ !=
+        WebstoreInstaller::MANIFEST_CHECK_LEVEL_NONE) {
+      expected_manifest_ = approval->manifest->CreateDeepCopy();
+    }
+    expected_id_ = approval->extension_id;
+  }
+  if (approval->minimum_version.get())
+    minimum_version_ = base::Version(*approval->minimum_version);
+
+  show_dialog_callback_ = approval->show_dialog_callback;
+}
+
+CrxInstaller::~CrxInstaller() {
+  DCHECK(!service_weak_ || service_weak_->browser_terminating() ||
+         installer_callback_.is_null());
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // Ensure |client_| and |install_checker_| data members are destroyed on the
+  // UI thread. The |client_| dialog has a weak reference as |this| is its
+  // delegate, and |install_checker_| owns WeakPtrs, so must be destroyed on the
+  // same thread that created it.
+}
+
+void CrxInstaller::InstallCrx(const base::FilePath& source_file) {
+  crx_file::VerifierFormat format =
+      off_store_install_allow_reason_ == OffStoreInstallDisallowed
+          ? GetWebstoreVerifierFormat(
+                base::CommandLine::ForCurrentProcess()->HasSwitch(
+                    ::switches::kAppsGalleryURL))
+          : GetExternalVerifierFormat();
+  InstallCrxFile(CRXFileInfo(source_file, format));
+}
+
+void CrxInstaller::InstallCrxFile(const CRXFileInfo& source_file) {
+  ExtensionService* service = service_weak_.get();
+  if (!service || service->browser_terminating())
+    return;
+
+  NotifyCrxInstallBegin();
+
+  source_file_ = source_file.path;
+
+  auto unpacker = base::MakeRefCounted<SandboxedUnpacker>(
+      install_source_, creation_flags_, install_directory_,
+      GetUnpackerTaskRunner(), this);
+
+  if (!GetUnpackerTaskRunner()->PostTask(
+          FROM_HERE, base::BindOnce(&SandboxedUnpacker::StartWithCrx, unpacker,
+                                    source_file))) {
+    NOTREACHED();
+  }
+}
+
+void CrxInstaller::InstallUnpackedCrx(const std::string& extension_id,
+                                      const std::string& public_key,
+                                      const base::FilePath& unpacked_dir) {
+  ExtensionService* service = service_weak_.get();
+  if (!service || service->browser_terminating())
+    return;
+
+  NotifyCrxInstallBegin();
+
+  source_file_ = unpacked_dir;
+
+  auto unpacker = base::MakeRefCounted<SandboxedUnpacker>(
+      install_source_, creation_flags_, install_directory_,
+      GetUnpackerTaskRunner(), this);
+
+  if (!GetUnpackerTaskRunner()->PostTask(
+          FROM_HERE,
+          base::BindOnce(&SandboxedUnpacker::StartWithDirectory, unpacker,
+                         extension_id, public_key, unpacked_dir))) {
+    NOTREACHED();
+  }
+}
+
+void CrxInstaller::InstallUserScript(const base::FilePath& source_file,
+                                     const GURL& download_url) {
+  DCHECK(!download_url.is_empty());
+
+  NotifyCrxInstallBegin();
+
+  source_file_ = source_file;
+  download_url_ = download_url;
+
+  if (!shared_file_task_runner_->PostTask(
+          FROM_HERE,
+          base::BindOnce(&CrxInstaller::ConvertUserScriptOnSharedFileThread,
+                         this)))
+    NOTREACHED();
+}
+
+void CrxInstaller::ConvertUserScriptOnSharedFileThread() {
+  base::string16 error;
+  scoped_refptr<Extension> extension = ConvertUserScriptToExtension(
+      source_file_, download_url_, install_directory_, &error);
+  if (!extension.get()) {
+    ReportFailureFromSharedFileThread(CrxInstallError(
+        CrxInstallErrorType::OTHER,
+        CrxInstallErrorDetail::CONVERT_USER_SCRIPT_TO_EXTENSION_FAILED, error));
+    return;
+  }
+
+  OnUnpackSuccessOnSharedFileThread(extension->path(), extension->path(),
+                                    nullptr, extension, SkBitmap(),
+                                    {} /* ruleset_install_prefs */);
+}
+
+void CrxInstaller::InstallWebApp(const WebApplicationInfo& web_app) {
+  NotifyCrxInstallBegin();
+
+  if (!shared_file_task_runner_->PostTask(
+          FROM_HERE,
+          base::BindOnce(&CrxInstaller::ConvertWebAppOnSharedFileThread, this,
+                         web_app)))
+    NOTREACHED();
+}
+
+void CrxInstaller::UpdateExtensionFromUnpackedCrx(
+    const std::string& extension_id,
+    const std::string& public_key,
+    const base::FilePath& unpacked_dir) {
+  ExtensionService* service = service_weak_.get();
+  if (!service || service->browser_terminating())
+    return;
+
+  const Extension* extension = ExtensionRegistry::Get(service->profile())
+                                   ->GetInstalledExtension(extension_id);
+  if (!extension) {
+    LOG(WARNING) << "Will not update extension " << extension_id
+                 << " because it is not installed";
+    if (delete_source_)
+      temp_dir_ = unpacked_dir;
+    if (installer_callback_.is_null()) {
+      shared_file_task_runner_->PostTask(
+          FROM_HERE, base::BindOnce(&CrxInstaller::CleanupTempFiles, this));
+    } else {
+      shared_file_task_runner_->PostTaskAndReply(
+          FROM_HERE, base::BindOnce(&CrxInstaller::CleanupTempFiles, this),
+          base::BindOnce(
+              std::move(installer_callback_),
+              CrxInstallError(
+                  CrxInstallErrorType::OTHER,
+                  CrxInstallErrorDetail::UPDATE_NON_EXISTING_EXTENSION)));
+    }
+    return;
+  }
+
+  expected_id_ = extension_id;
+  install_source_ = extension->location();
+  install_cause_ = extension_misc::INSTALL_CAUSE_UPDATE;
+  InitializeCreationFlagsForUpdate(extension, Extension::NO_FLAGS);
+
+  const ExtensionPrefs* extension_prefs =
+      ExtensionPrefs::Get(service->GetBrowserContext());
+  DCHECK(extension_prefs);
+  set_do_not_sync(extension_prefs->DoNotSync(extension_id));
+
+  InstallUnpackedCrx(extension_id, public_key, unpacked_dir);
+}
+
+void CrxInstaller::ConvertWebAppOnSharedFileThread(
+    const WebApplicationInfo& web_app) {
+  scoped_refptr<Extension> extension(
+      ConvertWebAppToExtension(web_app, base::Time::Now(), install_directory_,
+                               creation_flags_, install_source_));
+  if (!extension.get()) {
+    // Validation should have stopped any potential errors before getting here.
+    NOTREACHED() << "Could not convert web app to extension.";
+    return;
+  }
+
+  // TODO(aa): conversion data gets lost here :(
+
+  OnUnpackSuccessOnSharedFileThread(extension->path(), extension->path(),
+                                    nullptr, extension, SkBitmap(),
+                                    {} /* ruleset_install_prefs */);
+}
+
+base::Optional<CrxInstallError> CrxInstaller::CheckExpectations(
+    const Extension* extension) {
+  DCHECK(shared_file_task_runner_->RunsTasksInCurrentSequence());
+
+  // Make sure the expected ID matches if one was supplied or if we want to
+  // bypass the prompt.
+  if ((approved_ || !expected_id_.empty()) &&
+      expected_id_ != extension->id()) {
+    return CrxInstallError(
+        CrxInstallErrorType::OTHER, CrxInstallErrorDetail::UNEXPECTED_ID,
+        l10n_util::GetStringFUTF16(IDS_EXTENSION_INSTALL_UNEXPECTED_ID,
+                                   base::ASCIIToUTF16(expected_id_),
+                                   base::ASCIIToUTF16(extension->id())));
+  }
+
+  if (expected_version_.IsValid() && fail_install_if_unexpected_version_ &&
+      expected_version_ != extension->version()) {
+    return CrxInstallError(
+        CrxInstallErrorType::OTHER, CrxInstallErrorDetail::MISMATCHED_VERSION,
+        l10n_util::GetStringFUTF16(
+            IDS_EXTENSION_INSTALL_UNEXPECTED_VERSION,
+            base::ASCIIToUTF16(expected_version_.GetString()),
+            base::ASCIIToUTF16(extension->version().GetString())));
+  }
+
+  return base::nullopt;
+}
+
+base::Optional<CrxInstallError> CrxInstaller::AllowInstall(
+    const Extension* extension) {
+  DCHECK(shared_file_task_runner_->RunsTasksInCurrentSequence());
+
+  if (minimum_version_.IsValid() &&
+      extension->version().CompareTo(minimum_version_) < 0) {
+    return CrxInstallError(
+        CrxInstallErrorType::OTHER, CrxInstallErrorDetail::UNEXPECTED_VERSION,
+        l10n_util::GetStringFUTF16(
+            IDS_EXTENSION_INSTALL_UNEXPECTED_VERSION,
+            base::ASCIIToUTF16(minimum_version_.GetString() + "+"),
+            base::ASCIIToUTF16(extension->version().GetString())));
+  }
+
+  // Make sure the manifests match if we want to bypass the prompt.
+  if (approved_) {
+    bool valid = false;
+    if (expected_manifest_check_level_ ==
+        WebstoreInstaller::MANIFEST_CHECK_LEVEL_NONE) {
+      // To skip manifest checking, the extension must be a shared module
+      // and not request any permissions.
+      if (SharedModuleInfo::IsSharedModule(extension) &&
+          extension->permissions_data()->active_permissions().IsEmpty()) {
+        valid = true;
+      }
+    } else {
+      valid = expected_manifest_->Equals(original_manifest_.get());
+      if (!valid && expected_manifest_check_level_ ==
+          WebstoreInstaller::MANIFEST_CHECK_LEVEL_LOOSE) {
+        std::string error;
+        scoped_refptr<Extension> dummy_extension =
+            Extension::Create(base::FilePath(),
+                              install_source_,
+                              *expected_manifest_->value(),
+                              creation_flags_,
+                              extension->id(),
+                              &error);
+        if (error.empty()) {
+          valid = !(PermissionMessageProvider::Get()->IsPrivilegeIncrease(
+              dummy_extension->permissions_data()->active_permissions(),
+              extension->permissions_data()->active_permissions(),
+              extension->GetType()));
+        }
+      }
+    }
+
+    if (!valid)
+      return CrxInstallError(
+          CrxInstallErrorType::OTHER, CrxInstallErrorDetail::MANIFEST_INVALID,
+          l10n_util::GetStringUTF16(IDS_EXTENSION_MANIFEST_INVALID));
+  }
+
+  // The checks below are skipped for themes, external installs, and bookmark
+  // apps.
+  // TODO(pamg): After ManagementPolicy refactoring is complete, remove this
+  // and other uses of install_source_ that are no longer needed now that the
+  // SandboxedUnpacker sets extension->location.
+  if (extension->is_theme() || extension->from_bookmark() ||
+      Manifest::IsExternalLocation(install_source_)) {
+    return base::nullopt;
+  }
+
+  if (!extensions_enabled_) {
+    return CrxInstallError(
+        CrxInstallErrorType::DECLINED,
+        CrxInstallErrorDetail::INSTALL_NOT_ENABLED,
+        l10n_util::GetStringUTF16(IDS_EXTENSION_INSTALL_NOT_ENABLED));
+  }
+
+  if (install_cause_ == extension_misc::INSTALL_CAUSE_USER_DOWNLOAD &&
+      !is_gallery_install() &&
+      off_store_install_allow_reason_ == OffStoreInstallDisallowed) {
+    // Don't delete source in this case so that the user can install
+    // manually if they want.
+    delete_source_ = false;
+    did_handle_successfully_ = false;
+
+    return CrxInstallError(
+        CrxInstallErrorType::OTHER,
+        CrxInstallErrorDetail::OFFSTORE_INSTALL_DISALLOWED,
+        l10n_util::GetStringUTF16(IDS_EXTENSION_INSTALL_DISALLOWED_ON_SITE));
+  }
+
+  if (extension_->is_app()) {
+    // If the app was downloaded, apps_require_extension_mime_type_
+    // will be set.  In this case, check that it was served with the
+    // right mime type.  Make an exception for file URLs, which come
+    // from the users computer and have no headers.
+    if (!download_url_.SchemeIsFile() &&
+        apps_require_extension_mime_type_ &&
+        original_mime_type_ != Extension::kMimeType) {
+      return CrxInstallError(
+          CrxInstallErrorType::OTHER,
+          CrxInstallErrorDetail::INCORRECT_APP_CONTENT_TYPE,
+          l10n_util::GetStringFUTF16(
+              IDS_EXTENSION_INSTALL_INCORRECT_APP_CONTENT_TYPE,
+              base::ASCIIToUTF16(Extension::kMimeType)));
+    }
+
+    // If the client_ is NULL, then the app is either being installed via
+    // an internal mechanism like sync, external_extensions, or default apps.
+    // In that case, we don't want to enforce things like the install origin.
+    if (!is_gallery_install() && client_) {
+      // For apps with a gallery update URL, require that they be installed
+      // from the gallery.
+      // TODO(erikkay) Apply this rule for paid extensions and themes as well.
+      if (ManifestURL::UpdatesFromGallery(extension)) {
+        return CrxInstallError(
+            CrxInstallErrorType::OTHER,
+            CrxInstallErrorDetail::NOT_INSTALLED_FROM_GALLERY,
+            l10n_util::GetStringFUTF16(
+                IDS_EXTENSION_INSTALL_GALLERY_ONLY,
+                l10n_util::GetStringUTF16(IDS_EXTENSION_WEB_STORE_TITLE)));
+      }
+
+      // For self-hosted apps, verify that the entire extent is on the same
+      // host (or a subdomain of the host) the download happened from.  There's
+      // no way for us to verify that the app controls any other hosts.
+      URLPattern pattern(UserScript::ValidUserScriptSchemes());
+      pattern.SetHost(download_url_.host());
+      pattern.SetMatchSubdomains(true);
+
+      const URLPatternSet& patterns = extension_->web_extent();
+      for (auto i = patterns.begin(); i != patterns.end(); ++i) {
+        if (!pattern.MatchesHost(i->host())) {
+          return CrxInstallError(
+              CrxInstallErrorType::OTHER,
+              CrxInstallErrorDetail::INCORRECT_INSTALL_HOST,
+              l10n_util::GetStringUTF16(
+                  IDS_EXTENSION_INSTALL_INCORRECT_INSTALL_HOST));
+        }
+      }
+    }
+  }
+
+  return base::nullopt;
+}
+
+void CrxInstaller::ShouldComputeHashesOnUI(
+    scoped_refptr<const Extension> extension,
+    base::OnceCallback<void(bool)> callback) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  extensions::ContentVerifier* content_verifier =
+      extensions::ExtensionSystem::Get(profile_)->content_verifier();
+  bool result = content_verifier &&
+                content_verifier->ShouldComputeHashesOnInstall(*extension);
+  GetUnpackerTaskRunner()->PostTask(
+      FROM_HERE, base::BindOnce(std::move(callback), result));
+}
+
+void CrxInstaller::ShouldComputeHashesForOffWebstoreExtension(
+    scoped_refptr<const Extension> extension,
+    base::OnceCallback<void(bool)> callback) {
+  DCHECK(GetUnpackerTaskRunner()->RunsTasksInCurrentSequence());
+  if (!content::GetUIThreadTaskRunner({})->PostTask(
+          FROM_HERE,
+          base::BindOnce(&CrxInstaller::ShouldComputeHashesOnUI, this,
+                         std::move(extension), std::move(callback)))) {
+    NOTREACHED();
+  }
+}
+
+void CrxInstaller::OnUnpackFailure(const CrxInstallError& error) {
+  DCHECK(GetUnpackerTaskRunner()->RunsTasksInCurrentSequence());
+  if (!content::GetUIThreadTaskRunner({})->PostTask(
+          FROM_HERE, base::BindOnce(&CrxInstaller::ReportFailureFromUIThread,
+                                    this, error))) {
+    NOTREACHED();
+  }
+}
+
+void CrxInstaller::OnUnpackSuccess(
+    const base::FilePath& temp_dir,
+    const base::FilePath& extension_dir,
+    std::unique_ptr<base::DictionaryValue> original_manifest,
+    const Extension* extension,
+    const SkBitmap& install_icon,
+    declarative_net_request::RulesetInstallPrefs ruleset_install_prefs) {
+  DCHECK(GetUnpackerTaskRunner()->RunsTasksInCurrentSequence());
+  shared_file_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&CrxInstaller::OnUnpackSuccessOnSharedFileThread, this,
+                     temp_dir, extension_dir, std::move(original_manifest),
+                     scoped_refptr<const Extension>(extension), install_icon,
+                     std::move(ruleset_install_prefs)));
+}
+
+void CrxInstaller::OnUnpackSuccessOnSharedFileThread(
+    base::FilePath temp_dir,
+    base::FilePath extension_dir,
+    std::unique_ptr<base::DictionaryValue> original_manifest,
+    scoped_refptr<const Extension> extension,
+    SkBitmap install_icon,
+    declarative_net_request::RulesetInstallPrefs ruleset_install_prefs) {
+  DCHECK(shared_file_task_runner_->RunsTasksInCurrentSequence());
+
+  extension_ = extension;
+  temp_dir_ = temp_dir;
+  ruleset_install_prefs_ = std::move(ruleset_install_prefs);
+  ReportInstallationStage(InstallationStage::kCheckingExpectations);
+
+  if (!install_icon.empty())
+    install_icon_ = std::make_unique<SkBitmap>(install_icon);
+
+  if (original_manifest) {
+    original_manifest_ = std::make_unique<Manifest>(
+        Manifest::INVALID_LOCATION, std::move(original_manifest));
+  }
+
+  // We don't have to delete the unpack dir explicity since it is a child of
+  // the temp dir.
+  unpacked_extension_root_ = extension_dir;
+
+  // Check whether the crx matches the set expectations.
+  base::Optional<CrxInstallError> expectations_error =
+      CheckExpectations(extension.get());
+  if (expectations_error) {
+    DCHECK_NE(CrxInstallErrorType::NONE, expectations_error->type());
+    ReportFailureFromSharedFileThread(*expectations_error);
+    return;
+  }
+
+  // The |expectations_error| could be non-null in case of version mismatch if
+  // |fail_install_if_unexpected_version_| is set to false.
+  // If |expectations_passed_callback_| is set, the installer owns the crx file,
+  // and there is no version mismatch, invoke the callback and transfer the
+  // ownership. The responsibility to delete the crx file now lies with the
+  // callback.
+  if (!expectations_verified_callback_.is_null() && delete_source_ &&
+      (!expected_version_.IsValid() ||
+       expected_version_ == extension->version())) {
+    delete_source_ = false;
+    if (!content::GetUIThreadTaskRunner({})->PostTask(
+            FROM_HERE,
+            base::BindOnce(std::move(expectations_verified_callback_)))) {
+      NOTREACHED();
+    }
+  }
+
+  base::Optional<CrxInstallError> error = AllowInstall(extension.get());
+  if (error) {
+    DCHECK_NE(CrxInstallErrorType::NONE, error->type());
+    ReportFailureFromSharedFileThread(*error);
+    return;
+  }
+
+  if (!content::GetUIThreadTaskRunner({})->PostTask(
+          FROM_HERE, base::BindOnce(&CrxInstaller::CheckInstall, this)))
+    NOTREACHED();
+}
+
+void CrxInstaller::OnStageChanged(InstallationStage stage) {
+  ReportInstallationStage(stage);
+}
+
+void CrxInstaller::CheckInstall() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  ExtensionService* service = service_weak_.get();
+  if (!service || service->browser_terminating())
+    return;
+
+  // TODO(crbug.com/420147): Move this code to a utility class to avoid
+  // duplication of SharedModuleService::CheckImports code.
+  if (SharedModuleInfo::ImportsModules(extension())) {
+    const std::vector<SharedModuleInfo::ImportInfo>& imports =
+        SharedModuleInfo::GetImports(extension());
+    ExtensionRegistry* registry = ExtensionRegistry::Get(service->profile());
+    for (const auto& import : imports) {
+      const Extension* imported_module = registry->GetExtensionById(
+          import.extension_id, ExtensionRegistry::EVERYTHING);
+      if (!imported_module)
+        continue;
+
+      if (!SharedModuleInfo::IsSharedModule(imported_module)) {
+        ReportFailureFromUIThread(CrxInstallError(
+            CrxInstallErrorType::DECLINED,
+            CrxInstallErrorDetail::DEPENDENCY_NOT_SHARED_MODULE,
+            l10n_util::GetStringFUTF16(
+                IDS_EXTENSION_INSTALL_DEPENDENCY_NOT_SHARED_MODULE,
+                base::UTF8ToUTF16(imported_module->name()))));
+        return;
+      }
+      base::Version version_required(import.minimum_version);
+      if (version_required.IsValid() &&
+          imported_module->version().CompareTo(version_required) < 0) {
+        ReportFailureFromUIThread(CrxInstallError(
+            CrxInstallErrorType::DECLINED,
+            CrxInstallErrorDetail::DEPENDENCY_OLD_VERSION,
+            l10n_util::GetStringFUTF16(
+                IDS_EXTENSION_INSTALL_DEPENDENCY_OLD_VERSION,
+                base::UTF8ToUTF16(imported_module->name()),
+                base::ASCIIToUTF16(import.minimum_version),
+                base::ASCIIToUTF16(imported_module->version().GetString()))));
+        return;
+      }
+      if (!SharedModuleInfo::IsExportAllowedByAllowlist(imported_module,
+                                                        extension()->id())) {
+        ReportFailureFromUIThread(CrxInstallError(
+            CrxInstallErrorType::DECLINED,
+            CrxInstallErrorDetail::DEPENDENCY_NOT_ALLOWLISTED,
+            l10n_util::GetStringFUTF16(
+                IDS_EXTENSION_INSTALL_DEPENDENCY_NOT_ALLOWLISTED,
+                base::UTF8ToUTF16(extension()->name()),
+                base::UTF8ToUTF16(imported_module->name()))));
+        return;
+      }
+    }
+  }
+
+  // Skip the checks if the extension is a bookmark app.
+  if (extension()->from_bookmark()) {
+    ConfirmInstall();
+    return;
+  }
+
+  // Run the policy, requirements and blocklist checks in parallel.
+  check_group_ = std::make_unique<PreloadCheckGroup>();
+
+  policy_check_ = std::make_unique<PolicyCheck>(profile_, extension());
+  requirements_check_ = std::make_unique<RequirementsChecker>(extension());
+  blocklist_check_ =
+      std::make_unique<BlocklistCheck>(Blocklist::Get(profile_), extension_);
+
+  check_group_->AddCheck(policy_check_.get());
+  check_group_->AddCheck(requirements_check_.get());
+  check_group_->AddCheck(blocklist_check_.get());
+
+  check_group_->Start(
+      base::BindOnce(&CrxInstaller::OnInstallChecksComplete, this));
+}
+
+void CrxInstaller::OnInstallChecksComplete(const PreloadCheck::Errors& errors) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  if (!service_weak_)
+    return;
+
+  if (errors.empty()) {
+    ConfirmInstall();
+    return;
+  }
+
+  // Check for requirement errors.
+  if (!requirements_check_->GetErrorMessage().empty()) {
+    if (error_on_unsupported_requirements_) {
+      ReportFailureFromUIThread(
+          CrxInstallError(CrxInstallErrorType::DECLINED,
+                          CrxInstallErrorDetail::UNSUPPORTED_REQUIREMENTS,
+                          requirements_check_->GetErrorMessage()));
+      return;
+    }
+    install_flags_ |= kInstallFlagHasRequirementErrors;
+  }
+
+  // Check the blocklist state.
+  if (errors.count(PreloadCheck::BLOCKLISTED_ID) ||
+      errors.count(PreloadCheck::BLOCKLISTED_UNKNOWN)) {
+    if (allow_silent_install_) {
+      // NOTE: extension may still be blocklisted, but we're forced to silently
+      // install it. In this case, ExtensionService::OnExtensionInstalled needs
+      // to deal with it.
+      if (errors.count(PreloadCheck::BLOCKLISTED_ID))
+        install_flags_ |= kInstallFlagIsBlocklistedForMalware;
+    } else {
+      // User tried to install a blocklisted extension. Show an error and
+      // refuse to install it.
+      ReportFailureFromUIThread(CrxInstallError(
+          CrxInstallErrorType::DECLINED,
+          CrxInstallErrorDetail::EXTENSION_IS_BLOCKLISTED,
+          l10n_util::GetStringFUTF16(IDS_EXTENSION_IS_BLOCKLISTED,
+                                     base::UTF8ToUTF16(extension()->name()))));
+      UMA_HISTOGRAM_ENUMERATION("ExtensionBlacklist.BlockCRX",
+                                extension()->location(),
+                                Manifest::NUM_LOCATIONS);
+      return;
+    }
+  }
+
+  // Check for policy errors.
+  if (errors.count(PreloadCheck::DISALLOWED_BY_POLICY)) {
+    // We don't want to show the error infobar for installs from the WebStore,
+    // because the WebStore already shows an error dialog itself.
+    // Note: |client_| can be NULL in unit_tests!
+    if (extension()->from_webstore() && client_)
+      client_->install_ui()->SetSkipPostInstallUI(true);
+
+    ReportFailureFromUIThread(
+        CrxInstallError(CrxInstallErrorType::DECLINED,
+                        CrxInstallErrorDetail::DISALLOWED_BY_POLICY,
+                        policy_check_->GetErrorMessage()));
+    return;
+  }
+
+  ConfirmInstall();
+}
+
+void CrxInstaller::ConfirmInstall() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  ReportInstallationStage(InstallationStage::kFinalizing);
+  ExtensionService* service = service_weak_.get();
+  if (!service || service->browser_terminating())
+    return;
+
+  if (KioskModeInfo::IsKioskOnly(extension())) {
+    bool in_kiosk_mode = false;
+#if defined(OS_CHROMEOS)
+    user_manager::UserManager* user_manager = user_manager::UserManager::Get();
+    in_kiosk_mode = user_manager && user_manager->IsLoggedInAsKioskApp();
+#endif
+    if (!in_kiosk_mode) {
+      ReportFailureFromUIThread(CrxInstallError(
+          CrxInstallErrorType::DECLINED, CrxInstallErrorDetail::KIOSK_MODE_ONLY,
+          l10n_util::GetStringUTF16(IDS_EXTENSION_INSTALL_KIOSK_MODE_ONLY)));
+      return;
+    }
+  }
+
+  // Check whether this install is initiated from the settings page to
+  // update an existing extension or app.
+  CheckUpdateFromSettingsPage();
+
+  GURL overlapping_url;
+  ExtensionRegistry* registry = ExtensionRegistry::Get(service->profile());
+  const Extension* overlapping_extension =
+      registry->enabled_extensions().GetHostedAppByOverlappingWebExtent(
+          extension()->web_extent());
+  if (overlapping_extension &&
+      overlapping_extension->id() != extension()->id()) {
+    ReportFailureFromUIThread(
+        CrxInstallError(CrxInstallErrorType::OTHER,
+                        CrxInstallErrorDetail::OVERLAPPING_WEB_EXTENT,
+                        l10n_util::GetStringFUTF16(
+                            IDS_EXTENSION_OVERLAPPING_WEB_EXTENT,
+                            base::UTF8ToUTF16(extension()->name()),
+                            base::UTF8ToUTF16(overlapping_extension->name()))));
+    return;
+  }
+
+  current_version_ = base::Version(ExtensionPrefs::Get(service->profile())
+                         ->GetVersionString(extension()->id()));
+
+  if (client_ &&
+      (!allow_silent_install_ || !approved_) &&
+      !update_from_settings_page_) {
+    AddRef();  // Balanced in OnInstallPromptDone().
+    client_->ShowDialog(base::Bind(&CrxInstaller::OnInstallPromptDone, this),
+                        extension(), nullptr, show_dialog_callback_);
+  } else {
+    UpdateCreationFlagsAndCompleteInstall(kDontWithholdPermissions);
+  }
+}
+
+void CrxInstaller::OnInstallPromptDone(ExtensionInstallPrompt::Result result) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  // If update_from_settings_page_ boolean is true, this functions is
+  // getting called in response to ExtensionInstallPrompt::ConfirmReEnable()
+  // and if it is false, this function is called in response to
+  // ExtensionInstallPrompt::ShowDialog().
+
+  ExtensionService* service = service_weak_.get();
+  switch (result) {
+    case ExtensionInstallPrompt::Result::ACCEPTED:
+      if (!service || service->browser_terminating())
+        return;
+
+      // Install (or re-enable) the extension with full permissions.
+      if (update_from_settings_page_)
+        service->GrantPermissionsAndEnableExtension(extension());
+      else
+        UpdateCreationFlagsAndCompleteInstall(kDontWithholdPermissions);
+      break;
+    case ExtensionInstallPrompt::Result::ACCEPTED_AND_OPTION_CHECKED:
+      if (!service || service->browser_terminating())
+        return;
+
+      // TODO(tjudkins): Add support for withholding permissions on the
+      // re-enable prompt here once we know how that should be handled.
+      DCHECK(!update_from_settings_page_);
+      // Install the extension with permissions withheld.
+      UpdateCreationFlagsAndCompleteInstall(kWithholdPermissions);
+      break;
+    case ExtensionInstallPrompt::Result::USER_CANCELED:
+      if (!update_from_settings_page_) {
+        ExtensionService::RecordPermissionMessagesHistogram(extension(),
+                                                            "InstallCancel");
+        NotifyCrxInstallComplete(CrxInstallError(
+            CrxInstallErrorType::OTHER, CrxInstallErrorDetail::USER_CANCELED));
+      }
+      break;
+    case ExtensionInstallPrompt::Result::ABORTED:
+      if (!update_from_settings_page_) {
+        ExtensionService::RecordPermissionMessagesHistogram(extension(),
+                                                            "InstallAbort");
+        NotifyCrxInstallComplete(CrxInstallError(
+            CrxInstallErrorType::OTHER, CrxInstallErrorDetail::USER_ABORTED));
+      }
+      break;
+  }
+
+  Release();  // balanced in ConfirmInstall() or ConfirmReEnable().
+}
+
+void CrxInstaller::InitializeCreationFlagsForUpdate(const Extension* extension,
+                                                    const int initial_flags) {
+  DCHECK(extension);
+
+  creation_flags_ = initial_flags;
+
+  // If the extension was installed from or has migrated to the webstore, or
+  // its auto-update URL is from the webstore, treat it as a webstore install.
+  // Note that we ignore some older extensions with blank auto-update URLs
+  // because we are mostly concerned with restrictions on NaCl extensions,
+  // which are newer.
+  if (extension->from_webstore() || ManifestURL::UpdatesFromGallery(extension))
+    creation_flags_ |= Extension::FROM_WEBSTORE;
+
+  // Bookmark apps being updated is kind of a contradiction, but that's because
+  // we mark the default apps as bookmark apps, and they're hosted in the web
+  // store, thus they can get updated. See http://crbug.com/101605 for more
+  // details.
+  if (extension->from_bookmark())
+    creation_flags_ |= Extension::FROM_BOOKMARK;
+
+  if (extension->was_installed_by_default())
+    creation_flags_ |= Extension::WAS_INSTALLED_BY_DEFAULT;
+
+  if (extension->was_installed_by_oem())
+    creation_flags_ |= Extension::WAS_INSTALLED_BY_OEM;
+}
+
+void CrxInstaller::UpdateCreationFlagsAndCompleteInstall(
+    WithholdingBehavior withholding_behavior) {
+  creation_flags_ = extension()->creation_flags() | Extension::REQUIRE_KEY;
+  // If the extension was already installed and had file access, also grant file
+  // access to the updated extension.
+  if (ExtensionPrefs::Get(profile())->AllowFileAccess(extension()->id()))
+    creation_flags_ |= Extension::ALLOW_FILE_ACCESS;
+
+  if (withholding_behavior == kWithholdPermissions)
+    creation_flags_ |= Extension::WITHHOLD_PERMISSIONS;
+
+  if (!shared_file_task_runner_->PostTask(
+          FROM_HERE, base::BindOnce(&CrxInstaller::CompleteInstall, this))) {
+    NOTREACHED();
+  }
+}
+
+void CrxInstaller::CompleteInstall() {
+  DCHECK(shared_file_task_runner_->RunsTasksInCurrentSequence());
+
+  if (current_version_.IsValid() &&
+      current_version_.CompareTo(extension()->version()) > 0) {
+    ReportFailureFromSharedFileThread(CrxInstallError(
+        CrxInstallErrorType::DECLINED,
+        CrxInstallErrorDetail::CANT_DOWNGRADE_VERSION,
+        l10n_util::GetStringUTF16(extension()->is_app()
+                                      ? IDS_APP_CANT_DOWNGRADE_VERSION
+                                      : IDS_EXTENSION_CANT_DOWNGRADE_VERSION)));
+    return;
+  }
+
+  ExtensionAssetsManager* assets_manager =
+      ExtensionAssetsManager::GetInstance();
+  assets_manager->InstallExtension(
+      extension(),
+      unpacked_extension_root_,
+      install_directory_,
+      profile(),
+      base::Bind(&CrxInstaller::ReloadExtensionAfterInstall, this));
+}
+
+void CrxInstaller::ReloadExtensionAfterInstall(
+    const base::FilePath& version_dir) {
+  DCHECK(shared_file_task_runner_->RunsTasksInCurrentSequence());
+
+  if (version_dir.empty()) {
+    ReportFailureFromSharedFileThread(
+        CrxInstallError(CrxInstallErrorType::OTHER,
+                        CrxInstallErrorDetail::MOVE_DIRECTORY_TO_PROFILE_FAILED,
+                        l10n_util::GetStringUTF16(
+                            IDS_EXTENSION_MOVE_DIRECTORY_TO_PROFILE_FAILED)));
+    return;
+  }
+
+  // This is lame, but we must reload the extension because absolute paths
+  // inside the content scripts are established inside InitFromValue() and we
+  // just moved the extension.
+  // TODO(aa): All paths to resources inside extensions should be created
+  // lazily and based on the Extension's root path at that moment.
+  // TODO(rdevlin.cronin): Continue removing std::string errors and replacing
+  // with base::string16
+  std::string extension_id = extension()->id();
+  std::string error;
+  extension_ = file_util::LoadExtension(
+      version_dir, install_source_,
+      // Note: modified by UpdateCreationFlagsAndCompleteInstall.
+      creation_flags_, &error);
+
+  if (extension()) {
+    ReportSuccessFromSharedFileThread();
+  } else {
+    LOG(ERROR) << error << " " << extension_id << " " << download_url_;
+    ReportFailureFromSharedFileThread(CrxInstallError(
+        CrxInstallErrorType::OTHER, CrxInstallErrorDetail::CANT_LOAD_EXTENSION,
+        base::UTF8ToUTF16(error)));
+  }
+}
+
+void CrxInstaller::ReportFailureFromSharedFileThread(
+    const CrxInstallError& error) {
+  DCHECK(shared_file_task_runner_->RunsTasksInCurrentSequence());
+  if (!content::GetUIThreadTaskRunner({})->PostTask(
+          FROM_HERE, base::BindOnce(&CrxInstaller::ReportFailureFromUIThread,
+                                    this, error))) {
+    NOTREACHED();
+  }
+}
+
+void CrxInstaller::ReportFailureFromUIThread(const CrxInstallError& error) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  DCHECK_NE(CrxInstallErrorType::NONE, error.type());
+
+  if (!service_weak_.get() || service_weak_->browser_terminating())
+    return;
+
+  content::NotificationService* service =
+      content::NotificationService::current();
+  service->Notify(NOTIFICATION_EXTENSION_INSTALL_ERROR,
+                  content::Source<CrxInstaller>(this),
+                  content::Details<const CrxInstallError>(&error));
+
+  // This isn't really necessary, it is only used because unit tests expect to
+  // see errors get reported via this interface.
+  //
+  // TODO(aa): Need to go through unit tests and clean them up too, probably get
+  // rid of this line.
+  LoadErrorReporter::GetInstance()->ReportError(error.message(),
+                                                false);  // Be quiet.
+
+  if (client_)
+    client_->OnInstallFailure(error);
+
+  NotifyCrxInstallComplete(error);
+
+  // Delete temporary files.
+  CleanupTempFiles();
+}
+
+void CrxInstaller::ReportSuccessFromSharedFileThread() {
+  DCHECK(shared_file_task_runner_->RunsTasksInCurrentSequence());
+
+  // Tracking number of extensions installed by users
+  if (install_cause() == extension_misc::INSTALL_CAUSE_USER_DOWNLOAD)
+    UMA_HISTOGRAM_ENUMERATION("Extensions.ExtensionInstalled", 1, 2);
+
+  if (!content::GetUIThreadTaskRunner({})->PostTask(
+          FROM_HERE,
+          base::BindOnce(&CrxInstaller::ReportSuccessFromUIThread, this)))
+    NOTREACHED();
+
+  // Delete temporary files.
+  CleanupTempFiles();
+}
+
+void CrxInstaller::ReportSuccessFromUIThread() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  if (!service_weak_.get() || service_weak_->browser_terminating())
+    return;
+
+  extension()->permissions_data()->BindToCurrentThread();
+
+  if (!update_from_settings_page_) {
+    // If there is a client, tell the client about installation.
+    if (client_)
+      client_->OnInstallSuccess(extension_, install_icon_.get());
+
+    // We update the extension's granted permissions if the user already
+    // approved the install (client_ is non NULL), or we are allowed to install
+    // this silently.
+    if ((client_ || allow_silent_install_) && grant_permissions_ &&
+        (!expected_version_.IsValid() ||
+         expected_version_ == extension()->version())) {
+      PermissionsUpdater perms_updater(profile());
+      perms_updater.InitializePermissions(extension());
+      perms_updater.GrantActivePermissions(extension());
+    }
+  }
+
+  service_weak_->OnExtensionInstalled(extension(), page_ordinal_,
+                                      install_flags_, ruleset_install_prefs_);
+  NotifyCrxInstallComplete(base::nullopt);
+}
+
+void CrxInstaller::ReportInstallationStage(InstallationStage stage) {
+  if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {
+    DCHECK(GetUnpackerTaskRunner()->RunsTasksInCurrentSequence() ||
+           shared_file_task_runner_->RunsTasksInCurrentSequence());
+    if (!content::GetUIThreadTaskRunner({})->PostTask(
+            FROM_HERE, base::BindOnce(&CrxInstaller::ReportInstallationStage,
+                                      this, stage))) {
+      NOTREACHED();
+    }
+    return;
+  }
+
+  if (!service_weak_.get() || service_weak_->browser_terminating())
+    return;
+  // In case of force installed extensions, expected_id_ should always be set.
+  // We do not want to report in case of other extensions.
+  if (expected_id_.empty())
+    return;
+  InstallStageTracker* install_stage_tracker =
+      InstallStageTracker::Get(profile_);
+  install_stage_tracker->ReportCRXInstallationStage(expected_id_, stage);
+}
+
+void CrxInstaller::NotifyCrxInstallBegin() {
+  InstallTrackerFactory::GetForBrowserContext(profile())
+      ->OnBeginCrxInstall(expected_id_);
+}
+
+void CrxInstaller::NotifyCrxInstallComplete(
+    const base::Optional<CrxInstallError>& error) {
+  ReportInstallationStage(InstallationStage::kComplete);
+  const std::string extension_id =
+      expected_id_.empty() && extension() ? extension()->id() : expected_id_;
+  InstallStageTracker* install_stage_tracker =
+      InstallStageTracker::Get(profile_);
+  install_stage_tracker->ReportInstallationStage(
+      extension_id, InstallStageTracker::Stage::COMPLETE);
+  const bool success = !error.has_value();
+
+  if (extension()) {
+    install_stage_tracker->ReportExtensionType(extension_id,
+                                               extension()->GetType());
+  }
+
+  if (!success && (!expected_id_.empty() || extension())) {
+    switch (error->type()) {
+      case CrxInstallErrorType::DECLINED:
+        install_stage_tracker->ReportCrxInstallError(
+            extension_id,
+            InstallStageTracker::FailureReason::CRX_INSTALL_ERROR_DECLINED,
+            error->detail());
+        break;
+      case CrxInstallErrorType::SANDBOXED_UNPACKER_FAILURE:
+        install_stage_tracker->ReportSandboxedUnpackerFailureReason(
+            extension_id, error->sandbox_failure_detail());
+        break;
+      case CrxInstallErrorType::OTHER:
+        install_stage_tracker->ReportCrxInstallError(
+            extension_id,
+            InstallStageTracker::FailureReason::CRX_INSTALL_ERROR_OTHER,
+            error->detail());
+        break;
+      case CrxInstallErrorType::NONE:
+        NOTREACHED();
+        break;
+    }
+  }
+
+  // Some users (such as the download shelf) need to know when a
+  // CRXInstaller is done.  Listening for the EXTENSION_* events
+  // is problematic because they don't know anything about the
+  // extension before it is unpacked, so they cannot filter based
+  // on the extension.
+  content::NotificationService::current()->Notify(
+      NOTIFICATION_CRX_INSTALLER_DONE, content::Source<CrxInstaller>(this),
+      content::Details<const Extension>(success ? extension() : NULL));
+
+  InstallTrackerFactory::GetForBrowserContext(profile())
+      ->OnFinishCrxInstall(success ? extension()->id() : expected_id_, success);
+
+  if (success)
+    ConfirmReEnable();
+
+  if (!installer_callback_.is_null() &&
+      !content::GetUIThreadTaskRunner({})->PostTask(
+          FROM_HERE, base::BindOnce(std::move(installer_callback_), error))) {
+    NOTREACHED();
+  }
+}
+
+void CrxInstaller::CleanupTempFiles() {
+  if (!shared_file_task_runner_->RunsTasksInCurrentSequence()) {
+    if (!shared_file_task_runner_->PostTask(
+            FROM_HERE, base::BindOnce(&CrxInstaller::CleanupTempFiles, this))) {
+      NOTREACHED();
+    }
+    return;
+  }
+
+  // Delete the temp directory and crx file as necessary.
+  if (!temp_dir_.value().empty()) {
+    base::DeletePathRecursively(temp_dir_);
+    temp_dir_ = base::FilePath();
+  }
+
+  if (delete_source_ && !source_file_.value().empty()) {
+    base::DeleteFile(source_file_);
+    source_file_ = base::FilePath();
+  }
+}
+
+void CrxInstaller::CheckUpdateFromSettingsPage() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  ExtensionService* service = service_weak_.get();
+  if (!service || service->browser_terminating())
+    return;
+
+  if (off_store_install_allow_reason_ != OffStoreInstallAllowedFromSettingsPage)
+    return;
+
+  const Extension* installed_extension =
+      ExtensionRegistry::Get(service->profile())
+          ->GetInstalledExtension(extension()->id());
+  if (installed_extension) {
+    // Previous version of the extension exists.
+    update_from_settings_page_ = true;
+    expected_id_ = installed_extension->id();
+    install_source_ = installed_extension->location();
+    install_cause_ = extension_misc::INSTALL_CAUSE_UPDATE;
+  }
+}
+
+void CrxInstaller::ConfirmReEnable() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  ExtensionService* service = service_weak_.get();
+  if (!service || service->browser_terminating())
+    return;
+
+  if (!update_from_settings_page_)
+    return;
+
+  ExtensionPrefs* prefs = ExtensionPrefs::Get(service->profile());
+  if (!prefs->DidExtensionEscalatePermissions(extension()->id()))
+    return;
+
+  if (client_) {
+    AddRef();  // Balanced in OnInstallPromptDone().
+    ExtensionInstallPrompt::PromptType type =
+        ExtensionInstallPrompt::GetReEnablePromptTypeForExtension(
+            service->profile(), extension());
+    client_->ShowDialog(base::Bind(&CrxInstaller::OnInstallPromptDone, this),
+                        extension(), nullptr,
+                        std::make_unique<ExtensionInstallPrompt::Prompt>(type),
+                        ExtensionInstallPrompt::GetDefaultShowDialogCallback());
+  }
+}
+
+base::SequencedTaskRunner* CrxInstaller::GetUnpackerTaskRunner() {
+  if (!unpacker_task_runner_) {
+    bool low_priority =
+        (creation_flags_ & Extension::WAS_INSTALLED_BY_DEFAULT) &&
+        !(creation_flags_ & Extension::WAS_INSTALLED_BY_OEM);
+    unpacker_task_runner_ = GetOneShotFileTaskRunner(
+        low_priority ? base::TaskPriority::BEST_EFFORT
+                     : base::TaskPriority::USER_VISIBLE);
+  }
+  return unpacker_task_runner_.get();
+}
+
+void CrxInstaller::set_installer_callback(InstallerResultCallback callback) {
+  installer_callback_ = std::move(callback);
+}
+
+void CrxInstaller::set_expectations_verified_callback(
+    ExpectationsVerifiedCallback callback) {
+  expectations_verified_callback_ = std::move(callback);
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/browser/na/crx_installer.h b/components/user_scripts/browser/na/crx_installer.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/browser/na/crx_installer.h
@@ -0,0 +1,548 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CHROME_BROWSER_EXTENSIONS_CRX_INSTALLER_H_
+#define CHROME_BROWSER_EXTENSIONS_CRX_INSTALLER_H_
+
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/compiler_specific.h"
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "base/optional.h"
+#include "base/version.h"
+#include "chrome/browser/extensions/extension_install_prompt.h"
+#include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/extensions/webstore_installer.h"
+#include "chrome/common/extensions/extension_constants.h"
+#include "components/sync/model/string_ordinal.h"
+#include "extensions/browser/api/declarative_net_request/ruleset_install_pref.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/install_flag.h"
+#include "extensions/browser/preload_check.h"
+#include "extensions/browser/sandboxed_unpacker.h"
+#include "extensions/common/extension.h"
+#include "extensions/common/manifest.h"
+
+class ExtensionServiceTest;
+class SkBitmap;
+struct WebApplicationInfo;
+
+namespace base {
+class SequencedTaskRunner;
+}
+
+namespace extensions {
+class CrxInstallError;
+class ExtensionService;
+class ExtensionUpdaterTest;
+enum class InstallationStage;
+class PreloadCheckGroup;
+
+// This class installs a crx file into a profile.
+//
+// Installing a CRX is a multi-step process, including unpacking the crx,
+// validating it, prompting the user, and installing. Since many of these
+// steps must occur on the file thread, this class contains a copy of all data
+// necessary to do its job. (This also minimizes external dependencies for
+// easier testing).
+//
+// Lifetime management:
+//
+// This class is ref-counted by each call it makes to itself on another thread,
+// and by UtilityProcessHost.
+//
+// Additionally, we hold a reference to our own client so that it lives at least
+// long enough to receive the result of unpacking.
+//
+// IMPORTANT: Callers should keep a reference to a CrxInstaller while they are
+// working with it, eg:
+//
+// scoped_refptr<CrxInstaller> installer(new CrxInstaller(...));
+// installer->set_foo();
+// installer->set_bar();
+// installer->InstallCrx(...);
+//
+// Installation is aborted if the extension service learns that Chrome is
+// terminating during the install. We can't listen for the app termination
+// notification here in this class because it can be destroyed on any thread
+// and won't safely be able to clean up UI thread notification listeners.
+class CrxInstaller : public SandboxedUnpackerClient {
+ public:
+  // A callback to be executed when the install finishes.
+  using InstallerResultCallback = ExtensionSystem::InstallUpdateCallback;
+
+  using ExpectationsVerifiedCallback = base::OnceClosure;
+
+  // Used in histograms; do not change order.
+  enum OffStoreInstallAllowReason {
+    OffStoreInstallDisallowed,
+    OffStoreInstallAllowedFromSettingsPage,
+    OffStoreInstallAllowedBecausePref,
+    OffStoreInstallAllowedInTest,
+    NumOffStoreInstallAllowReasons
+  };
+
+  // Used to indicate if host permissions should be withheld during
+  // installation.
+  enum WithholdingBehavior { kWithholdPermissions, kDontWithholdPermissions };
+
+  // Extensions will be installed into service->install_directory(), then
+  // registered with |service|. This does a silent install - see below for
+  // other options.
+  static scoped_refptr<CrxInstaller> CreateSilent(ExtensionService* service);
+
+  // Same as above, but use |client| to generate a confirmation prompt.
+  static scoped_refptr<CrxInstaller> Create(
+      ExtensionService* service,
+      std::unique_ptr<ExtensionInstallPrompt> client);
+
+  // Same as the previous method, except use the |approval| to bypass the
+  // prompt. Note that the caller retains ownership of |approval|.
+  static scoped_refptr<CrxInstaller> Create(
+      ExtensionService* service,
+      std::unique_ptr<ExtensionInstallPrompt> client,
+      const WebstoreInstaller::Approval* approval);
+
+  // Install the crx in |source_file|. The file must be a CRX3. A publisher
+  // proof in the file is required unless off-webstore installation is allowed.
+  void InstallCrx(const base::FilePath& source_file);
+
+  // Install the crx in |source_file|.
+  void InstallCrxFile(const CRXFileInfo& source_file);
+
+  // Install the unpacked crx in |unpacked_dir|.
+  // If |delete_source_| is true, |unpacked_dir| will be removed at the end of
+  // the installation.
+  void InstallUnpackedCrx(const std::string& extension_id,
+                          const std::string& public_key,
+                          const base::FilePath& unpacked_dir);
+
+  // Convert the specified user script into an extension and install it.
+  void InstallUserScript(const base::FilePath& source_file,
+                         const GURL& download_url);
+
+  // Convert the specified web app into an extension and install it.
+  // Virtual for testing.
+  virtual void InstallWebApp(const WebApplicationInfo& web_app);
+
+  // Update the extension |extension_id| with the unpacked crx in
+  // |unpacked_dir|.
+  // If |delete_source_| is true, |unpacked_dir| will be removed at the end of
+  // the update.
+  void UpdateExtensionFromUnpackedCrx(const std::string& extension_id,
+                                      const std::string& public_key,
+                                      const base::FilePath& unpacked_dir);
+
+  void OnInstallPromptDone(ExtensionInstallPrompt::Result result);
+
+  void InitializeCreationFlagsForUpdate(const Extension* extension,
+                                        const int initial_flags);
+
+  int creation_flags() const { return creation_flags_; }
+  void set_creation_flags(int val) { creation_flags_ = val; }
+
+  const base::FilePath& source_file() const { return source_file_; }
+
+  Manifest::Location install_source() const {
+    return install_source_;
+  }
+  void set_install_source(Manifest::Location source) {
+    install_source_ = source;
+  }
+
+  const std::string& expected_id() const { return expected_id_; }
+  void set_expected_id(const std::string& val) { expected_id_ = val; }
+
+  // Expected SHA256 hash sum for the package.
+  const std::string& expected_hash() const { return expected_hash_; }
+  void set_expected_hash(const std::string& val) { expected_hash_ = val; }
+
+  bool verification_check_failed() const { return verification_check_failed_; }
+  void set_verification_check_failed(bool val) {
+    verification_check_failed_ = val;
+  }
+
+  // Set the exact version the installed extension should have. If
+  // |fail_install_if_unexpected| is true, installation will fail if the actual
+  // version doesn't match. If it is false, the installation will still
+  // be performed, but the extension will not be granted any permissions.
+  void set_expected_version(const base::Version& val,
+                            bool fail_install_if_unexpected) {
+    expected_version_ = val;
+    fail_install_if_unexpected_version_ = fail_install_if_unexpected;
+  }
+
+  bool delete_source() const { return delete_source_; }
+  void set_delete_source(bool val) { delete_source_ = val; }
+
+  bool allow_silent_install() const { return allow_silent_install_; }
+  void set_allow_silent_install(bool val) { allow_silent_install_ = val; }
+
+  bool grant_permissions() const { return grant_permissions_; }
+  void set_grant_permissions(bool val) { grant_permissions_ = val; }
+
+  bool is_gallery_install() const {
+    return (creation_flags_ & Extension::FROM_WEBSTORE) > 0;
+  }
+  void set_is_gallery_install(bool val) {
+    if (val)
+      creation_flags_ |= Extension::FROM_WEBSTORE;
+    else
+      creation_flags_ &= ~Extension::FROM_WEBSTORE;
+  }
+
+  // If |apps_require_extension_mime_type_| is set to true, be sure to set
+  // |original_mime_type_| as well.
+  void set_apps_require_extension_mime_type(
+      bool apps_require_extension_mime_type) {
+    apps_require_extension_mime_type_ = apps_require_extension_mime_type;
+  }
+
+  void set_original_mime_type(const std::string& original_mime_type) {
+    original_mime_type_ = original_mime_type;
+  }
+
+  extension_misc::CrxInstallCause install_cause() const {
+    return install_cause_;
+  }
+  void set_install_cause(extension_misc::CrxInstallCause install_cause) {
+    install_cause_ = install_cause;
+  }
+
+  OffStoreInstallAllowReason off_store_install_allow_reason() const {
+    return off_store_install_allow_reason_;
+  }
+  void set_off_store_install_allow_reason(OffStoreInstallAllowReason reason) {
+    off_store_install_allow_reason_ = reason;
+  }
+
+  void set_page_ordinal(const syncer::StringOrdinal& page_ordinal) {
+    page_ordinal_ = page_ordinal;
+  }
+
+  void set_error_on_unsupported_requirements(bool val) {
+    error_on_unsupported_requirements_ = val;
+  }
+
+  void set_install_immediately(bool val) {
+    set_install_flag(kInstallFlagInstallImmediately, val);
+  }
+  void set_do_not_sync(bool val) {
+    set_install_flag(kInstallFlagDoNotSync, val);
+  }
+
+  // Virtual for testing.
+  virtual void set_installer_callback(InstallerResultCallback callback);
+
+  // Callback to be invoked when the crx file has passed the expectations check
+  // after unpack success and the ownership of the crx file lies with the
+  // installer. The callback is passed the ownership of the crx file.
+  void set_expectations_verified_callback(
+      ExpectationsVerifiedCallback callback);
+
+  bool did_handle_successfully() const { return did_handle_successfully_; }
+
+  Profile* profile() { return profile_; }
+
+  const Extension* extension() { return extension_.get(); }
+
+  // The currently installed version of the extension, for updates. Will be
+  // invalid if this isn't an update.
+  const base::Version& current_version() const { return current_version_; }
+
+ private:
+  friend class ::ExtensionServiceTest;
+  friend class BookmarkAppInstallFinalizerTest;
+  friend class ExtensionUpdaterTest;
+
+  CrxInstaller(base::WeakPtr<ExtensionService> service_weak,
+               std::unique_ptr<ExtensionInstallPrompt> client,
+               const WebstoreInstaller::Approval* approval);
+  ~CrxInstaller() override;
+
+  // Converts the source user script to an extension.
+  void ConvertUserScriptOnSharedFileThread();
+
+  // Converts the source web app to an extension.
+  void ConvertWebAppOnSharedFileThread(const WebApplicationInfo& web_app);
+
+  // Called after OnUnpackSuccess check to see whether the install expectations
+  // are met and the install process should continue.
+  base::Optional<CrxInstallError> CheckExpectations(const Extension* extension);
+
+  // Called after OnUnpackSuccess as a last check to see whether the install
+  // should complete.
+  base::Optional<CrxInstallError> AllowInstall(const Extension* extension);
+
+  // To check whether we need to compute hashes or not, we have to make a query
+  // to ContentVerifier, and that should be done on the UI thread.
+  void ShouldComputeHashesOnUI(scoped_refptr<const Extension> extension,
+                               base::OnceCallback<void(bool)> callback);
+
+  // SandboxedUnpackerClient
+  void ShouldComputeHashesForOffWebstoreExtension(
+      scoped_refptr<const Extension> extension,
+      base::OnceCallback<void(bool)> callback) override;
+  void OnUnpackFailure(const CrxInstallError& error) override;
+  void OnUnpackSuccess(const base::FilePath& temp_dir,
+                       const base::FilePath& extension_dir,
+                       std::unique_ptr<base::DictionaryValue> original_manifest,
+                       const Extension* extension,
+                       const SkBitmap& install_icon,
+                       declarative_net_request::RulesetInstallPrefs
+                           ruleset_install_prefs) override;
+  void OnStageChanged(InstallationStage stage) override;
+
+  // Called on the UI thread to start the requirements, policy and blocklist
+  // checks on the extension.
+  void CheckInstall();
+
+  // Runs on the UI thread. Callback from PreloadCheckGroup.
+  void OnInstallChecksComplete(const PreloadCheck::Errors& errors);
+
+  // Runs on the UI thread. Confirms the installation to the ExtensionService.
+  void ConfirmInstall();
+
+  // Runs on the UI thread. Updates the creation flags for the extension and
+  // calls CompleteInstall().
+  void UpdateCreationFlagsAndCompleteInstall(
+      WithholdingBehavior withholding_behavior);
+
+  // Runs on File thread. Install the unpacked extension into the profile and
+  // notify the frontend.
+  void CompleteInstall();
+
+  // Reloads extension on File thread and reports installation result back
+  // to UI thread.
+  void ReloadExtensionAfterInstall(const base::FilePath& version_dir);
+
+  // Result reporting.
+  void ReportFailureFromSharedFileThread(const CrxInstallError& error);
+  void ReportFailureFromUIThread(const CrxInstallError& error);
+  void ReportSuccessFromSharedFileThread();
+  void ReportSuccessFromUIThread();
+  // Always report from the UI thread.
+  void ReportInstallationStage(InstallationStage stage);
+  void NotifyCrxInstallBegin();
+  void NotifyCrxInstallComplete(const base::Optional<CrxInstallError>& error);
+
+  // Deletes temporary directory and crx file if needed.
+  void CleanupTempFiles();
+
+  // Checks whether the current installation is initiated by the user from
+  // the extension settings page to update an existing extension or app.
+  void CheckUpdateFromSettingsPage();
+
+  // Show re-enable prompt if the update is initiated from the settings page
+  // and needs additional permissions.
+  void ConfirmReEnable();
+
+  // OnUnpackSuccess() gets called on the unpacker sequence. It calls this
+  // method on the shared file sequence, to avoid race conditions.
+  virtual void OnUnpackSuccessOnSharedFileThread(
+      base::FilePath temp_dir,
+      base::FilePath extension_dir,
+      std::unique_ptr<base::DictionaryValue> original_manifest,
+      scoped_refptr<const Extension> extension,
+      SkBitmap install_icon,
+      declarative_net_request::RulesetInstallPrefs ruleset_install_prefs);
+
+  void set_install_flag(int flag, bool val) {
+    if (val)
+      install_flags_ |= flag;
+    else
+      install_flags_ &= ~flag;
+  }
+
+  // Returns |unpacker_task_runner_|. Initializes it if it's still nullptr.
+  base::SequencedTaskRunner* GetUnpackerTaskRunner();
+
+  // The Profile the extension is being installed in.
+  Profile* profile_;
+
+  // The extension being installed.
+  scoped_refptr<const Extension> extension_;
+
+  // The file we're installing.
+  base::FilePath source_file_;
+
+  // The URL the file was downloaded from.
+  GURL download_url_;
+
+  // The directory extensions are installed to.
+  const base::FilePath install_directory_;
+
+  // The location the installation came from (bundled with Chromium, registry,
+  // manual install, etc). This metadata is saved with the installation if
+  // successful. Defaults to INTERNAL.
+  Manifest::Location install_source_;
+
+  // Indicates whether the user has already approved the extension to be
+  // installed. If true, |expected_manifest_| and |expected_id_| must match
+  // those of the CRX.
+  bool approved_;
+
+  // For updates, external and webstore installs we have an ID we're expecting
+  // the extension to contain.
+  std::string expected_id_;
+
+  // An expected hash sum for the .crx file.
+  std::string expected_hash_;
+
+  // True if installation failed due to a hash sum mismatch or expectations
+  // mismatch.
+  bool verification_check_failed_;
+
+  // A parsed copy of the expected manifest, before any transformations like
+  // localization have taken place. If |approved_| is true, then the
+  // extension's manifest must match this for the install to proceed.
+  std::unique_ptr<Manifest> expected_manifest_;
+
+  // The level of checking when comparing the actual manifest against
+  // the |expected_manifest_|.
+  WebstoreInstaller::ManifestCheckLevel expected_manifest_check_level_;
+
+  // If valid, specifies the minimum version we'll install. Installation will
+  // fail if the actual version is smaller.
+  base::Version minimum_version_;
+
+  // If valid, contains the expected version of the extension we're installing.
+  // Important for external sources, where claiming the wrong version could
+  // cause unnecessary unpacking of an extension at every restart.
+  // See also |fail_install_if_unexpected_version_|!
+  base::Version expected_version_;
+
+  // If true, installation will fail if the actual version doesn't match
+  // |expected_version_|. If false, the extension will still be installed, but
+  // not granted any permissions.
+  bool fail_install_if_unexpected_version_;
+
+  // Whether manual extension installation is enabled. We can't just check this
+  // before trying to install because themes and bookmark apps are special-cased
+  // to always be allowed.
+  bool extensions_enabled_;
+
+  // Whether we're supposed to delete the source file on destruction. Defaults
+  // to false.
+  bool delete_source_;
+
+  // The ordinal of the NTP apps page |extension_| will be shown on.
+  syncer::StringOrdinal page_ordinal_;
+
+  // A parsed copy of the unmodified original manifest, before any
+  // transformations like localization have taken place.
+  std::unique_ptr<Manifest> original_manifest_;
+
+  // If valid, contains the current version of the extension we're
+  // installing (for upgrades).
+  base::Version current_version_;
+
+  // The icon we will display in the installation UI, if any.
+  std::unique_ptr<SkBitmap> install_icon_;
+
+  // The temp directory extension resources were unpacked to. We own this and
+  // must delete it when we are done with it.
+  base::FilePath temp_dir_;
+
+  // The frontend we will report results back to.
+  base::WeakPtr<ExtensionService> service_weak_;
+
+  // The client we will work with to do the installation. This can be NULL, in
+  // which case the install is silent.
+  std::unique_ptr<ExtensionInstallPrompt> client_;
+
+  // The root of the unpacked extension directory. This is a subdirectory of
+  // temp_dir_, so we don't have to delete it explicitly.
+  base::FilePath unpacked_extension_root_;
+
+  // True when the CRX being installed was just downloaded.
+  // Used to trigger extra checks before installing.
+  bool apps_require_extension_mime_type_;
+
+  // Allows for the possibility of a normal install (one in which a |client|
+  // is provided in the ctor) to proceed without showing the permissions prompt
+  // dialog.
+  bool allow_silent_install_;
+
+  // Allows for the possibility of an installation without granting any
+  // permissions to the extension.
+  bool grant_permissions_;
+
+  // The value of the content type header sent with the CRX.
+  // Ignorred unless |require_extension_mime_type_| is true.
+  std::string original_mime_type_;
+
+  // What caused this install?  Used only for histograms that report
+  // on failure rates, broken down by the cause of the install.
+  extension_misc::CrxInstallCause install_cause_;
+
+  // Creation flags to use for the extension.  These flags will be used
+  // when calling Extension::Create() by the crx installer.
+  int creation_flags_;
+
+  // Whether to allow off store installation.
+  OffStoreInstallAllowReason off_store_install_allow_reason_;
+
+  // Whether the installation was handled successfully. This is used to
+  // indicate to the client whether the file should be removed and any UI
+  // initiating the installation can be removed. This is different than whether
+  // there was an error; if there was an error that rejects installation we
+  // still consider the installation 'handled'.
+  bool did_handle_successfully_;
+
+  // Whether we should produce an error if the manifest declares requirements
+  // that are not met. If false and there is an unmet requirement, the install
+  // will continue but the extension will be distabled.
+  bool error_on_unsupported_requirements_;
+
+  // Sequenced task runner where most file I/O operations will be performed.
+  scoped_refptr<base::SequencedTaskRunner> shared_file_task_runner_;
+
+  // Sequenced task runner where the SandboxedUnpacker will run. Because the
+  // unpacker uses its own temp dir, it won't hit race conditions, and can use a
+  // separate task runner per instance (for better performance).
+  //
+  // Lazily initialized by GetUnpackerTaskRunner().
+  scoped_refptr<base::SequencedTaskRunner> unpacker_task_runner_ = nullptr;
+
+  // Used to show the install dialog.
+  ExtensionInstallPrompt::ShowDialogCallback show_dialog_callback_;
+
+  // Whether the update is initiated by the user from the extension settings
+  // page.
+  bool update_from_settings_page_;
+
+  // The flags for ExtensionService::OnExtensionInstalled.
+  int install_flags_;
+
+  // Install prefs needed for the Declarative Net Request API.
+  declarative_net_request::RulesetInstallPrefs ruleset_install_prefs_;
+
+  // Checks that may run before installing the extension.
+  std::unique_ptr<PreloadCheck> policy_check_;
+  std::unique_ptr<PreloadCheck> requirements_check_;
+  std::unique_ptr<PreloadCheck> blocklist_check_;
+
+  // Runs the above checks.
+  std::unique_ptr<PreloadCheckGroup> check_group_;
+
+  // Invoked when the install is completed.
+  InstallerResultCallback installer_callback_;
+
+  // Invoked when the expectations from CRXFileInfo match with the crx file
+  // after unpack success.
+  ExpectationsVerifiedCallback expectations_verified_callback_;
+
+  DISALLOW_COPY_AND_ASSIGN(CrxInstaller);
+};
+
+}  // namespace extensions
+
+#endif  // CHROME_BROWSER_EXTENSIONS_CRX_INSTALLER_H_
diff --git a/components/user_scripts/browser/na/extension_system.cc b/components/user_scripts/browser/na/extension_system.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/browser/na/extension_system.cc
@@ -0,0 +1,26 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "extensions/browser/extension_system.h"
+
+#include "components/keyed_service/content/browser_context_keyed_service_factory.h"
+#include "extensions/browser/extension_system_provider.h"
+#include "extensions/browser/extensions_browser_client.h"
+
+namespace user_scripts {
+
+ExtensionSystem::ExtensionSystem() {
+}
+
+ExtensionSystem::~ExtensionSystem() {
+}
+
+// static
+ExtensionSystem* ExtensionSystem::Get(content::BrowserContext* context) {
+  return ExtensionsBrowserClient::Get()
+      ->GetExtensionSystemFactory()
+      ->GetForBrowserContext(context);
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/browser/na/extension_system.h b/components/user_scripts/browser/na/extension_system.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/browser/na/extension_system.h
@@ -0,0 +1,169 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_BROWSER_EXTENSION_SYSTEM_H_
+#define EXTENSIONS_BROWSER_EXTENSION_SYSTEM_H_
+
+#include <string>
+
+#include "base/callback.h"
+#include "base/memory/ref_counted.h"
+#include "base/optional.h"
+#include "build/build_config.h"
+#include "components/keyed_service/core/keyed_service.h"
+// #include "extensions/browser/install/crx_install_error.h"
+// #include "extensions/buildflags/buildflags.h"
+// #include "extensions/common/extension.h"
+
+// #if !BUILDFLAG(ENABLE_EXTENSIONS)
+// #error "Extensions must be enabled"
+// #endif
+
+namespace base {
+class OneShotEvent;
+}
+
+namespace content {
+class BrowserContext;
+}
+
+namespace user_scripts {
+
+class AppSorting;
+class ContentVerifier;
+class Extension;
+class ExtensionService;
+class ExtensionSet;
+class InfoMap;
+class ManagementPolicy;
+class QuotaService;
+class RuntimeData;
+class ServiceWorkerManager;
+class SharedUserScriptManager;
+class StateStore;
+class ValueStoreFactory;
+enum class UnloadedExtensionReason;
+
+// ExtensionSystem manages the lifetime of many of the services used by the
+// extensions and apps system, and it handles startup and shutdown as needed.
+// Eventually, we'd like to make more of these services into KeyedServices in
+// their own right.
+class ExtensionSystem : public KeyedService {
+ public:
+  // A callback to be executed when InstallUpdate finishes.
+  using InstallUpdateCallback =
+      base::OnceCallback<void(const base::Optional<CrxInstallError>& result)>;
+
+  ExtensionSystem();
+  ~ExtensionSystem() override;
+
+  // Returns the instance for the given browser context, or NULL if none.
+  static ExtensionSystem* Get(content::BrowserContext* context);
+
+  // Initializes extensions machinery.
+  // Component extensions are always enabled, external and user extensions are
+  // controlled (for both incognito and non-incognito profiles) by the
+  // |extensions_enabled| flag passed to non-incognito initialization.
+  // These calls should occur after the profile IO data is initialized,
+  // as extensions initialization depends on that.
+  virtual void InitForRegularProfile(bool extensions_enabled) = 0;
+
+  // The ExtensionService is created at startup. ExtensionService is only
+  // defined in Chrome.
+  virtual ExtensionService* extension_service() = 0;
+
+  // Per-extension data that can change during the life of the process but
+  // does not persist across restarts. Lives on UI thread. Created at startup.
+  virtual RuntimeData* runtime_data() = 0;
+
+  // The class controlling whether users are permitted to perform certain
+  // actions on extensions (install, uninstall, disable, etc.).
+  // The ManagementPolicy is created at startup.
+  virtual ManagementPolicy* management_policy() = 0;
+
+  // The ServiceWorkerManager is created at startup.
+  virtual ServiceWorkerManager* service_worker_manager() = 0;
+
+  // The SharedUserScriptManager is created at startup.
+  virtual SharedUserScriptManager* shared_user_script_manager() = 0;
+
+  // The StateStore is created at startup.
+  virtual StateStore* state_store() = 0;
+
+  // The rules store is created at startup.
+  virtual StateStore* rules_store() = 0;
+
+  // Returns the |ValueStore| factory created at startup.
+  virtual scoped_refptr<ValueStoreFactory> store_factory() = 0;
+
+  // Returns the IO-thread-accessible extension data.
+  virtual InfoMap* info_map() = 0;
+
+  // Returns the QuotaService that limits calls to certain extension functions.
+  // Lives on the UI thread. Created at startup.
+  virtual QuotaService* quota_service() = 0;
+
+  // Returns the AppSorting which provides an ordering for all installed apps.
+  virtual AppSorting* app_sorting() = 0;
+
+  // Called by the ExtensionService that lives in this system. Gives the
+  // info map a chance to react to the load event before the EXTENSION_LOADED
+  // notification has fired. The purpose for handling this event first is to
+  // avoid race conditions by making sure URLRequestContexts learn about new
+  // extensions before anything else needs them to know. This operation happens
+  // asynchronously. |callback| is run on the calling thread once completed.
+  virtual void RegisterExtensionWithRequestContexts(
+      const Extension* extension,
+      base::OnceClosure callback) {}
+
+  // Called by the ExtensionService that lives in this system. Lets the
+  // info map clean up its RequestContexts once all the listeners to the
+  // EXTENSION_UNLOADED notification have finished running.
+  virtual void UnregisterExtensionWithRequestContexts(
+      const std::string& extension_id,
+      const UnloadedExtensionReason reason) {}
+
+  // Signaled when the extension system has completed its startup tasks.
+  virtual const base::OneShotEvent& ready() const = 0;
+
+  // Whether the extension system is ready.
+  virtual bool is_ready() const = 0;
+
+  // Returns the content verifier, if any.
+  virtual ContentVerifier* content_verifier() = 0;
+
+  // Get a set of extensions that depend on the given extension.
+  // TODO(elijahtaylor): Move SharedModuleService out of chrome/browser
+  // so it can be retrieved from ExtensionSystem directly.
+  virtual std::unique_ptr<ExtensionSet> GetDependentExtensions(
+      const Extension* extension) = 0;
+
+  // Install an updated version of |extension_id| with the version given in
+  // |unpacked_dir|. If |install_immediately| is true, the system will install
+  // the given extension immediately instead of waiting until idle. Ownership
+  // of |unpacked_dir| in the filesystem is transferred and implementors of
+  // this function are responsible for cleaning it up on errors, etc.
+  virtual void InstallUpdate(const std::string& extension_id,
+                             const std::string& public_key,
+                             const base::FilePath& unpacked_dir,
+                             bool install_immediately,
+                             InstallUpdateCallback install_update_callback) = 0;
+
+  // Perform various actions depending on the Omaga attributes on the extension.
+  virtual void PerformActionBasedOnOmahaAttributes(
+      const std::string& extension_id,
+      const base::Value& attributes) = 0;
+
+  // Attempts finishing installation of an update for an extension with the
+  // specified id, when installation of that extension was previously delayed.
+  // |install_immediately| - Install the extension should be installed if it is
+  // currently in use.
+  // Returns whether the extension installation was finished.
+  virtual bool FinishDelayedInstallationIfReady(const std::string& extension_id,
+                                                bool install_immediately) = 0;
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_BROWSER_EXTENSION_SYSTEM_H_
diff --git a/components/user_scripts/browser/na/extension_user_script_loader.cc b/components/user_scripts/browser/na/extension_user_script_loader.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/browser/na/extension_user_script_loader.cc
@@ -0,0 +1,347 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "extensions/browser/extension_user_script_loader.h"
+
+#include <stddef.h>
+
+#include <functional>
+#include <map>
+#include <memory>
+#include <set>
+#include <string>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/bind_helpers.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/memory/read_only_shared_memory_region.h"
+#include "base/one_shot_event.h"
+#include "base/optional.h"
+#include "base/run_loop.h"
+#include "base/stl_util.h"
+#include "base/strings/string_util.h"
+#include "base/version.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/notification_service.h"
+#include "content/public/browser/render_process_host.h"
+#include "extensions/browser/component_extension_resource_manager.h"
+#include "extensions/browser/content_verifier.h"
+#include "extensions/browser/extension_file_task_runner.h"
+#include "extensions/browser/extension_system.h"
+#include "extensions/browser/extensions_browser_client.h"
+#include "extensions/common/file_util.h"
+#include "extensions/common/manifest_handlers/default_locale_handler.h"
+#include "extensions/common/message_bundle.h"
+#include "ui/base/resource/resource_bundle.h"
+
+using content::BrowserContext;
+
+namespace extensions {
+
+namespace {
+
+using SubstitutionMap = std::map<std::string, std::string>;
+
+// Each map entry associates a UserScript::File object with the ID of the
+// resource holding the content of the script.
+using ScriptResourceIds = std::map<UserScript::File*, base::Optional<int>>;
+
+struct VerifyContentInfo {
+  VerifyContentInfo(const scoped_refptr<ContentVerifier>& verifier,
+                    const ExtensionId& extension_id,
+                    const base::FilePath& extension_root,
+                    const base::FilePath relative_path,
+                    const std::string& content)
+      : verifier(verifier),
+        extension_id(extension_id),
+        extension_root(extension_root),
+        relative_path(relative_path),
+        content(content) {}
+
+  scoped_refptr<ContentVerifier> verifier;
+  ExtensionId extension_id;
+  base::FilePath extension_root;
+  base::FilePath relative_path;
+  std::string content;
+};
+
+// Verifies file contents as they are read.
+void VerifyContent(const VerifyContentInfo& info) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+  DCHECK(info.verifier);
+  scoped_refptr<ContentVerifyJob> job(info.verifier->CreateAndStartJobFor(
+      info.extension_id, info.extension_root, info.relative_path));
+  if (job.get()) {
+    job->Read(info.content.data(), info.content.size(), MOJO_RESULT_OK);
+    job->Done();
+  }
+}
+
+void ForwardVerifyContentToIO(const VerifyContentInfo& info) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  content::GetIOThreadTaskRunner({})->PostTask(
+      FROM_HERE, base::BindOnce(&VerifyContent, info));
+}
+
+// Loads user scripts from the extension who owns these scripts.
+bool LoadScriptContent(const HostID& host_id,
+                       UserScript::File* script_file,
+                       const base::Optional<int>& script_resource_id,
+                       const SubstitutionMap* localization_messages,
+                       const scoped_refptr<ContentVerifier>& verifier) {
+  DCHECK(script_file);
+  std::string content;
+  const base::FilePath& path = ExtensionResource::GetFilePath(
+      script_file->extension_root(), script_file->relative_path(),
+      ExtensionResource::SYMLINKS_MUST_RESOLVE_WITHIN_ROOT);
+  if (path.empty()) {
+    if (script_resource_id) {
+      const ui::ResourceBundle& rb = ui::ResourceBundle::GetSharedInstance();
+      content = rb.LoadDataResourceString(*script_resource_id);
+    } else {
+      LOG(WARNING) << "Failed to get file path to "
+                   << script_file->relative_path().value() << " from "
+                   << script_file->extension_root().value();
+      return false;
+    }
+  } else {
+    if (!base::ReadFileToString(path, &content)) {
+      LOG(WARNING) << "Failed to load user script file: " << path.value();
+      return false;
+    }
+    if (verifier.get()) {
+      // Call VerifyContent() after yielding on UI thread so it is ensured that
+      // ContentVerifierIOData is populated at the time we call VerifyContent().
+      // Priority set explicitly to avoid unwanted task priority inheritance.
+      content::GetUIThreadTaskRunner({base::TaskPriority::USER_BLOCKING})
+          ->PostTask(
+              FROM_HERE,
+              base::BindOnce(
+                  &ForwardVerifyContentToIO,
+                  VerifyContentInfo(verifier, host_id.id(),
+                                    script_file->extension_root(),
+                                    script_file->relative_path(), content)));
+    }
+  }
+
+  // Localize the content.
+  if (localization_messages) {
+    std::string error;
+    MessageBundle::ReplaceMessagesWithExternalDictionary(*localization_messages,
+                                                         &content, &error);
+    if (!error.empty())
+      LOG(WARNING) << "Failed to replace messages in script: " << error;
+  }
+
+  // Remove BOM from the content.
+  if (base::StartsWith(content, base::kUtf8ByteOrderMark,
+                       base::CompareCase::SENSITIVE)) {
+    script_file->set_content(content.substr(strlen(base::kUtf8ByteOrderMark)));
+  } else {
+    script_file->set_content(content);
+  }
+
+  return true;
+}
+
+SubstitutionMap* GetLocalizationMessages(
+    const ExtensionUserScriptLoader::HostsInfo& hosts_info,
+    const HostID& host_id) {
+  auto iter = hosts_info.find(host_id);
+  if (iter == hosts_info.end())
+    return nullptr;
+  const ExtensionUserScriptLoader::PathAndLocaleInfo& info = iter->second;
+  return file_util::LoadMessageBundleSubstitutionMap(
+      info.file_path, host_id.id(), info.default_locale, info.gzip_permission);
+}
+
+void FillScriptFileResourceIds(const UserScript::FileList& script_files,
+                               ScriptResourceIds& script_resource_ids) {
+  const ComponentExtensionResourceManager* extension_resource_manager =
+      ExtensionsBrowserClient::Get()->GetComponentExtensionResourceManager();
+  if (!extension_resource_manager)
+    return;
+
+  for (const std::unique_ptr<UserScript::File>& script_file : script_files) {
+    if (!script_file->GetContent().empty())
+      continue;
+    int resource_id = 0;
+    if (extension_resource_manager->IsComponentExtensionResource(
+            script_file->extension_root(), script_file->relative_path(),
+            &resource_id)) {
+      script_resource_ids[script_file.get()] = resource_id;
+    }
+  }
+}
+
+void LoadUserScripts(UserScriptList* user_scripts,
+                     ScriptResourceIds script_resource_ids,
+                     const ExtensionUserScriptLoader::HostsInfo& hosts_info,
+                     const std::set<int>& added_script_ids,
+                     const scoped_refptr<ContentVerifier>& verifier) {
+  for (const std::unique_ptr<UserScript>& script : *user_scripts) {
+    if (added_script_ids.count(script->id()) == 0)
+      continue;
+    for (const std::unique_ptr<UserScript::File>& script_file :
+         script->js_scripts()) {
+      if (script_file->GetContent().empty())
+        LoadScriptContent(script->host_id(), script_file.get(),
+                          script_resource_ids[script_file.get()], nullptr,
+                          verifier);
+    }
+    if (script->css_scripts().size() > 0) {
+      std::unique_ptr<SubstitutionMap> localization_messages(
+          GetLocalizationMessages(hosts_info, script->host_id()));
+      for (const std::unique_ptr<UserScript::File>& script_file :
+           script->css_scripts()) {
+        if (script_file->GetContent().empty()) {
+          LoadScriptContent(script->host_id(), script_file.get(),
+                            script_resource_ids[script_file.get()],
+                            localization_messages.get(), verifier);
+        }
+      }
+    }
+  }
+}
+
+void LoadScriptsOnFileTaskRunner(
+    std::unique_ptr<UserScriptList> user_scripts,
+    ScriptResourceIds script_resource_ids,
+    const ExtensionUserScriptLoader::HostsInfo& hosts_info,
+    const std::set<int>& added_script_ids,
+    const scoped_refptr<ContentVerifier>& verifier,
+    UserScriptLoader::LoadScriptsCallback callback) {
+  DCHECK(GetExtensionFileTaskRunner()->RunsTasksInCurrentSequence());
+  DCHECK(user_scripts.get());
+  LoadUserScripts(user_scripts.get(), std::move(script_resource_ids),
+                  hosts_info, added_script_ids, verifier);
+  base::ReadOnlySharedMemoryRegion memory =
+      UserScriptLoader::Serialize(*user_scripts);
+  // Explicit priority to prevent unwanted task priority inheritance.
+  content::GetUIThreadTaskRunner({base::TaskPriority::USER_BLOCKING})
+      ->PostTask(FROM_HERE,
+                 base::BindOnce(std::move(callback), std::move(user_scripts),
+                                std::move(memory)));
+}
+
+}  // namespace
+
+ExtensionUserScriptLoader::ExtensionUserScriptLoader(
+    BrowserContext* browser_context,
+    const HostID& host_id,
+    bool listen_for_extension_system_loaded)
+    : ExtensionUserScriptLoader(
+          browser_context,
+          host_id,
+          listen_for_extension_system_loaded,
+          ExtensionSystem::Get(browser_context)->content_verifier()) {}
+
+ExtensionUserScriptLoader::ExtensionUserScriptLoader(
+    BrowserContext* browser_context,
+    const HostID& host_id,
+    bool listen_for_extension_system_loaded,
+    scoped_refptr<ContentVerifier> content_verifier)
+    : UserScriptLoader(browser_context, host_id),
+      content_verifier_(std::move(content_verifier)) {
+  extension_registry_observer_.Add(ExtensionRegistry::Get(browser_context));
+  if (listen_for_extension_system_loaded) {
+    ExtensionSystem::Get(browser_context)
+        ->ready()
+        .Post(FROM_HERE,
+              base::BindOnce(&ExtensionUserScriptLoader::OnExtensionSystemReady,
+                             weak_factory_.GetWeakPtr()));
+  } else {
+    SetReady(true);
+  }
+}
+
+ExtensionUserScriptLoader::~ExtensionUserScriptLoader() {
+}
+
+std::unique_ptr<UserScriptList> ExtensionUserScriptLoader::LoadScriptsForTest(
+    std::unique_ptr<UserScriptList> user_scripts) {
+  std::set<int> added_script_ids;
+  for (const std::unique_ptr<UserScript>& script : *user_scripts)
+    added_script_ids.insert(script->id());
+
+  std::set<HostID> changed_hosts;
+  std::unique_ptr<UserScriptList> result;
+
+  // Block until the scripts have been loaded on the file task runner so that
+  // we can return the result synchronously.
+  base::RunLoop run_loop;
+  LoadScripts(std::move(user_scripts), changed_hosts, added_script_ids,
+              base::BindOnce(
+                  [](base::OnceClosure done_callback,
+                     std::unique_ptr<UserScriptList>& loaded_user_scripts,
+                     std::unique_ptr<UserScriptList> user_scripts,
+                     base::ReadOnlySharedMemoryRegion /* shared_memory */) {
+                    loaded_user_scripts = std::move(user_scripts);
+                    std::move(done_callback).Run();
+                  },
+                  run_loop.QuitClosure(), std::ref(result)));
+  run_loop.Run();
+
+  return result;
+}
+
+void ExtensionUserScriptLoader::LoadScripts(
+    std::unique_ptr<UserScriptList> user_scripts,
+    const std::set<HostID>& changed_hosts,
+    const std::set<int>& added_script_ids,
+    LoadScriptsCallback callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  UpdateHostsInfo(changed_hosts);
+
+  ScriptResourceIds script_resource_ids;
+  for (const std::unique_ptr<UserScript>& script : *user_scripts) {
+    if (!base::Contains(added_script_ids, script->id()))
+      continue;
+    FillScriptFileResourceIds(script->js_scripts(), script_resource_ids);
+    FillScriptFileResourceIds(script->css_scripts(), script_resource_ids);
+  }
+
+  GetExtensionFileTaskRunner()->PostTask(
+      FROM_HERE,
+      base::BindOnce(&LoadScriptsOnFileTaskRunner, std::move(user_scripts),
+                     std::move(script_resource_ids), hosts_info_,
+                     added_script_ids, content_verifier_, std::move(callback)));
+}
+
+void ExtensionUserScriptLoader::UpdateHostsInfo(
+    const std::set<HostID>& changed_hosts) {
+  ExtensionRegistry* registry = ExtensionRegistry::Get(browser_context());
+  for (const HostID& host_id : changed_hosts) {
+    const Extension* extension =
+        registry->GetExtensionById(host_id.id(), ExtensionRegistry::ENABLED);
+    // |changed_hosts_| may include hosts that have been removed,
+    // which leads to the above lookup failing. In this case, just continue.
+    if (!extension)
+      continue;
+    if (hosts_info_.find(host_id) != hosts_info_.end())
+      continue;
+    hosts_info_[host_id] = PathAndLocaleInfo{
+        extension->path(), LocaleInfo::GetDefaultLocale(extension),
+        extension_l10n_util::GetGzippedMessagesPermissionForExtension(
+            extension)};
+  }
+}
+
+void ExtensionUserScriptLoader::OnExtensionUnloaded(
+    content::BrowserContext* browser_context,
+    const Extension* extension,
+    UnloadedExtensionReason reason) {
+  hosts_info_.erase(HostID(HostID::EXTENSIONS, extension->id()));
+}
+
+void ExtensionUserScriptLoader::OnExtensionSystemReady() {
+  SetReady(true);
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/browser/na/extension_user_script_loader.h b/components/user_scripts/browser/na/extension_user_script_loader.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/browser/na/extension_user_script_loader.h
@@ -0,0 +1,88 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_BROWSER_EXTENSION_USER_SCRIPT_LOADER_H_
+#define EXTENSIONS_BROWSER_EXTENSION_USER_SCRIPT_LOADER_H_
+
+#include "base/macros.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/browser/extension_registry_observer.h"
+#include "extensions/browser/user_script_loader.h"
+#include "extensions/common/extension.h"
+#include "extensions/common/extension_l10n_util.h"
+
+namespace content {
+class BrowserContext;
+}
+
+namespace extensions {
+
+class ContentVerifier;
+
+// UserScriptLoader for extensions.
+class ExtensionUserScriptLoader : public UserScriptLoader,
+                                  public ExtensionRegistryObserver {
+ public:
+  struct PathAndLocaleInfo {
+    base::FilePath file_path;
+    std::string default_locale;
+    extension_l10n_util::GzippedMessagesPermission gzip_permission;
+  };
+  using HostsInfo = std::map<HostID, PathAndLocaleInfo>;
+
+  // The listen_for_extension_system_loaded is only set true when initializing
+  // the Extension System, e.g, when constructs SharedUserScriptManager in
+  // ExtensionSystemImpl.
+  ExtensionUserScriptLoader(content::BrowserContext* browser_context,
+                            const HostID& host_id,
+                            bool listen_for_extension_system_loaded);
+  ExtensionUserScriptLoader(content::BrowserContext* browser_context,
+                            const HostID& host_id,
+                            bool listen_for_extension_system_loaded,
+                            scoped_refptr<ContentVerifier> content_verifier);
+  ~ExtensionUserScriptLoader() override;
+
+  // A wrapper around the method to load user scripts. Waits for the user
+  // scripts to load and returns the scripts that were loaded. Exposed only for
+  // tests.
+  std::unique_ptr<UserScriptList> LoadScriptsForTest(
+      std::unique_ptr<UserScriptList> user_scripts);
+
+ private:
+  // UserScriptLoader:
+  void LoadScripts(std::unique_ptr<UserScriptList> user_scripts,
+                   const std::set<HostID>& changed_hosts,
+                   const std::set<int>& added_script_ids,
+                   LoadScriptsCallback callback) override;
+
+  // Updates |hosts_info_| to contain info for each element of
+  //  |changed_hosts_|.
+  void UpdateHostsInfo(const std::set<HostID>& changed_hosts);
+
+  // ExtensionRegistryObserver:
+  void OnExtensionUnloaded(content::BrowserContext* browser_context,
+                           const Extension* extension,
+                           UnloadedExtensionReason reason) override;
+
+  // Initiates script load when we have been waiting for the extension system
+  // to be ready.
+  void OnExtensionSystemReady();
+
+  // Maps host info needed for localization to a host ID.
+  HostsInfo hosts_info_;
+
+  // Manages content verification of the loaded user scripts.
+  scoped_refptr<ContentVerifier> content_verifier_;
+
+  ScopedObserver<ExtensionRegistry, ExtensionRegistryObserver>
+      extension_registry_observer_{this};
+
+  base::WeakPtrFactory<ExtensionUserScriptLoader> weak_factory_{this};
+
+  DISALLOW_COPY_AND_ASSIGN(ExtensionUserScriptLoader);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_BROWSER_EXTENSION_USER_SCRIPT_LOADER_H_
diff --git a/components/user_scripts/browser/user_script_loader.cc b/components/user_scripts/browser/user_script_loader.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/browser/user_script_loader.cc
@@ -0,0 +1,618 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "user_script_loader.h"
+
+#include <stddef.h>
+
+#include <set>
+#include <string>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/memory/writable_shared_memory_region.h"
+#include "base/strings/string_util.h"
+#include "base/version.h"
+#include "base/task/task_traits.h"
+#include "base/files/file_util.h"
+#include "base/files/file_enumerator.h"
+#include "base/path_service.h"
+#include "base/base_paths_android.h"
+#include "base/strings/utf_string_conversions.h"
+
+#include "crypto/sha2.h"
+#include "base/base64.h"
+
+#include "build/build_config.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/notification_service.h"
+#include "content/public/browser/notification_types.h"
+#include "content/public/browser/render_process_host.h"
+// #include "extensions/browser/extensions_browser_client.h"
+// #include "extensions/browser/notification_types.h"
+#include "../common/extension_messages.h"
+#include "extension_file_task_runner.h"
+
+using content::BrowserThread;
+using content::BrowserContext;
+
+namespace user_scripts {
+
+namespace {
+
+// #if DCHECK_IS_ON()
+// bool AreScriptsUnique(const UserScriptList& scripts) {
+//   std::set<int> script_ids;
+//   for (const std::unique_ptr<UserScript>& script : scripts) {
+//     if (script_ids.count(script->id()))
+//       return false;
+//     script_ids.insert(script->id());
+//   }
+//   return true;
+// }
+// #endif  // DCHECK_IS_ON()
+
+// Helper function to parse greasesmonkey headers
+bool GetDeclarationValue(const base::StringPiece& line,
+                         const base::StringPiece& prefix,
+                         std::string* value) {
+  base::StringPiece::size_type index = line.find(prefix);
+  if (index == base::StringPiece::npos)
+    return false;
+
+  std::string temp(line.data() + index + prefix.length(),
+                   line.length() - index - prefix.length());
+
+  if (temp.empty() || !base::IsUnicodeWhitespace(temp[0]))
+    return false;
+
+  base::TrimWhitespaceASCII(temp, base::TRIM_ALL, value);
+  return true;
+}
+
+}  // namespace
+
+// static
+bool UserScriptLoader::ParseMetadataHeader(const base::StringPiece& script_text,
+                                           UserScript* script) {
+  // http://wiki.greasespot.net/Metadata_block
+  base::StringPiece line;
+  size_t line_start = 0;
+  size_t line_end = line_start;
+  bool in_metadata = false;
+
+  static const base::StringPiece kUserScriptBegin("// ==UserScript==");
+  static const base::StringPiece kUserScriptEng("// ==/UserScript==");
+  static const base::StringPiece kNamespaceDeclaration("// @namespace");
+  static const base::StringPiece kNameDeclaration("// @name");
+  static const base::StringPiece kVersionDeclaration("// @version");
+  static const base::StringPiece kDescriptionDeclaration("// @description");
+  static const base::StringPiece kIncludeDeclaration("// @include");
+  static const base::StringPiece kExcludeDeclaration("// @exclude");
+  static const base::StringPiece kMatchDeclaration("// @match");
+  static const base::StringPiece kExcludeMatchDeclaration("// @exclude_match");
+  static const base::StringPiece kRunAtDeclaration("// @run-at");
+  static const base::StringPiece kRunAtDocumentStartValue("document-start");
+  static const base::StringPiece kRunAtDocumentEndValue("document-end");
+  static const base::StringPiece kRunAtDocumentIdleValue("document-idle");
+
+  while (line_start < script_text.length()) {
+    line_end = script_text.find('\n', line_start);
+
+    // Handle the case where there is no trailing newline in the file.
+    if (line_end == std::string::npos)
+      line_end = script_text.length() - 1;
+
+    line = base::StringPiece(script_text.data() + line_start,
+                             line_end - line_start);
+
+    if (!in_metadata) {
+      if (base::StartsWith(line, kUserScriptBegin))
+        in_metadata = true;
+    } else {
+      if (base::StartsWith(line, kUserScriptEng))
+        break;
+
+      std::string value;
+      if (GetDeclarationValue(line, kIncludeDeclaration, &value)) {
+        // We escape some characters that MatchPattern() considers special.
+        base::ReplaceSubstringsAfterOffset(&value, 0, "\\", "\\\\");
+        base::ReplaceSubstringsAfterOffset(&value, 0, "?", "\\?");
+        script->add_glob(value);
+      } else if (GetDeclarationValue(line, kExcludeDeclaration, &value)) {
+        base::ReplaceSubstringsAfterOffset(&value, 0, "\\", "\\\\");
+        base::ReplaceSubstringsAfterOffset(&value, 0, "?", "\\?");
+        script->add_exclude_glob(value);
+      } else if (GetDeclarationValue(line, kNamespaceDeclaration, &value)) {
+        script->set_name_space(value);
+      } else if (GetDeclarationValue(line, kNameDeclaration, &value)) {
+        script->set_name(value);
+      } else if (GetDeclarationValue(line, kVersionDeclaration, &value)) {
+        base::Version version(value);
+        if (version.IsValid())
+          script->set_version(version.GetString());
+      } else if (GetDeclarationValue(line, kDescriptionDeclaration, &value)) {
+        script->set_description(value);
+      } else if (GetDeclarationValue(line, kMatchDeclaration, &value)) {
+        URLPattern pattern(UserScript::ValidUserScriptSchemes());
+        if (URLPattern::ParseResult::kSuccess != pattern.Parse(value))
+          return false;
+        script->add_url_pattern(pattern);
+      } else if (GetDeclarationValue(line, kExcludeMatchDeclaration, &value)) {
+        URLPattern exclude(UserScript::ValidUserScriptSchemes());
+        if (URLPattern::ParseResult::kSuccess != exclude.Parse(value))
+          return false;
+        script->add_exclude_url_pattern(exclude);
+      } else if (GetDeclarationValue(line, kRunAtDeclaration, &value)) {
+        if (value == kRunAtDocumentStartValue)
+          script->set_run_location(UserScript::DOCUMENT_START);
+        else if (value == kRunAtDocumentEndValue)
+          script->set_run_location(UserScript::DOCUMENT_END);
+        else if (value == kRunAtDocumentIdleValue)
+          script->set_run_location(UserScript::DOCUMENT_IDLE);
+        else
+          return false;
+      }
+
+      // TODO(aa): Handle more types of metadata.
+    }
+
+    line_start = line_end + 1;
+  }
+
+  // If no patterns were specified, default to @include *. This is what
+  // Greasemonkey does.
+  if (script->globs().empty() && script->url_patterns().is_empty())
+    script->add_glob("*");
+
+  return true;
+}
+
+bool LoadUserScriptFromFile(
+    const base::FilePath& user_script_path, const GURL& original_url,
+    UserScript* script,
+    base::string16* error) {
+
+    std::string content;
+    if (!base::ReadFileToString(user_script_path, &content)) {
+      *error = base::ASCIIToUTF16("Could not read source file.");
+      return false;
+    }
+
+    if (!base::IsStringUTF8(content)) {
+      *error = base::ASCIIToUTF16("User script must be UTF8 encoded.");
+      return false;
+    }
+
+    if (!UserScriptLoader::ParseMetadataHeader(content, script)) {
+      *error = base::ASCIIToUTF16("Invalid script header.");
+      return false;
+    }
+
+    std::unique_ptr<UserScript::File> file(new UserScript::File());
+    file->set_content(content);
+    file->set_url(GURL("script.js"));
+
+    char raw[crypto::kSHA256Length] = {0};
+    std::string key;
+    crypto::SHA256HashString(content, raw, crypto::kSHA256Length);
+    base::Base64Encode(base::StringPiece(raw, crypto::kSHA256Length), &key);
+    file->set_key(key);
+
+    script->js_scripts().push_back(std::move(file));
+
+    //static_scripts_.AddScript(std::move(script_));
+
+    return true;
+}
+
+void LoadUserScripts(UserScriptList* user_scripts
+                    //  ,ScriptResourceIds script_resource_ids,
+                    //  const ExtensionUserScriptLoader::HostsInfo& hosts_info,
+                    //  const std::set<int>& added_script_ids,
+                     /*const scoped_refptr<ContentVerifier>& verifier*/) {
+  //Profile *profile = ProfileManager::GetLastUsedProfile();
+  base::FilePath path;
+  base::PathService::Get(base::DIR_ANDROID_APP_DATA, &path);
+  path = path.AppendASCII("snippets");
+
+  LOG(INFO) << "---Checking Path " << path;
+
+  // create snippets directory if not exists
+  if(!base::PathExists(path)) {
+    LOG(INFO) << "---Path " << path << " doesn't exists. Creating";
+    base::File::Error error = base::File::FILE_OK;
+    if( !base::CreateDirectoryAndGetError(path, &error) ) {
+      LOG(INFO) <<  
+               "ERROR: failed to create directory: " << path
+               << " with error code " << error;
+      return;
+    }
+  }
+
+  // 
+  // scripts_ = std::make_unique<UserScriptList>();
+  // scripts_->clear();
+
+  // 
+  base::FileEnumerator dir_enum(
+    path,
+    /*recursive=*/false, base::FileEnumerator::FILES);
+  base::FilePath full_name;
+  while (full_name = dir_enum.Next(), !full_name.empty()) {
+    LOG(INFO) << "---Found " << full_name;
+
+    //UserScript script;
+    std::unique_ptr<UserScript> userscript(new UserScript());
+
+    base::string16 error;
+    if( LoadUserScriptFromFile(full_name, GURL(), userscript.get(), &error) ) {
+      LOG(INFO) << "---  Loaded " << userscript->name() << 
+                                 " " << userscript->version() <<
+                                 " " << userscript->description();
+
+      //std::unique_ptr<UserScript> script_ptr(script);
+      user_scripts->push_back(std::move(userscript));
+    } else {
+      LOG(INFO) << "---  error " << error;
+    }
+  }
+}
+
+UserScriptLoader::UserScriptLoader(BrowserContext* browser_context)
+                                   //, const HostID& host_id)
+    : loaded_scripts_(new UserScriptList()),
+      //clear_scripts_(false),
+      ready_(false),
+      //queued_load_(false),
+      browser_context_(browser_context)
+      /*, host_id_(host_id)*/ {
+  LOG(INFO) << "---UserScriptLoader::UserScriptLoader ctor";
+  //SetReady(true);
+}
+
+UserScriptLoader::~UserScriptLoader() {
+  // for (auto& observer : observers_)
+  //   observer.OnUserScriptLoaderDestroyed(this);
+}
+
+// void UserScriptLoader::AddScripts(std::unique_ptr<UserScriptList> scripts) {
+// #if DCHECK_IS_ON()
+//   // |scripts| with non-unique IDs will work, but that would indicate we are
+//   // doing something wrong somewhere, so DCHECK that.
+//   DCHECK(AreScriptsUnique(*scripts))
+//       << "AddScripts() expects scripts with unique IDs.";
+// #endif  // DCHECK_IS_ON()
+//   for (std::unique_ptr<UserScript>& user_script : *scripts) {
+//     int id = user_script->id();
+//     removed_script_hosts_.erase(UserScriptIDPair(id));
+//     if (added_scripts_map_.count(id) == 0)
+//       added_scripts_map_[id] = std::move(user_script);
+//   }
+//   AttemptLoad();
+// }
+
+// void UserScriptLoader::AddScripts(std::unique_ptr<UserScriptList> scripts,
+//                                   int render_process_id,
+//                                   int render_frame_id) {
+//   AddScripts(std::move(scripts));
+// }
+
+// void UserScriptLoader::RemoveScripts(
+//     const std::set<UserScriptIDPair>& scripts) {
+//   for (const UserScriptIDPair& id_pair : scripts) {
+//     removed_script_hosts_.insert(UserScriptIDPair(id_pair.id, id_pair.host_id));
+//     // TODO(lazyboy): We shouldn't be trying to remove scripts that were never
+//     // a) added to |added_scripts_map_| or b) being loaded or has done loading
+//     // through |loaded_scripts_|. This would reduce sending redundant IPC.
+//     added_scripts_map_.erase(id_pair.id);
+//   }
+//   AttemptLoad();
+// }
+
+// void UserScriptLoader::ClearScripts() {
+//   clear_scripts_ = true;
+//   added_scripts_map_.clear();
+//   removed_script_hosts_.clear();
+//   AttemptLoad();
+// }
+
+void UserScriptLoader::OnRenderProcessHostCreated(
+    content::RenderProcessHost* process_host) {
+  // if (!ExtensionsBrowserClient::Get()->IsSameContext(
+  //         browser_context_, process_host->GetBrowserContext()))
+  //   return;
+  LOG(INFO) << "--- UserScriptLoader::OnRenderProcessHostCreated";
+
+  if (initial_load_complete()) {
+    SendUpdate(process_host, shared_memory_);
+               //,std::set<HostID>());  // Include all hosts.
+  }
+}
+
+// bool UserScriptLoader::ScriptsMayHaveChanged() const {
+//   // Scripts may have changed if there are scripts added, scripts removed, or
+//   // if scripts were cleared and either:
+//   // (1) A load is in progress (which may result in a non-zero number of
+//   //     scripts that need to be cleared), or
+//   // (2) The current set of scripts is non-empty (so they need to be cleared).
+//   return (added_scripts_map_.size() || removed_script_hosts_.size() ||
+//           (clear_scripts_ && (is_loading() || loaded_scripts_->size())));
+// }
+
+void UserScriptLoader::AttemptLoad() {
+  // if (ready_ && ScriptsMayHaveChanged()) {
+  //   if (is_loading())
+  //     queued_load_ = true;
+  //   else
+      StartLoad();
+  // }
+}
+
+void UserScriptLoader::StartLoad() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  // DCHECK(!is_loading());
+
+  LOG(INFO) << "---UserScriptLoader::StartLoad";
+
+  // Reload any loaded scripts, and clear out |loaded_scripts_| to indicate that
+  // the scripts aren't currently ready.
+  std::unique_ptr<UserScriptList> scripts_to_load = std::move(loaded_scripts_);
+  scripts_to_load->clear();
+
+  // if (clear_scripts_) {
+  //   // If scripts were marked for clearing before adding and removing, then
+  //   // clear them...
+  //   scripts_to_load->clear();
+  // } else {
+  //   // ... otherwise, filter out any scripts that are queued for removal.
+  //   for (auto it = scripts_to_load->begin(); it != scripts_to_load->end();) {
+  //     UserScriptIDPair id_pair(it->get()->id());
+  //     if (removed_script_hosts_.count(id_pair) > 0u)
+  //       it = scripts_to_load->erase(it);
+  //     else
+  //       ++it;
+  //   }
+  // }
+
+  // std::set<int> added_script_ids;
+  // scripts_to_load->reserve(scripts_to_load->size() + added_scripts_map_.size());
+  // for (auto& id_and_script : added_scripts_map_) {
+  //   std::unique_ptr<UserScript>& script = id_and_script.second;
+  //   added_script_ids.insert(script->id());
+  //   // Expand |changed_hosts_| for OnScriptsLoaded, which will use it in
+  //   // its IPC message. This must be done before we clear |added_scripts_map_|
+  //   // and |removed_script_hosts_| below.
+  //   changed_hosts_.insert(script->host_id());
+  //   // Move script from |added_scripts_map_| into |scripts_to_load|.
+  //   scripts_to_load->push_back(std::move(script));
+  // }
+  // for (const UserScriptIDPair& id_pair : removed_script_hosts_)
+  //   changed_hosts_.insert(id_pair.host_id);
+
+  LoadScripts(std::move(scripts_to_load), //changed_hosts_, added_script_ids,
+              base::BindOnce(&UserScriptLoader::OnScriptsLoaded,
+                             weak_factory_.GetWeakPtr()));
+
+  // clear_scripts_ = false;
+  // added_scripts_map_.clear();
+  // removed_script_hosts_.clear();
+}
+
+// bool UserScriptLoader::HasLoadedScripts(const HostID& host_id) const {
+//   // If there are no loaded scripts (which can happen if either the initial
+//   // load hasn't completed or if the loader is currently re-fetching scripts),
+//   // then the scripts have not been loaded.
+//   if (!loaded_scripts_)
+//     return false;
+
+//   // If there is a pending change for scripts associated with the |host_id|
+//   // (either addition or removal of a script), the scripts haven't finished
+//   // loading.
+//   for (const auto& key_value : added_scripts_map_) {
+//     if (key_value.second->host_id() == host_id)
+//       return false;
+//   }
+//   for (const UserScriptIDPair& id_pair : removed_script_hosts_) {
+//     if (id_pair.host_id == host_id)
+//       return false;
+//   }
+
+//   // Find if we have any scripts associated with the |host_id|.
+//   bool has_loaded_script = false;
+//   for (const auto& script : *loaded_scripts_) {
+//     if (script->host_id() == host_id) {
+//       has_loaded_script = true;
+//       break;
+//     }
+//   }
+
+//   // Assume that if any script associated with |host_id| is present (and there
+//   // aren't any pending changes), then the scripts have successfully loaded.
+//   return has_loaded_script;
+// }
+
+// static
+base::ReadOnlySharedMemoryRegion UserScriptLoader::Serialize(
+    const UserScriptList& scripts) {
+  base::Pickle pickle;
+  pickle.WriteUInt32(scripts.size());
+  for (const std::unique_ptr<UserScript>& script : scripts) {
+    // TODO(aa): This can be replaced by sending content script metadata to
+    // renderers along with other extension data in ExtensionMsg_Loaded.
+    // See crbug.com/70516.
+    script->Pickle(&pickle);
+    // Write scripts as 'data' so that we can read it out in the slave without
+    // allocating a new string.
+    for (const std::unique_ptr<UserScript::File>& js_file :
+         script->js_scripts()) {
+      base::StringPiece contents = js_file->GetContent();
+      pickle.WriteData(contents.data(), contents.length());
+    }
+    for (const std::unique_ptr<UserScript::File>& css_file :
+         script->css_scripts()) {
+      base::StringPiece contents = css_file->GetContent();
+      pickle.WriteData(contents.data(), contents.length());
+    }
+  }
+
+  // Create the shared memory object.
+  base::MappedReadOnlyRegion shared_memory =
+      base::ReadOnlySharedMemoryRegion::Create(pickle.size());
+  if (!shared_memory.IsValid())
+    return {};
+
+  // Copy the pickle to shared memory.
+  memcpy(shared_memory.mapping.memory(), pickle.data(), pickle.size());
+  return std::move(shared_memory.region);
+}
+
+// void UserScriptLoader::AddObserver(Observer* observer) {
+//   observers_.AddObserver(observer);
+// }
+
+// void UserScriptLoader::RemoveObserver(Observer* observer) {
+//   observers_.RemoveObserver(observer);
+// }
+
+void UserScriptLoader::SetReady(bool ready) {
+  bool was_ready = ready_;
+  ready_ = ready;
+  if (ready_ && !was_ready)
+    AttemptLoad();
+}
+
+void UserScriptLoader::OnScriptsLoaded(
+    std::unique_ptr<UserScriptList> user_scripts,
+    base::ReadOnlySharedMemoryRegion shared_memory) {
+  LOG(INFO) << "---UserScriptLoader::OnScriptsLoaded";
+
+  loaded_scripts_ = std::move(user_scripts);
+  // if (queued_load_) {
+  //   // While we were loading, there were further changes. Don't bother
+  //   // notifying about these scripts and instead just immediately reload.
+  //   queued_load_ = false;
+  //   StartLoad();
+  //   return;
+  // }
+
+  if (!shared_memory.IsValid()) {
+    // This can happen if we run out of file descriptors.  In that case, we
+    // have a choice between silently omitting all user scripts for new tabs,
+    // by nulling out shared_memory_, or only silently omitting new ones by
+    // leaving the existing object in place. The second seems less bad, even
+    // though it removes the possibility that freeing the shared memory block
+    // would open up enough FDs for long enough for a retry to succeed.
+
+    // Pretend the extension change didn't happen.
+    return;
+  }
+
+  LOG(INFO) << "---UserScriptLoader::OnScriptsLoaded 2";
+
+  // We've got scripts ready to go.
+  shared_memory_ = std::move(shared_memory);
+
+  for (content::RenderProcessHost::iterator i(
+           content::RenderProcessHost::AllHostsIterator());
+       !i.IsAtEnd(); i.Advance()) {
+    SendUpdate(i.GetCurrentValue(), shared_memory_); //, changed_hosts_);
+  }
+  // changed_hosts_.clear();
+
+  // TODO(hanxi): Remove the NOTIFICATION_USER_SCRIPTS_UPDATED.
+  // content::NotificationService::current()->Notify(
+  //     user_scripts::NOTIFICATION_USER_SCRIPTS_UPDATED,
+  //     content::Source<BrowserContext>(browser_context_),
+  //     content::Details<base::ReadOnlySharedMemoryRegion>(&shared_memory_));
+  // for (auto& observer : observers_)
+  //   observer.OnScriptsLoaded(this, browser_context_);
+}
+
+void UserScriptLoader::SendUpdate(
+    content::RenderProcessHost* process,
+    const base::ReadOnlySharedMemoryRegion& shared_memory
+    /*const std::set<HostID>& changed_hosts*/) {
+  LOG(INFO) << "---UserScriptLoader::SendUpdate";
+  // Don't allow injection of non-whitelisted extensions' content scripts
+  // into <webview>.
+  //bool whitelisted_only = process->IsForGuestsOnly() && host_id().id().empty();
+
+  // Make sure we only send user scripts to processes in our browser_context.
+  // if (!ExtensionsBrowserClient::Get()->IsSameContext(
+  //         browser_context_, process->GetBrowserContext()))
+  //   return;
+
+  // If the process is being started asynchronously, early return.  We'll end up
+  // calling InitUserScripts when it's created which will call this again.
+  base::ProcessHandle handle = process->GetProcess().Handle();
+  if (!handle)
+    return;
+
+  LOG(INFO) << "---UserScriptLoader::SendUpdate 2";
+
+  base::ReadOnlySharedMemoryRegion region_for_process =
+      shared_memory.Duplicate();
+  if (!region_for_process.IsValid())
+    return;
+
+  LOG(INFO) << "---UserScriptLoader::SendUpdate 3";
+
+  //std::set<HostID> changed_hosts;
+  process->Send(new ExtensionMsg_UpdateUserScripts(
+     std::move(region_for_process))); //, /*host_id()*/HostID(), changed_hosts,
+      ///*whitelisted_only*/false));
+}
+
+void LoadScriptsOnFileTaskRunner(
+    std::unique_ptr<UserScriptList> user_scripts,
+    // ScriptResourceIds script_resource_ids,
+    // const ExtensionUserScriptLoader::HostsInfo& hosts_info,
+    // const std::set<int>& added_script_ids,
+    // const scoped_refptr<ContentVerifier>& verifier,
+    UserScriptLoader::LoadScriptsCallback callback) {
+  DCHECK(GetUserScriptsFileTaskRunner()->RunsTasksInCurrentSequence());
+  DCHECK(user_scripts.get());
+  LoadUserScripts(user_scripts.get()); //, std::move(script_resource_ids),
+                  //hosts_info, added_script_ids, verifier);
+  base::ReadOnlySharedMemoryRegion memory =
+      UserScriptLoader::Serialize(*user_scripts);
+
+  // Explicit priority to prevent unwanted task priority inheritance.
+  content::GetUIThreadTaskRunner({base::TaskPriority::USER_BLOCKING})
+      ->PostTask(FROM_HERE,
+                 base::BindOnce(std::move(callback), std::move(user_scripts),
+                                std::move(memory)));
+}
+
+void UserScriptLoader::LoadScripts(
+    std::unique_ptr<UserScriptList> user_scripts,
+    // const std::set<HostID>& changed_hosts,
+    // const std::set<int>& added_script_ids,
+    LoadScriptsCallback callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  // UpdateHostsInfo(changed_hosts);
+
+  // ScriptResourceIds script_resource_ids;
+  // for (const std::unique_ptr<UserScript>& script : *user_scripts) {
+  //   if (!base::Contains(added_script_ids, script->id()))
+  //     continue;
+  //   FillScriptFileResourceIds(script->js_scripts(), script_resource_ids);
+  //   FillScriptFileResourceIds(script->css_scripts(), script_resource_ids);
+  // }
+  LOG(INFO) << "---UserScriptLoader::LoadScripts";
+
+  GetUserScriptsFileTaskRunner()->PostTask(
+      FROM_HERE,
+      base::BindOnce(&LoadScriptsOnFileTaskRunner, std::move(user_scripts),
+                    //  std::move(script_resource_ids), 
+                    //  hosts_info_,
+                    //  added_script_ids, content_verifier_,
+                     std::move(callback)));
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/browser/user_script_loader.h b/components/user_scripts/browser/user_script_loader.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/browser/user_script_loader.h
@@ -0,0 +1,191 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_BROWSER_USER_SCRIPT_LOADER_H_
+#define EXTENSIONS_BROWSER_USER_SCRIPT_LOADER_H_
+
+#include <map>
+#include <memory>
+#include <set>
+
+#include "base/callback_forward.h"
+#include "base/compiler_specific.h"
+#include "base/macros.h"
+#include "base/memory/read_only_shared_memory_region.h"
+#include "base/memory/weak_ptr.h"
+#include "base/observer_list.h"
+#include "base/scoped_observer.h"
+#include "content/public/browser/render_process_host_creation_observer.h"
+#include "../common/host_id.h"
+#include "../common/user_script.h"
+
+namespace base {
+class ReadOnlySharedMemoryRegion;
+}
+
+namespace content {
+class BrowserContext;
+class RenderProcessHost;
+}
+
+namespace user_scripts {
+
+// Manages one "logical unit" of user scripts in shared memory by constructing a
+// new shared memory region when the set of scripts changes. Also notifies
+// renderers of new shared memory region when new renderers appear, or when
+// script reloading completes. Script loading lives on the UI thread. Instances
+// of this class are embedded within classes with names ending in
+// UserScriptManager. These "manager" classes implement the strategy for which
+// scripts to load/unload on this logical unit of scripts.
+class UserScriptLoader : public content::RenderProcessHostCreationObserver {
+ public:
+  using LoadScriptsCallback =
+      base::OnceCallback<void(std::unique_ptr<UserScriptList>,
+                              base::ReadOnlySharedMemoryRegion shared_memory)>;
+  // class Observer {
+  //  public:
+  //   virtual void OnScriptsLoaded(UserScriptLoader* loader,
+  //                                content::BrowserContext* browser_context) = 0;
+  //   virtual void OnUserScriptLoaderDestroyed(UserScriptLoader* loader) = 0;
+  // };
+
+  // Parses the includes out of |script| and returns them in |includes|.
+  static bool ParseMetadataHeader(const base::StringPiece& script_text,
+                                  UserScript* script);
+
+  UserScriptLoader(content::BrowserContext* browser_context);
+                   //const HostID& host_id);
+  ~UserScriptLoader() override;
+
+  // Add |scripts| to the set of scripts managed by this loader.
+  // void AddScripts(std::unique_ptr<UserScriptList> scripts);
+
+  // Add |scripts| to the set of scripts managed by this loader.
+  // The fetch of the content of the script starts URL request
+  // to the associated render specified by
+  // |render_process_id, render_frame_id|.
+  // TODO(hanxi): The renderer information doesn't really belong in this base
+  // class, but it's not an easy fix.
+  // virtual void AddScripts(std::unique_ptr<UserScriptList> scripts,
+  //                         int render_process_id,
+  //                         int render_frame_id);
+
+  // Removes scripts with ids specified in |scripts| from the set of scripts
+  // managed by this loader.
+  // TODO(lazyboy): Likely we can make |scripts| a std::vector, but
+  // WebViewContentScriptManager makes this non-trivial.
+  // void RemoveScripts(const std::set<UserScriptIDPair>& scripts);
+
+  // Clears the set of scripts managed by this loader.
+  // void ClearScripts();
+
+  // Initiates procedure to start loading scripts on the file thread.
+  void StartLoad();
+
+  // Returns true if the scripts for the given |host_id| have been loaded.
+  // bool HasLoadedScripts(const HostID& host_id) const;
+
+  // Returns true if we have any scripts ready.
+  bool initial_load_complete() const { return shared_memory_.IsValid(); }
+
+  // Pickle user scripts and return pointer to the shared memory.
+  static base::ReadOnlySharedMemoryRegion Serialize(
+      const user_scripts::UserScriptList& scripts);
+
+  // Adds or removes observers.
+  // void AddObserver(Observer* observer);
+  // void RemoveObserver(Observer* observer);
+
+  // Sets the flag if the initial set of hosts has finished loading; if it's
+  // set to be true, calls AttempLoad() to bootstrap.
+  void SetReady(bool ready);
+
+ protected:
+  // Allows the derived classes to have different ways to load user scripts.
+  // This may not be synchronous with the calls to Add/Remove/Clear scripts.
+  void LoadScripts(std::unique_ptr<UserScriptList> user_scripts,
+                      // const std::set<HostID>& changed_hosts,
+                      // const std::set<int>& added_script_ids,
+                      LoadScriptsCallback callback);
+
+  content::BrowserContext* browser_context() const { return browser_context_; }
+  // const HostID& host_id() const { return host_id_; }
+
+ private:
+  // content::RenderProcessHostCreationObserver:
+  void OnRenderProcessHostCreated(
+      content::RenderProcessHost* process_host) override;
+
+  // Returns whether or not it is possible that calls to AddScripts(),
+  // RemoveScripts(), and/or ClearScripts() have caused any real change in the
+  // set of scripts to be loaded.
+  // bool ScriptsMayHaveChanged() const;
+
+  // Attempts to initiate a load.
+  void AttemptLoad();
+
+  // Called once we have finished loading the scripts on the file thread.
+  void OnScriptsLoaded(std::unique_ptr<UserScriptList> user_scripts,
+                       base::ReadOnlySharedMemoryRegion shared_memory);
+
+  // Sends the renderer process a new set of user scripts. If
+  // |changed_hosts| is not empty, this signals that only the scripts from
+  // those hosts should be updated. Otherwise, all hosts will be
+  // updated.
+  void SendUpdate(content::RenderProcessHost* process,
+                  const base::ReadOnlySharedMemoryRegion& shared_memory
+                  /*,const std::set<HostID>& changed_hosts*/);
+
+  // bool is_loading() const {
+  //   // |loaded_scripts_| is reset when loading.
+  //   return loaded_scripts_.get() == nullptr;
+  // }
+
+  // Contains the scripts that were found the last time scripts were updated.
+  base::ReadOnlySharedMemoryRegion shared_memory_;
+
+  // List of scripts that are currently loaded. This is null when a load is in
+  // progress.
+  std::unique_ptr<UserScriptList> loaded_scripts_;
+
+  // The mutually-exclusive information about sets of scripts that were added or
+  // removed since the last script load. These maps are keyed by script ids.
+  // Note that we only need HostID information for removal.
+  // std::map<int, std::unique_ptr<UserScript>> added_scripts_map_;
+  // std::set<UserScriptIDPair> removed_script_hosts_;
+
+  // Indicates whether the the collection of scripts should be cleared before
+  // additions and removals on the next script load.
+  // bool clear_scripts_;
+
+  // The IDs of the extensions which changed in the last update sent to the
+  // renderer.
+  // std::set<HostID> changed_hosts_;
+
+  // If the initial set of hosts has finished loading.
+  bool ready_;
+
+  // If list of user scripts is modified while we're loading it, we note
+  // that we're currently mid-load and then start over again once the load
+  // finishes.  This boolean tracks whether another load is pending.
+  // bool queued_load_;
+
+  // The browser_context for which the scripts managed here are installed.
+  content::BrowserContext* browser_context_;
+
+  // ID of the host that owns these scripts, if any. This is only set to a
+  // non-empty value for declarative user script shared memory regions.
+  // HostID host_id_;
+
+  // The associated observers.
+  // base::ObserverList<Observer>::Unchecked observers_;
+
+  base::WeakPtrFactory<UserScriptLoader> weak_factory_{this};
+
+  DISALLOW_COPY_AND_ASSIGN(UserScriptLoader);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_BROWSER_USER_SCRIPT_LOADER_H_
diff --git a/components/user_scripts/common/BUILD.gn b/components/user_scripts/common/BUILD.gn
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/BUILD.gn
@@ -0,0 +1,541 @@
+# Copyright 2014 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/features.gni")
+import("//components/nacl/features.gni")
+import("//extensions/buildflags/buildflags.gni")
+import("//mojo/public/tools/bindings/mojom.gni")
+import("//testing/libfuzzer/fuzzer_test.gni")
+
+# TODO(crbug.com/731689): Assert that extensions are enabled.
+
+# source_set("common_constants") {
+#   sources = [
+#   ]
+
+#   deps = [
+#     "//base",
+#     "//build:chromecast_buildflags",
+#     "//components/services/app_service/public/mojom",
+#     "//components/version_info:channel",
+#     "//ui/base",
+#   ]
+
+#   configs += [
+#     # TODO(jschuh): crbug.com/167187 fix size_t to int truncations.
+#     "//build/config/compiler:no_size_t_to_int_warning",
+#     "//build/config/compiler:wexit_time_destructors",
+#   ]
+# }
+
+# if (enable_extensions) {
+#   mojom("mojom") {
+#     # We don't want Blink variants of bindings to be generated.
+#     disable_variants = true
+
+#     sources = [
+#       "mojom/app_window.mojom",
+#       "mojom/guest_view.mojom",
+#       "mojom/keep_alive.mojom",
+#     ]
+
+#     if (proprietary_codecs && enable_wifi_display) {
+#       sources += [ "mojo/wifi_display_session_service.mojom" ]
+#     }
+
+#     public_deps = [
+#       "//content/public/common:interfaces",
+#       "//extensions/common/api:mojom",
+#       "//mojo/public/mojom/base",
+#       "//ui/gfx/geometry/mojom",
+#       "//url/mojom:url_mojom_gurl",
+#     ]
+
+#     overridden_deps = [ "//content/public/common:interfaces" ]
+
+#     component_deps = [ "//content/public/common" ]
+#   }
+
+  # This must be a static library because extensions common depends on
+  # GetTrustedICAPublicKey in extensions/browser which isn't always linked
+  # in. TODO(brettw): This reverse dependency should be fixed.
+  static_library("common") {
+    sources = [
+    "constants.cc",
+    "constants.h",
+    "extension_id.h",
+    "host_id.cc",
+    "host_id.h",
+    "script_constants.h",
+    "url_pattern_set.cc",
+    "url_pattern_set.h",
+    "url_pattern.cc",
+    "url_pattern.h",
+    "user_script.cc",
+    "user_script.h",
+    "view_type.cc",
+    "view_type.h",
+    "extension_messages.cc",
+    "extension_messages.h",
+    "extension_message_generator.cc",
+    "extension_message_generator.h",
+      # "activation_sequence.h",
+      # "alias.h",
+      # "api/bluetooth/bluetooth_manifest_data.cc",
+      # "api/bluetooth/bluetooth_manifest_data.h",
+      # "api/bluetooth/bluetooth_manifest_handler.cc",
+      # "api/bluetooth/bluetooth_manifest_handler.h",
+      # "api/bluetooth/bluetooth_manifest_permission.cc",
+      # "api/bluetooth/bluetooth_manifest_permission.h",
+      # "api/declarative/declarative_constants.cc",
+      # "api/declarative/declarative_constants.h",
+      # "api/declarative/declarative_manifest_data.cc",
+      # "api/declarative/declarative_manifest_data.h",
+      # "api/declarative/declarative_manifest_handler.cc",
+      # "api/declarative/declarative_manifest_handler.h",
+      # "api/declarative_net_request/constants.cc",
+      # "api/declarative_net_request/constants.h",
+      # "api/declarative_net_request/dnr_manifest_data.cc",
+      # "api/declarative_net_request/dnr_manifest_data.h",
+      # "api/declarative_net_request/dnr_manifest_handler.cc",
+      # "api/declarative_net_request/dnr_manifest_handler.h",
+      # "api/declarative_net_request/utils.cc",
+      # "api/declarative_net_request/utils.h",
+      # "api/extension_action/action_info.cc",
+      # "api/extension_action/action_info.h",
+      # "api/messaging/message.h",
+      # "api/messaging/messaging_endpoint.cc",
+      # "api/messaging/messaging_endpoint.h",
+      # "api/messaging/port_context.cc",
+      # "api/messaging/port_context.h",
+      # "api/messaging/port_id.cc",
+      # "api/messaging/port_id.h",
+      # "api/printer_provider/usb_printer_manifest_data.cc",
+      # "api/printer_provider/usb_printer_manifest_data.h",
+      # "api/printer_provider/usb_printer_manifest_handler.cc",
+      # "api/printer_provider/usb_printer_manifest_handler.h",
+      # "api/sockets/sockets_manifest_data.cc",
+      # "api/sockets/sockets_manifest_data.h",
+      # "api/sockets/sockets_manifest_handler.cc",
+      # "api/sockets/sockets_manifest_handler.h",
+      # "api/sockets/sockets_manifest_permission.cc",
+      # "api/sockets/sockets_manifest_permission.h",
+      # "common_manifest_handlers.cc",
+      # "common_manifest_handlers.h",
+      # "common_param_traits.h",
+      # "cors_util.cc",
+      # "cors_util.h",
+      # "csp_validator.cc",
+      # "csp_validator.h",
+      # "dom_action_types.h",
+      # "draggable_region.cc",
+      # "draggable_region.h",
+      # "error_utils.cc",
+      # "error_utils.h",
+      # "event_filter.cc",
+      # "event_filter.h",
+      # "event_filtering_info.cc",
+      # "event_filtering_info.h",
+      # "event_matcher.cc",
+      # "event_matcher.h",
+      # "extension.cc",
+      # "extension.h",
+      # "extension_api.cc",
+      # "extension_api.h",
+      # "extension_features.cc",
+      # "extension_features.h",
+      # "extension_icon_set.cc",
+      # "extension_icon_set.h",
+      # "extension_id.h",
+      # "extension_l10n_util.cc",
+      # "extension_l10n_util.h",
+      # "extension_message_generator.cc",
+      # "extension_message_generator.h",
+      # "extension_messages.cc",
+      # "extension_messages.h",
+      # "extension_paths.cc",
+      # "extension_paths.h",
+      # "extension_resource.cc",
+      # "extension_resource.h",
+      # "extension_resource_path_normalizer.cc",
+      # "extension_resource_path_normalizer.h",
+      # "extension_set.cc",
+      # "extension_set.h",
+      # "extension_updater_uma.h",
+      # "extension_urls.cc",
+      # "extension_urls.h",
+      # "extension_utility_types.h",
+      # "extensions_client.cc",
+      # "extensions_client.h",
+      # "feature_switch.cc",
+      # "feature_switch.h",
+      # "features/behavior_feature.cc",
+      # "features/behavior_feature.h",
+      # "features/complex_feature.cc",
+      # "features/complex_feature.h",
+      # "features/feature.cc",
+      # "features/feature.h",
+      # "features/feature_channel.cc",
+      # "features/feature_channel.h",
+      # "features/feature_flags.cc",
+      # "features/feature_flags.h",
+      # "features/feature_provider.cc",
+      # "features/feature_provider.h",
+      # "features/feature_session_type.cc",
+      # "features/feature_session_type.h",
+      # "features/json_feature_provider_source.cc",
+      # "features/json_feature_provider_source.h",
+      # "features/manifest_feature.cc",
+      # "features/manifest_feature.h",
+      # "features/permission_feature.cc",
+      # "features/permission_feature.h",
+      # "features/simple_feature.cc",
+      # "features/simple_feature.h",
+      # "file_util.cc",
+      # "file_util.h",
+      # "guest_view/extensions_guest_view_messages.h",
+      # "guest_view/mime_handler_view_uma_types.cc",
+      # "guest_view/mime_handler_view_uma_types.h",
+      # "hashed_extension_id.cc",
+      # "hashed_extension_id.h",
+      # "host_id.cc",
+      # "host_id.h",
+      # "identifiability_metrics.cc",
+      # "identifiability_metrics.h",
+      # "image_util.cc",
+      # "image_util.h",
+      # "install_warning.cc",
+      # "install_warning.h",
+      # "manifest.cc",
+      # "manifest.h",
+      # "manifest_constants.cc",
+      # "manifest_constants.h",
+      # "manifest_handler.cc",
+      # "manifest_handler.h",
+      # "manifest_handler_helpers.cc",
+      # "manifest_handler_helpers.h",
+      # "manifest_handlers/app_isolation_info.cc",
+      # "manifest_handlers/app_isolation_info.h",
+      # "manifest_handlers/automation.cc",
+      # "manifest_handlers/automation.h",
+      # "manifest_handlers/background_info.cc",
+      # "manifest_handlers/background_info.h",
+      # "manifest_handlers/content_capabilities_handler.cc",
+      # "manifest_handlers/content_capabilities_handler.h",
+      # "manifest_handlers/content_scripts_handler.cc",
+      # "manifest_handlers/content_scripts_handler.h",
+      # "manifest_handlers/csp_info.cc",
+      # "manifest_handlers/csp_info.h",
+      # "manifest_handlers/default_locale_handler.cc",
+      # "manifest_handlers/default_locale_handler.h",
+      # "manifest_handlers/extension_action_handler.cc",
+      # "manifest_handlers/extension_action_handler.h",
+      # "manifest_handlers/externally_connectable.cc",
+      # "manifest_handlers/externally_connectable.h",
+      # "manifest_handlers/file_handler_info.cc",
+      # "manifest_handlers/file_handler_info.h",
+      # "manifest_handlers/icons_handler.cc",
+      # "manifest_handlers/icons_handler.h",
+      # "manifest_handlers/incognito_info.cc",
+      # "manifest_handlers/incognito_info.h",
+      # "manifest_handlers/kiosk_mode_info.cc",
+      # "manifest_handlers/kiosk_mode_info.h",
+      # "manifest_handlers/mime_types_handler.cc",
+      # "manifest_handlers/mime_types_handler.h",
+      # "manifest_handlers/oauth2_manifest_handler.cc",
+      # "manifest_handlers/oauth2_manifest_handler.h",
+      # "manifest_handlers/offline_enabled_info.cc",
+      # "manifest_handlers/offline_enabled_info.h",
+      # "manifest_handlers/options_page_info.cc",
+      # "manifest_handlers/options_page_info.h",
+      # "manifest_handlers/permissions_parser.cc",
+      # "manifest_handlers/permissions_parser.h",
+      # "manifest_handlers/replacement_apps.cc",
+      # "manifest_handlers/replacement_apps.h",
+      # "manifest_handlers/requirements_info.cc",
+      # "manifest_handlers/requirements_info.h",
+      # "manifest_handlers/sandboxed_page_info.cc",
+      # "manifest_handlers/sandboxed_page_info.h",
+      # "manifest_handlers/shared_module_info.cc",
+      # "manifest_handlers/shared_module_info.h",
+      # "manifest_handlers/web_accessible_resources_info.cc",
+      # "manifest_handlers/web_accessible_resources_info.h",
+      # "manifest_handlers/web_app_file_handler.cc",
+      # "manifest_handlers/web_app_file_handler.h",
+      # "manifest_handlers/web_app_linked_shortcut_items.cc",
+      # "manifest_handlers/web_app_linked_shortcut_items.h",
+      # "manifest_handlers/web_app_shortcut_icons_handler.cc",
+      # "manifest_handlers/web_app_shortcut_icons_handler.h",
+      # "manifest_handlers/webview_info.cc",
+      # "manifest_handlers/webview_info.h",
+      # "manifest_url_handlers.cc",
+      # "manifest_url_handlers.h",
+      # "message_bundle.cc",
+      # "message_bundle.h",
+      # "permissions/api_permission.cc",
+      # "permissions/api_permission.h",
+      # "permissions/api_permission_set.cc",
+      # "permissions/api_permission_set.h",
+      # "permissions/base_set_operators.h",
+      # "permissions/extensions_api_permissions.cc",
+      # "permissions/extensions_api_permissions.h",
+      # "permissions/manifest_permission.cc",
+      # "permissions/manifest_permission.h",
+      # "permissions/manifest_permission_set.cc",
+      # "permissions/manifest_permission_set.h",
+      # "permissions/permission_message.cc",
+      # "permissions/permission_message.h",
+      # "permissions/permission_message_provider.cc",
+      # "permissions/permission_message_provider.h",
+      # "permissions/permission_message_util.cc",
+      # "permissions/permission_message_util.h",
+      # "permissions/permission_set.cc",
+      # "permissions/permission_set.h",
+      # "permissions/permissions_data.cc",
+      # "permissions/permissions_data.h",
+      # "permissions/permissions_info.cc",
+      # "permissions/permissions_info.h",
+      # "permissions/set_disjunction_permission.h",
+      # "permissions/settings_override_permission.cc",
+      # "permissions/settings_override_permission.h",
+      # "permissions/socket_permission.cc",
+      # "permissions/socket_permission.h",
+      # "permissions/socket_permission_data.cc",
+      # "permissions/socket_permission_data.h",
+      # "permissions/socket_permission_entry.cc",
+      # "permissions/socket_permission_entry.h",
+      # "permissions/usb_device_permission.cc",
+      # "permissions/usb_device_permission.h",
+      # "permissions/usb_device_permission_data.cc",
+      # "permissions/usb_device_permission_data.h",
+      # "script_constants.h",
+      # "stack_frame.cc",
+      # "stack_frame.h",
+      # "switches.cc",
+      # "switches.h",
+      # "url_pattern.cc",
+      # "url_pattern.h",
+      # "url_pattern_set.cc",
+      # "url_pattern_set.h",
+      # "user_script.cc",
+      # "user_script.h",
+      # "value_builder.cc",
+      # "value_builder.h",
+      # "value_counter.cc",
+      # "value_counter.h",
+      # "verifier_formats.cc",
+      # "verifier_formats.h",
+      # "view_type.cc",
+      # "view_type.h",
+    ]
+
+    configs += [
+      "//build/config:precompiled_headers",
+
+      # TODO(jschuh): crbug.com/167187 fix size_t to int truncations.
+      "//build/config/compiler:no_size_t_to_int_warning",
+      "//build/config/compiler:wexit_time_destructors",
+    ]
+
+    public_deps = [
+      # ":common_constants",
+      # ":mojom",
+      "//components/services/app_service/public/cpp:app_file_handling",
+      "//content/public/common",
+      "//ipc",
+      "//skia",
+    ]
+
+    deps = [
+      "//base",
+      # "//build:branding_buildflags",
+      # "//build:chromeos_buildflags",
+      # "//components/crx_file",
+      # "//components/nacl/common:buildflags",
+      "//components/url_formatter",
+      "//components/url_matcher",
+      "//components/version_info",
+      "//crypto",
+      # "//device/bluetooth",
+      # "//device/bluetooth/public/cpp",
+      # "//extensions:extensions_resources",
+      # "//extensions/common/api",
+      # "//extensions/strings",
+      # "//net",
+      # "//services/device/public/cpp/usb",
+      # "//services/device/public/mojom:usb",
+      # "//services/network/public/mojom",
+      # "//third_party/boringssl",
+      # "//third_party/icu",
+      # "//third_party/re2",
+      # "//third_party/zlib/google:compression_utils",
+      # "//tools/json_schema_compiler:generated_api_util",
+      # "//ui/base",
+      # "//ui/gfx/geometry",
+      # "//ui/gfx/ipc",
+      # "//ui/gfx/ipc/geometry",
+      # "//ui/gfx/ipc/skia",
+      # "//url",
+    ]
+
+    # if (enable_nacl) {
+    #   sources += [
+    #     "manifest_handlers/nacl_modules_handler.cc",
+    #     "manifest_handlers/nacl_modules_handler.h",
+    #   ]
+    # }
+
+    # if (is_chromeos) {
+    #   sources += [
+    #     "manifest_handlers/action_handlers_handler.cc",
+    #     "manifest_handlers/action_handlers_handler.h",
+    #   ]
+    # }
+  }
+
+  # NOTE: This is separate from ":common" because it depends on
+  # extensions/common/api:extensions_features, which in turn depends on
+  # :common.
+  # source_set("core_api_provider") {
+  #   sources = [
+  #     "core_extensions_api_provider.cc",
+  #     "core_extensions_api_provider.h",
+  #   ]
+
+  #   configs += [ "//build/config/compiler:wexit_time_destructors" ]
+  #   deps = [
+  #     ":common",
+  #     "//extensions:extensions_resources",
+  #     "//extensions/common/api",
+  #     "//extensions/common/api:extensions_features",
+  #   ]
+  # }
+
+  # source_set("test_support") {
+  #   testonly = true
+
+  #   sources = [
+  #     "api/declarative_net_request/test_utils.cc",
+  #     "api/declarative_net_request/test_utils.h",
+  #     "api/extension_action/action_info_test_util.cc",
+  #     "api/extension_action/action_info_test_util.h",
+  #     "file_test_util.cc",
+  #     "file_test_util.h",
+  #     "scoped_worker_based_extensions_channel.cc",
+  #     "scoped_worker_based_extensions_channel.h",
+  #   ]
+
+  #   deps = [
+  #     ":common",
+  #     "//base",
+  #     "//components/version_info:channel",
+  #     "//extensions/common/api",
+  #   ]
+  # }
+
+  # source_set("unit_tests") {
+  #   testonly = true
+  #   sources = [
+  #     "api/declarative/declarative_manifest_unittest.cc",
+  #     "api/declarative_net_request/dnr_manifest_unittest.cc",
+  #     "api/printer_provider/usb_printer_manifest_unittest.cc",
+  #     "api/sockets/sockets_manifest_permission_unittest.cc",
+  #     "component_extension_url_pattern_unittest.cc",
+  #     "csp_validator_unittest.cc",
+  #     "error_utils_unittest.cc",
+  #     "event_filter_unittest.cc",
+  #     "extension_builder_unittest.cc",
+  #     "extension_icon_set_unittest.cc",
+  #     "extension_l10n_util_unittest.cc",
+  #     "extension_messages_unittest.cc",
+  #     "extension_resource_path_normalizer_unittest.cc",
+  #     "extension_resource_unittest.cc",
+  #     "extension_set_unittest.cc",
+  #     "extension_unittest.cc",
+  #     "feature_switch_unittest.cc",
+  #     "features/complex_feature_unittest.cc",
+  #     "features/feature_provider_unittest.cc",
+  #     "features/simple_feature_unittest.cc",
+  #     "file_util_unittest.cc",
+  #     "hashed_extension_id_unittest.cc",
+  #     "image_util_unittest.cc",
+  #     "manifest_handler_perf_test.cc",
+  #     "manifest_handler_unittest.cc",
+  #     "manifest_handlers/content_capabilities_manifest_unittest.cc",
+  #     "manifest_handlers/csp_info_unittest.cc",
+  #     "manifest_handlers/default_locale_manifest_unittest.cc",
+  #     "manifest_handlers/extension_action_handler_unittest.cc",
+  #     "manifest_handlers/externally_connectable_unittest.cc",
+  #     "manifest_handlers/file_handler_manifest_unittest.cc",
+  #     "manifest_handlers/icons_handler_unittest.cc",
+  #     "manifest_handlers/incognito_manifest_unittest.cc",
+  #     "manifest_handlers/kiosk_mode_info_unittest.cc",
+  #     "manifest_handlers/manifest_v3_permissions_unittest.cc",
+  #     "manifest_handlers/oauth2_manifest_unittest.cc",
+  #     "manifest_handlers/replacement_apps_unittest.cc",
+  #     "manifest_handlers/shared_module_manifest_unittest.cc",
+  #     "manifest_handlers/web_app_file_handler_manifest_unittest.cc",
+  #     "manifest_handlers/web_app_linked_shortcut_items_unittest.cc",
+  #     "manifest_handlers/web_app_shortcut_icons_handler_unittest.cc",
+  #     "manifest_unittest.cc",
+  #     "message_bundle_unittest.cc",
+  #     "permissions/api_permission_set_unittest.cc",
+  #     "permissions/api_permission_unittest.cc",
+  #     "permissions/base_set_operators_unittest.cc",
+  #     "permissions/manifest_permission_set_unittest.cc",
+  #     "permissions/socket_permission_unittest.cc",
+  #     "permissions/usb_device_permission_unittest.cc",
+  #     "stack_frame_unittest.cc",
+  #     "url_pattern_set_unittest.cc",
+  #     "url_pattern_unittest.cc",
+  #     "user_script_unittest.cc",
+  #     "value_builder_unittest.cc",
+  #     "value_counter_unittest.cc",
+  #   ]
+
+  #   deps = [
+  #     ":common",
+  #     ":test_support",
+  #     "//base",
+  #     "//base:i18n",
+  #     "//base/test:test_support",
+  #     "//components/crx_file",
+  #     "//components/version_info:version_info",
+  #     "//content/test:test_support",
+  #     "//extensions:extensions_resources",
+  #     "//extensions/common/api",
+  #     "//tools/json_schema_compiler:generated_api_util",
+
+  #     # TODO(brettw) these tests should not be including headers from browser.
+  #     "//extensions:test_support",
+  #     "//extensions/browser",
+  #     "//extensions/strings",
+  #     "//ipc",
+  #     "//services/device/public/cpp:test_support",
+  #     "//testing/gmock",
+  #     "//testing/gtest",
+  #     "//third_party/zlib/google:compression_utils",
+  #     "//ui/base",
+  #     "//ui/gfx",
+  #     "//url",
+  #   ]
+
+  #   if (is_chromeos) {
+  #     sources += [ "manifest_handlers/action_handlers_handler_unittest.cc" ]
+  #   }
+
+  #   data = [
+  #     "//extensions/common/permissions/api_permission.h",
+  #     "//tools/metrics/histograms/enums.xml",
+  #   ]
+  # }
+
+  # fuzzer_test("extension_fuzzer") {
+  #   sources = [ "extension_fuzzer.cc" ]
+  #   deps = [
+  #     ":common",
+  #     "//base",
+  #   ]
+  # }
+#}  # enable_extensions
diff --git a/components/user_scripts/common/constants.cc b/components/user_scripts/common/constants.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/constants.cc
@@ -0,0 +1,196 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "constants.h"
+
+#include "base/stl_util.h"
+#include "base/strings/string_piece.h"
+#include "build/chromecast_buildflags.h"
+
+namespace user_scripts {
+
+// const char kExtensionScheme[] = "chrome-extension";
+
+// const base::FilePath::CharType kManifestFilename[] =
+//     FILE_PATH_LITERAL("manifest.json");
+// const base::FilePath::CharType kDifferentialFingerprintFilename[] =
+//     FILE_PATH_LITERAL("manifest.fingerprint");
+// const base::FilePath::CharType kLocaleFolder[] =
+//     FILE_PATH_LITERAL("_locales");
+// const base::FilePath::CharType kMessagesFilename[] =
+//     FILE_PATH_LITERAL("messages.json");
+// const base::FilePath::CharType kGzippedMessagesFilename[] =
+//     FILE_PATH_LITERAL("messages.json.gz");
+// const base::FilePath::CharType kPlatformSpecificFolder[] =
+//     FILE_PATH_LITERAL("_platform_specific");
+// const base::FilePath::CharType kMetadataFolder[] =
+//     FILE_PATH_LITERAL("_metadata");
+// const base::FilePath::CharType kVerifiedContentsFilename[] =
+//     FILE_PATH_LITERAL("verified_contents.json");
+// const base::FilePath::CharType kComputedHashesFilename[] =
+//     FILE_PATH_LITERAL("computed_hashes.json");
+// const base::FilePath::CharType kIndexedRulesetDirectory[] =
+//     FILE_PATH_LITERAL("generated_indexed_rulesets");
+
+// const char kInstallDirectoryName[] = "Extensions";
+
+// const char kTempExtensionName[] = "CRX_INSTALL";
+
+// const char kDecodedMessageCatalogsFilename[] = "DECODED_MESSAGE_CATALOGS";
+
+// const char kGeneratedBackgroundPageFilename[] =
+//     "_generated_background_page.html";
+
+// const char kModulesDir[] = "_modules";
+
+// const base::FilePath::CharType kExtensionFileExtension[] =
+//     FILE_PATH_LITERAL(".crx");
+// const base::FilePath::CharType kExtensionKeyFileExtension[] =
+//     FILE_PATH_LITERAL(".pem");
+
+// // If auto-updates are turned on, default to running every 5 hours.
+// const int kDefaultUpdateFrequencySeconds = 60 * 60 * 5;
+
+// const char kLocalAppSettingsDirectoryName[] = "Local App Settings";
+// const char kLocalExtensionSettingsDirectoryName[] = "Local Extension Settings";
+// const char kSyncAppSettingsDirectoryName[] = "Sync App Settings";
+// const char kSyncExtensionSettingsDirectoryName[] = "Sync Extension Settings";
+// const char kManagedSettingsDirectoryName[] = "Managed Extension Settings";
+// const char kStateStoreName[] = "Extension State";
+// const char kRulesStoreName[] = "Extension Rules";
+// const char kWebStoreAppId[] = "ahfgeienlihckogmohjhadlkjgocpleb";
+
+// const uint8_t kWebstoreSignaturesPublicKey[] = {
+//     0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,
+//     0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00,
+//     0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0x8f, 0xfb, 0xbf,
+//     0x5c, 0x37, 0x63, 0x94, 0x3c, 0xb0, 0xee, 0x01, 0xc4, 0xb5, 0xa6, 0x9a,
+//     0xb1, 0x9f, 0x46, 0x74, 0x6f, 0x16, 0x38, 0xa0, 0x32, 0x27, 0x35, 0xdd,
+//     0xf0, 0x71, 0x6b, 0x0e, 0xdc, 0xf6, 0x25, 0xcb, 0xb2, 0xed, 0xea, 0xfb,
+//     0x32, 0xd5, 0xaf, 0x1e, 0x03, 0x43, 0x03, 0x46, 0xf0, 0xa7, 0x39, 0xdb,
+//     0x23, 0x96, 0x1d, 0x65, 0xe5, 0x78, 0x51, 0xf0, 0x84, 0xb0, 0x0e, 0x12,
+//     0xac, 0x0e, 0x5b, 0xdc, 0xc9, 0xd6, 0x4c, 0x7c, 0x00, 0xd5, 0xb8, 0x1b,
+//     0x88, 0x33, 0x3e, 0x2f, 0xda, 0xeb, 0xaa, 0xf7, 0x1a, 0x75, 0xc2, 0xae,
+//     0x3a, 0x54, 0xde, 0x37, 0x8f, 0x10, 0xd2, 0x28, 0xe6, 0x84, 0x79, 0x4d,
+//     0x15, 0xb4, 0xf3, 0xbd, 0x3f, 0x56, 0xd3, 0x3c, 0x3f, 0x18, 0xab, 0xfc,
+//     0x2e, 0x05, 0xc0, 0x1e, 0x08, 0x31, 0xb6, 0x61, 0xd0, 0xfd, 0x9f, 0x4f,
+//     0x3f, 0x64, 0x0d, 0x17, 0x93, 0xbc, 0xad, 0x41, 0xc7, 0x48, 0xbe, 0x00,
+//     0x27, 0xa8, 0x4d, 0x70, 0x42, 0x92, 0x05, 0x54, 0xa6, 0x6d, 0xb8, 0xde,
+//     0x56, 0x6e, 0x20, 0x49, 0x70, 0xee, 0x10, 0x3e, 0x6b, 0xd2, 0x7c, 0x31,
+//     0xbd, 0x1b, 0x6e, 0xa4, 0x3c, 0x46, 0x62, 0x9f, 0x08, 0x66, 0x93, 0xf9,
+//     0x2a, 0x51, 0x31, 0xa8, 0xdb, 0xb5, 0x9d, 0xb9, 0x0f, 0x73, 0xe8, 0xa0,
+//     0x09, 0x32, 0x01, 0xe9, 0x7b, 0x2a, 0x8a, 0x36, 0xa0, 0xcf, 0x17, 0xb0,
+//     0x50, 0x70, 0x9d, 0xa2, 0xf9, 0xa4, 0x6f, 0x62, 0x4d, 0xb6, 0xc9, 0x31,
+//     0xfc, 0xf3, 0x08, 0x12, 0xff, 0x93, 0xbd, 0x62, 0x31, 0xd8, 0x1c, 0xea,
+//     0x1a, 0x9e, 0xf5, 0x81, 0x28, 0x7f, 0x75, 0x5e, 0xd2, 0x27, 0x7a, 0xc2,
+//     0x96, 0xf5, 0x9d, 0xdb, 0x18, 0xfc, 0x76, 0xdc, 0x46, 0xf0, 0x57, 0xc0,
+//     0x58, 0x34, 0xc8, 0x22, 0x2d, 0x2a, 0x65, 0x75, 0xa7, 0xd9, 0x08, 0x62,
+//     0xcd, 0x02, 0x03, 0x01, 0x00, 0x01};
+
+// const size_t kWebstoreSignaturesPublicKeySize =
+//     base::size(kWebstoreSignaturesPublicKey);
+
+// const int kMainThreadId = 0;
+
+// const char kMimeTypeJpeg[] = "image/jpeg";
+// const char kMimeTypePng[] = "image/png";
+
+}  // namespace extensions
+
+// namespace extension_misc {
+
+// #if defined(OS_CHROMEOS) || BUILDFLAG(IS_CHROMECAST)
+// // The extension id for the built-in component extension.
+// const char kChromeVoxExtensionId[] = "mndnfokpggljbaajbnioimlmbfngpief";
+// #else
+// // The extension id for the web store extension.
+// const char kChromeVoxExtensionId[] = "kgejglhpjiefppelpmljglcjbhoiplfn";
+// #endif
+// const char kFeedbackExtensionId[] = "gfdkimpbcpahaombhbimeihdjnejgicl";
+// const char kPdfExtensionId[] = "mhjfbmdgcfjbbpaeojofohoefgiehjai";
+// const char kQuickOfficeComponentExtensionId[] =
+//     "bpmcpldpdmajfigpchkicefoigmkfalc";
+// const char kQuickOfficeInternalExtensionId[] =
+//     "ehibbfinohgbchlgdbfpikodjaojhccn";
+// const char kQuickOfficeExtensionId[] = "gbkeegbaiigmenfmjfclcdgdpimamgkj";
+// const char kMimeHandlerPrivateTestExtensionId[] =
+//     "oickdpebdnfbgkcaoklfcdhjniefkcji";
+// const char kCameraAppId[] = "hfhhnacclhffhdffklopdkcgdhifgngh";
+// const char kCameraAppDevId[] = "flgnmkgjffmkephdokeeliiopbjaafpm";
+// const char kChromeAppId[] = "mgndgikekgjfcpckkfioiadnlibdjbkf";
+// // Generated by: echo "lacros-chrome" | sha256sum | head -c32 | tr 0-9a-f a-p
+// const char kLacrosAppId[] = "jaimifaeiicidiikhmjedcgdimealfbh";
+// const char kFilesManagerAppId[] = "hhaomjibdihmijegdhdafkllkbggdgoj";
+// const char kCalculatorAppId[] = "joodangkbfjnajiiifokapkpmhfnpleo";
+// const char kCalendarDemoAppId[] = "fpgfohogebplgnamlafljlcidjedbdeb";
+// const char kGMailAppId[] = "pjkljhegncpnkpknbcohdijeoejaedia";
+// const char kGoogleDocsDemoAppId[] = "chdaoodbokekbiiphekbfjdmiodccljl";
+// const char kGoogleDriveAppId[] = "apdfllckaahabafndbhieahigkjlhalf";
+// const char kGoogleSheetsDemoAppId[] = "nifkmgcdokhkjghdlgflonppnefddien";
+// const char kGoogleSlidesDemoAppId[] = "hdmobeajeoanbanmdlabnbnlopepchip";
+// const char kGoogleKeepAppId[] = "hmjkmjkepdijhoojdojkdfohbdgmmhki";
+// const char kYoutubeAppId[] = "blpcfgokakmgnkcojhhkbfbldkacnbeo";
+// const char kGeniusAppId[] = "ljoammodoonkhnehlncldjelhidljdpi";
+
+// #if defined(OS_CHROMEOS)
+// // TODO(michaelpg): Deprecate old app IDs before adding new ones to avoid bloat.
+// const char kHighlightsAppId[] = "lpmakjfjcconjeehbidjclhdlpjmfjjj";
+// const char kHighlightsEveAppId[] = "iggildboghmjpbjcpmobahnkmoefkike";
+// const char kHighlightsNocturneAppId[] = "elhbopodaklenjkeihkdhhfaghalllba";
+// const char kHighlightsAtlasAppId[] = "gjeelkjnolfmhphfhhjokaijbicopfln";
+// const char kScreensaverAppId[] = "mnoijifedipmbjaoekhadjcijipaijjc";
+// const char kScreensaverEveAppId[] = "gdobaoeekhiklaljmhladjfdfkigampc";
+// const char kScreensaverNocturneAppId[] = "lminefdanffajachfahfpmphfkhahcnj";
+// const char kScreensaverAtlasAppId[] = "bnabjkecnachpogjlfilfcnlpcmacglh";
+// const char kScreensaverKukuiAppId[] = "fafhbhdboeiciklpkminlncemohljlkj";
+// const char kSigninProfileTestExtensionId[] = "mecfefiddjlmabpeilblgegnbioikfmp";
+
+// bool IsSystemUIApp(base::StringPiece extension_id) {
+//   static const char* const kApps[] = {
+//       // clang-format off
+//       kCameraAppId,
+//       kChromeVoxExtensionId,
+//       kFeedbackExtensionId,
+//       kFilesManagerAppId,
+//       kHighlightsEveAppId,
+//       kHighlightsNocturneAppId,
+//       kHighlightsAtlasAppId,
+//       kHighlightsAppId,
+//       kScreensaverEveAppId,
+//       kScreensaverNocturneAppId,
+//       kScreensaverAtlasAppId,
+//       kScreensaverAppId,
+//       // clang-format on
+//   };
+//   for (const char* id : kApps) {
+//     if (extension_id == id)
+//       return true;
+//   }
+//   return false;
+// }
+// #endif  // defined(OS_CHROMEOS)
+
+// const char kProdHangoutsExtensionId[] = "nckgahadagoaajjgafhacjanaoiihapd";
+// const char* const kHangoutsExtensionIds[6] = {
+//     kProdHangoutsExtensionId,
+//     "ljclpkphhpbpinifbeabbhlfddcpfdde",  // Debug.
+//     "ppleadejekpmccmnpjdimmlfljlkdfej",  // Alpha.
+//     "eggnbpckecmjlblplehfpjjdhhidfdoj",  // Beta.
+//     "jfjjdfefebklmdbmenmlehlopoocnoeh",  // Packaged App Debug.
+//     "knipolnnllmklapflnccelgolnpehhpl"   // Packaged App Prod.
+//     // Keep in sync with _api_features.json and _manifest_features.json.
+// };
+
+// // Error returned when scripting of a page is denied due to enterprise policy.
+// const char kPolicyBlockedScripting[] =
+//     "This page cannot be scripted due to an ExtensionsSettings policy.";
+
+// const int kContentVerificationDefaultBlockSize = 4096;
+
+// const logging::LogSeverity kMinimumSeverityToReportError = logging::LOG_WARNING;
+
+// const char kCastExtensionIdRelease[] = "pkedcjkdefgpdelpbcmbmeomcjbeemfm";
+// const char kCastExtensionIdDev[] = "enhhojjnijigcajfphajepfemndkmdlo";
+
+// }  // namespace extension_misc
diff --git a/components/user_scripts/common/constants.h b/components/user_scripts/common/constants.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/constants.h
@@ -0,0 +1,304 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef USERSCRIPTS_COMMON_CONSTANTS_H_
+#define USERSCRIPTS_COMMON_CONSTANTS_H_
+
+#include "base/files/file_path.h"
+#include "base/strings/string_piece_forward.h"
+#include "components/services/app_service/public/mojom/types.mojom.h"
+#include "components/version_info/channel.h"
+#include "ui/base/layout.h"
+
+namespace user_scripts {
+
+// // Scheme we serve extension content from.
+// extern const char kExtensionScheme[];
+
+// // The name of the manifest inside an extension.
+// extern const base::FilePath::CharType kManifestFilename[];
+
+// // The name of the differential fingerprint file inside an extension.
+// extern const base::FilePath::CharType kDifferentialFingerprintFilename[];
+
+// // The name of locale folder inside an extension.
+// extern const base::FilePath::CharType kLocaleFolder[];
+
+// // The name of the messages file inside an extension.
+// extern const base::FilePath::CharType kMessagesFilename[];
+
+// // The name of the gzipped messages file inside an extension.
+// extern const base::FilePath::CharType kGzippedMessagesFilename[];
+
+// // The base directory for subdirectories with platform-specific code.
+// extern const base::FilePath::CharType kPlatformSpecificFolder[];
+
+// // A directory reserved for metadata, generated either by the webstore
+// // or chrome.
+// extern const base::FilePath::CharType kMetadataFolder[];
+
+// // Name of the verified contents file within the metadata folder.
+// extern const base::FilePath::CharType kVerifiedContentsFilename[];
+
+// // Name of the computed hashes file within the metadata folder.
+// extern const base::FilePath::CharType kComputedHashesFilename[];
+
+// // Name of the indexed ruleset directory for the Declarative Net Request API.
+// extern const base::FilePath::CharType kIndexedRulesetDirectory[];
+
+// // The name of the directory inside the profile where extensions are
+// // installed to.
+// extern const char kInstallDirectoryName[];
+
+// // The name of a temporary directory to install an extension into for
+// // validation before finalizing install.
+// extern const char kTempExtensionName[];
+
+// // The file to write our decoded message catalogs to, relative to the
+// // extension_path.
+// extern const char kDecodedMessageCatalogsFilename[];
+
+// // The filename to use for a background page generated from
+// // background.scripts.
+// extern const char kGeneratedBackgroundPageFilename[];
+
+// // Path to imported modules.
+// extern const char kModulesDir[];
+
+// // The file extension (.crx) for extensions.
+// extern const base::FilePath::CharType kExtensionFileExtension[];
+
+// // The file extension (.pem) for private key files.
+// extern const base::FilePath::CharType kExtensionKeyFileExtension[];
+
+// // Default frequency for auto updates, if turned on.
+// extern const int kDefaultUpdateFrequencySeconds;
+
+// // The name of the directory inside the profile where per-app local settings
+// // are stored.
+// extern const char kLocalAppSettingsDirectoryName[];
+
+// // The name of the directory inside the profile where per-extension local
+// // settings are stored.
+// extern const char kLocalExtensionSettingsDirectoryName[];
+
+// // The name of the directory inside the profile where per-app synced settings
+// // are stored.
+// extern const char kSyncAppSettingsDirectoryName[];
+
+// // The name of the directory inside the profile where per-extension synced
+// // settings are stored.
+// extern const char kSyncExtensionSettingsDirectoryName[];
+
+// // The name of the directory inside the profile where per-extension persistent
+// // managed settings are stored.
+// extern const char kManagedSettingsDirectoryName[];
+
+// // The name of the database inside the profile where chrome-internal
+// // extension state resides.
+// extern const char kStateStoreName[];
+
+// // The name of the database inside the profile where declarative extension
+// // rules are stored.
+// extern const char kRulesStoreName[];
+
+// // The URL query parameter key corresponding to multi-login user index.
+// extern const char kAuthUserQueryKey[];
+
+// // Mime type strings
+// extern const char kMimeTypeJpeg[];
+// extern const char kMimeTypePng[];
+
+// // The extension id of the Web Store component application.
+// extern const char kWebStoreAppId[];
+
+// // The key used for signing some pieces of data from the webstore.
+// extern const uint8_t kWebstoreSignaturesPublicKey[];
+// extern const size_t kWebstoreSignaturesPublicKeySize;
+
+// // Thread identifier for the main renderer thread (as opposed to a service
+// // worker thread).
+// // This is the default thread id used for extension event listeners registered
+// // from a non-service worker context
+// extern const int kMainThreadId;
+
+// using apps::mojom::AppLaunchSource;
+// using apps::mojom::LaunchContainer;
+
+// // This enum is used for the launch type the user wants to use for an
+// // application.
+// // Do not remove items or re-order this enum as it is used in preferences
+// // and histograms.
+// enum LaunchType {
+//   LAUNCH_TYPE_INVALID = -1,
+//   LAUNCH_TYPE_FIRST = 0,
+//   LAUNCH_TYPE_PINNED = LAUNCH_TYPE_FIRST,
+//   LAUNCH_TYPE_REGULAR = 1,
+//   LAUNCH_TYPE_FULLSCREEN = 2,
+//   LAUNCH_TYPE_WINDOW = 3,
+//   NUM_LAUNCH_TYPES,
+
+//   // Launch an app in the in the way a click on the NTP would,
+//   // if no user pref were set.  Update this constant to change
+//   // the default for the NTP and chrome.management.launchApp().
+//   LAUNCH_TYPE_DEFAULT = LAUNCH_TYPE_REGULAR
+// };
+
+// // The origin of injected CSS.
+enum CSSOrigin { CSS_ORIGIN_AUTHOR, CSS_ORIGIN_USER };
+// static const CSSOrigin CSS_ORIGIN_LAST = CSS_ORIGIN_USER;
+
+}  // namespace extensions
+
+// namespace extension_misc {
+
+// // Matches chrome.tabs.TAB_ID_NONE.
+// const int kUnknownTabId = -1;
+
+// // Matches chrome.windows.WINDOW_ID_NONE.
+// const int kUnknownWindowId = -1;
+
+// // Matches chrome.windows.WINDOW_ID_CURRENT.
+// const int kCurrentWindowId = -2;
+
+// enum ExtensionIcons {
+//   EXTENSION_ICON_GIGANTOR = 512,
+//   EXTENSION_ICON_EXTRA_LARGE = 256,
+//   EXTENSION_ICON_LARGE = 128,
+//   EXTENSION_ICON_MEDIUM = 48,
+//   EXTENSION_ICON_SMALL = 32,
+//   EXTENSION_ICON_SMALLISH = 24,
+//   EXTENSION_ICON_BITTY = 16,
+//   EXTENSION_ICON_INVALID = 0,
+// };
+
+// // The extension id of the ChromeVox extension.
+// extern const char kChromeVoxExtensionId[];
+
+// // The extension id of the feedback component extension.
+// extern const char kFeedbackExtensionId[];
+
+// // The extension id of the PDF extension.
+// extern const char kPdfExtensionId[];
+
+// // The extension id of the Office Viewer component extension.
+// extern const char kQuickOfficeComponentExtensionId[];
+
+// // The extension id of the Office Viewer extension on the internal webstore.
+// extern const char kQuickOfficeInternalExtensionId[];
+
+// // The extension id of the Office Viewer extension.
+// extern const char kQuickOfficeExtensionId[];
+
+// // The extension id used for testing mimeHandlerPrivate.
+// extern const char kMimeHandlerPrivateTestExtensionId[];
+
+// // The extension id of the Camera application.
+// extern const char kCameraAppId[];
+
+// // The extension id of the devoloper version of Camera application.
+// extern const char kCameraAppDevId[];
+
+// // The extension id of the Chrome component application.
+// extern const char kChromeAppId[];
+
+// // Fake extension ID for the Lacros chrome browser application.
+// extern const char kLacrosAppId[];
+
+// // The extension id of the Files Manager application.
+// extern const char kFilesManagerAppId[];
+
+// // The extension id of the Calculator application.
+// extern const char kCalculatorAppId[];
+
+// // The extension id of the demo Calendar application.
+// extern const char kCalendarDemoAppId[];
+
+// // The extension id of the GMail application.
+// extern const char kGMailAppId[];
+
+// // The extension id of the demo Google Docs application.
+// extern const char kGoogleDocsDemoAppId[];
+
+// // The extension id of the Google Drive application.
+// extern const char kGoogleDriveAppId[];
+
+// // The extension id of the demo Google Sheets application.
+// extern const char kGoogleSheetsDemoAppId[];
+
+// // The extension id of the demo Google Slides application.
+// extern const char kGoogleSlidesDemoAppId[];
+
+// // The extension id of the Google Keep application.
+// extern const char kGoogleKeepAppId[];
+
+// // The extension id of the Youtube application.
+// extern const char kYoutubeAppId[];
+
+// // The extension id of the genius (Get Help) app.
+// extern const char kGeniusAppId[];
+
+// #if defined(OS_CHROMEOS)
+// // The extension id of the default Demo Mode Highlights app.
+// extern const char kHighlightsAppId[];
+
+// // The extension id of the eve Demo Mode Highlights app.
+// extern const char kHighlightsEveAppId[];
+
+// // The extension id of the nocturne Demo Mode Highlights app.
+// extern const char kHighlightsNocturneAppId[];
+
+// // The extension id of the atlas Demo Mode Highlights app.
+// extern const char kHighlightsAtlasAppId[];
+
+// // The extension id of the default Demo Mode screensaver app.
+// extern const char kScreensaverAppId[];
+
+// // The extension id of the eve Demo Mode screensaver app.
+// extern const char kScreensaverEveAppId[];
+
+// // The extension id of the nocturne Demo Mode screensaver app.
+// extern const char kScreensaverNocturneAppId[];
+
+// // The extension id of the atlas Demo Mode screensaver app.
+// extern const char kScreensaverAtlasAppId[];
+
+// // The extension id of the kukui Demo Mode screensaver app.
+// extern const char kScreensaverKukuiAppId[];
+
+// // The id of the testing extension allowed in the signin profile.
+// extern const char kSigninProfileTestExtensionId[];
+
+// // Returns true if this app is part of the "system UI". Generally this is UI
+// // that that on other operating systems would be considered part of the OS,
+// // for example the file manager.
+// bool IsSystemUIApp(base::StringPiece extension_id);
+// #endif
+
+// // The extension id for the production version of Hangouts.
+// extern const char kProdHangoutsExtensionId[];
+
+// // Extension ids used by Hangouts.
+// extern const char* const kHangoutsExtensionIds[6];
+
+// // Error message when enterprise policy blocks scripting of webpage.
+// extern const char kPolicyBlockedScripting[];
+
+// // The default block size for hashing used in content verification.
+// extern const int kContentVerificationDefaultBlockSize;
+
+// // The minimum severity of a log or error in order to report it to the browser.
+// extern const logging::LogSeverity kMinimumSeverityToReportError;
+
+// // The minimum channel where Service Worker based extensions can run.
+// constexpr version_info::Channel kMinChannelForServiceWorkerBasedExtension =
+//     version_info::Channel::DEV;
+
+// // IDs for the Media Router Component Extension.
+// extern const char kCastExtensionIdRelease[];
+// extern const char kCastExtensionIdDev[];
+
+// }  // namespace extension_misc
+
+#endif  // USERSCRIPTS_COMMON_CONSTANTS_H_
diff --git a/components/user_scripts/common/error_utils.cc b/components/user_scripts/common/error_utils.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/error_utils.cc
@@ -0,0 +1,85 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "error_utils.h"
+
+#include <initializer_list>
+
+#include "base/check_op.h"
+#include "base/strings/string_tokenizer.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+
+namespace user_scripts {
+
+namespace {
+
+std::string FormatErrorMessageInternal(
+    base::StringPiece format,
+    std::initializer_list<base::StringPiece> args) {
+  std::string format_str = format.as_string();
+  base::StringTokenizer tokenizer(format_str, "*");
+  tokenizer.set_options(base::StringTokenizer::RETURN_DELIMS);
+
+  std::vector<base::StringPiece> result_pieces;
+  auto* args_it = args.begin();
+  while (tokenizer.GetNext()) {
+    if (!tokenizer.token_is_delim()) {
+      result_pieces.push_back(tokenizer.token_piece());
+      continue;
+    }
+
+    CHECK_NE(args_it, args.end())
+        << "More placeholders (*) than substitutions.";
+
+    // Substitute the argument.
+    result_pieces.push_back(*args_it);
+    args_it++;
+  }
+
+  // Not all substitutions were consumed.
+  CHECK_EQ(args_it, args.end()) << "Fewer placeholders (*) than substitutions.";
+
+  return base::JoinString(result_pieces, "" /* separator */);
+}
+
+}  // namespace
+
+std::string ErrorUtils::FormatErrorMessage(base::StringPiece format,
+                                           base::StringPiece s1) {
+  return FormatErrorMessageInternal(format, {s1});
+}
+
+// std::string ErrorUtils::FormatErrorMessage(base::StringPiece format,
+//                                            base::StringPiece s1,
+//                                            base::StringPiece s2) {
+//   return FormatErrorMessageInternal(format, {s1, s2});
+// }
+
+// std::string ErrorUtils::FormatErrorMessage(base::StringPiece format,
+//                                            base::StringPiece s1,
+//                                            base::StringPiece s2,
+//                                            base::StringPiece s3) {
+//   return FormatErrorMessageInternal(format, {s1, s2, s3});
+// }
+
+// base::string16 ErrorUtils::FormatErrorMessageUTF16(base::StringPiece format,
+//                                                    base::StringPiece s1) {
+//   return base::UTF8ToUTF16(FormatErrorMessageInternal(format, {s1}));
+// }
+
+// base::string16 ErrorUtils::FormatErrorMessageUTF16(base::StringPiece format,
+//                                                    base::StringPiece s1,
+//                                                    base::StringPiece s2) {
+//   return base::UTF8ToUTF16(FormatErrorMessageInternal(format, {s1, s2}));
+// }
+
+// base::string16 ErrorUtils::FormatErrorMessageUTF16(base::StringPiece format,
+//                                                    base::StringPiece s1,
+//                                                    base::StringPiece s2,
+//                                                    base::StringPiece s3) {
+//   return base::UTF8ToUTF16(FormatErrorMessageInternal(format, {s1, s2, s3}));
+// }
+
+}  // namespace extensions
diff --git a/components/user_scripts/common/error_utils.h b/components/user_scripts/common/error_utils.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/error_utils.h
@@ -0,0 +1,45 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_COMMON_ERROR_UTILS_H_
+#define EXTENSIONS_COMMON_ERROR_UTILS_H_
+
+#include <string>
+
+#include "base/strings/string16.h"
+#include "base/strings/string_piece.h"
+
+namespace user_scripts {
+
+class ErrorUtils {
+ public:
+  // Creates an error messages from a pattern.
+   static std::string FormatErrorMessage(base::StringPiece format,
+                                         base::StringPiece s1);
+
+//   static std::string FormatErrorMessage(base::StringPiece format,
+//                                         base::StringPiece s1,
+//                                         base::StringPiece s2);
+
+//   static std::string FormatErrorMessage(base::StringPiece format,
+//                                         base::StringPiece s1,
+//                                         base::StringPiece s2,
+//                                         base::StringPiece s3);
+
+//   static base::string16 FormatErrorMessageUTF16(base::StringPiece format,
+//                                                 base::StringPiece s1);
+
+//   static base::string16 FormatErrorMessageUTF16(base::StringPiece format,
+//                                                 base::StringPiece s1,
+//                                                 base::StringPiece s2);
+
+//   static base::string16 FormatErrorMessageUTF16(base::StringPiece format,
+//                                                 base::StringPiece s1,
+//                                                 base::StringPiece s2,
+//                                                 base::StringPiece s3);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_COMMON_ERROR_UTILS_H_
diff --git a/components/user_scripts/common/extension_id.h b/components/user_scripts/common/extension_id.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/extension_id.h
@@ -0,0 +1,23 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_COMMON_EXTENSION_ID_H_
+#define EXTENSIONS_COMMON_EXTENSION_ID_H_
+
+#include <set>
+#include <string>
+#include <vector>
+
+namespace user_scripts {
+
+// // If valid, uniquely identifies an Extension using 32 characters from the
+// // alphabet 'a'-'p'.
+// using ExtensionId = std::string;
+
+// using ExtensionIdList = std::vector<ExtensionId>;
+// using ExtensionIdSet = std::set<ExtensionId>;
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_COMMON_EXTENSION_ID_H_
diff --git a/components/user_scripts/common/extension_message_generator.cc b/components/user_scripts/common/extension_message_generator.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/extension_message_generator.cc
@@ -0,0 +1,29 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Get basic type definitions.
+#define IPC_MESSAGE_IMPL
+#include "components/user_scripts/common/extension_message_generator.h"
+
+// Generate constructors.
+#include "ipc/struct_constructor_macros.h"
+#include "components/user_scripts/common/extension_message_generator.h"
+
+// Generate param traits write methods.
+#include "ipc/param_traits_write_macros.h"
+namespace IPC {
+#include "components/user_scripts/common/extension_message_generator.h"
+}  // namespace IPC
+
+// Generate param traits read methods.
+#include "ipc/param_traits_read_macros.h"
+namespace IPC {
+#include "components/user_scripts/common/extension_message_generator.h"
+}  // namespace IPC
+
+// Generate param traits log methods.
+#include "ipc/param_traits_log_macros.h"
+namespace IPC {
+#include "components/user_scripts/common/extension_message_generator.h"
+}  // namespace IPC
diff --git a/components/user_scripts/common/extension_message_generator.h b/components/user_scripts/common/extension_message_generator.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/extension_message_generator.h
@@ -0,0 +1,16 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Multiply-included file, hence no include guard.
+
+#undef EXTENSIONS_COMMON_EXTENSION_MESSAGES_H_
+#include "extension_messages.h"
+#ifndef EXTENSIONS_COMMON_EXTENSION_MESSAGES_H_
+#error "Failed to include header extension_messages.h"
+#endif
+// #undef EXTENSIONS_COMMON_GUEST_VIEW_EXTENSIONS_GUEST_VIEW_MESSAGES_H_
+// #include "extensions/common/guest_view/extensions_guest_view_messages.h"
+// #ifndef EXTENSIONS_COMMON_GUEST_VIEW_EXTENSIONS_GUEST_VIEW_MESSAGES_H_
+// #error "Failed to include header extensions_guest_view_messages.h"
+// #endif
diff --git a/components/user_scripts/common/extension_messages.cc b/components/user_scripts/common/extension_messages.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/extension_messages.cc
@@ -0,0 +1,358 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "extension_messages.h"
+
+#include <stddef.h>
+
+#include <memory>
+#include <utility>
+
+#include "content/public/common/common_param_traits.h"
+// #include "extensions/common/extension.h"
+// #include "extensions/common/manifest.h"
+// #include "extensions/common/manifest_handler.h"
+// #include "extensions/common/permissions/permissions_data.h"
+// #include "extensions/common/permissions/permissions_info.h"
+
+// using extensions::ActivationSequence;
+// using extensions::APIPermission;
+// using extensions::APIPermissionInfo;
+// using extensions::APIPermissionSet;
+// using extensions::Extension;
+// using extensions::Manifest;
+// using extensions::ManifestHandler;
+// using extensions::ManifestPermission;
+// using extensions::ManifestPermissionSet;
+// using extensions::PermissionSet;
+// using extensions::URLPatternSet;
+
+// ExtensionMsg_PermissionSetStruct::ExtensionMsg_PermissionSetStruct() {
+// }
+
+// ExtensionMsg_PermissionSetStruct::ExtensionMsg_PermissionSetStruct(
+//     const PermissionSet& permissions)
+//     : apis(permissions.apis().Clone()),
+//       manifest_permissions(permissions.manifest_permissions().Clone()),
+//       explicit_hosts(permissions.explicit_hosts().Clone()),
+//       scriptable_hosts(permissions.scriptable_hosts().Clone()) {}
+
+// ExtensionMsg_PermissionSetStruct::~ExtensionMsg_PermissionSetStruct() {}
+
+// ExtensionMsg_PermissionSetStruct::ExtensionMsg_PermissionSetStruct(
+//     ExtensionMsg_PermissionSetStruct&& other) = default;
+
+// ExtensionMsg_PermissionSetStruct& ExtensionMsg_PermissionSetStruct::operator=(
+//     ExtensionMsg_PermissionSetStruct&& other) = default;
+
+// std::unique_ptr<const PermissionSet>
+// ExtensionMsg_PermissionSetStruct::ToPermissionSet() const {
+//   // TODO(devlin): Make this destructive so we can std::move() the members.
+//   return std::make_unique<PermissionSet>(
+//       apis.Clone(), manifest_permissions.Clone(), explicit_hosts.Clone(),
+//       scriptable_hosts.Clone());
+// }
+
+// ExtensionMsg_Loaded_Params::ExtensionMsg_Loaded_Params()
+//     : location(Manifest::INVALID_LOCATION),
+//       creation_flags(Extension::NO_FLAGS) {}
+
+// ExtensionMsg_Loaded_Params::~ExtensionMsg_Loaded_Params() {}
+
+// ExtensionMsg_Loaded_Params::ExtensionMsg_Loaded_Params(
+//     const Extension* extension,
+//     bool include_tab_permissions,
+//     base::Optional<ActivationSequence> worker_activation_sequence)
+//     : manifest(static_cast<base::DictionaryValue&&>(
+//           extension->manifest()->value()->Clone())),
+//       location(extension->location()),
+//       path(extension->path()),
+//       active_permissions(extension->permissions_data()->active_permissions()),
+//       withheld_permissions(
+//           extension->permissions_data()->withheld_permissions()),
+//       policy_blocked_hosts(
+//           extension->permissions_data()->policy_blocked_hosts().Clone()),
+//       policy_allowed_hosts(
+//           extension->permissions_data()->policy_allowed_hosts().Clone()),
+//       uses_default_policy_blocked_allowed_hosts(
+//           extension->permissions_data()->UsesDefaultPolicyHostRestrictions()),
+//       id(extension->id()),
+//       worker_activation_sequence(worker_activation_sequence),
+//       creation_flags(extension->creation_flags()) {
+//   if (include_tab_permissions) {
+//     for (const auto& pair :
+//          extension->permissions_data()->tab_specific_permissions()) {
+//       tab_specific_permissions[pair.first] =
+//           ExtensionMsg_PermissionSetStruct(*pair.second);
+//     }
+//   }
+// }
+
+// ExtensionMsg_Loaded_Params::ExtensionMsg_Loaded_Params(
+//     ExtensionMsg_Loaded_Params&& other) = default;
+// ExtensionMsg_Loaded_Params& ExtensionMsg_Loaded_Params::operator=(
+//     ExtensionMsg_Loaded_Params&& other) = default;
+
+// scoped_refptr<Extension> ExtensionMsg_Loaded_Params::ConvertToExtension(
+//     const int context_id,
+//     std::string* error) const {
+//   // We pass in the |id| to the create call because it will save work in the
+//   // normal case, and because in tests, extensions may not have paths or keys,
+//   // but it's important to retain the same id.
+//   scoped_refptr<Extension> extension =
+//       Extension::Create(path, location, manifest, creation_flags, id, error);
+//   if (extension.get()) {
+//     const extensions::PermissionsData* permissions_data =
+//         extension->permissions_data();
+//     permissions_data->SetPermissions(active_permissions.ToPermissionSet(),
+//                                      withheld_permissions.ToPermissionSet());
+//     if (uses_default_policy_blocked_allowed_hosts) {
+//       permissions_data->SetUsesDefaultHostRestrictions(context_id);
+//     } else {
+//       permissions_data->SetPolicyHostRestrictions(policy_blocked_hosts,
+//                                                   policy_allowed_hosts);
+//     }
+//     for (const auto& pair : tab_specific_permissions) {
+//       permissions_data->UpdateTabSpecificPermissions(
+//           pair.first, *pair.second.ToPermissionSet());
+//     }
+//   }
+//   return extension;
+// }
+
+namespace IPC {
+
+// void ParamTraits<URLPattern>::Write(base::Pickle* m, const param_type& p) {
+//   WriteParam(m, p.valid_schemes());
+//   WriteParam(m, p.GetAsString());
+// }
+
+// bool ParamTraits<URLPattern>::Read(const base::Pickle* m,
+//                                    base::PickleIterator* iter,
+//                                    param_type* p) {
+//   int valid_schemes;
+//   std::string spec;
+//   if (!ReadParam(m, iter, &valid_schemes) ||
+//       !ReadParam(m, iter, &spec))
+//     return false;
+
+//   // TODO(jstritar): We don't want the URLPattern to fail parsing when the
+//   // scheme is invalid. Instead, the pattern should parse but it should not
+//   // match the invalid patterns. We get around this by setting the valid
+//   // schemes after parsing the pattern. Update these method calls once we can
+//   // ignore scheme validation with URLPattern parse options. crbug.com/90544
+//   p->SetValidSchemes(URLPattern::SCHEME_ALL);
+//   URLPattern::ParseResult result = p->Parse(spec);
+//   p->SetValidSchemes(valid_schemes);
+//   return URLPattern::ParseResult::kSuccess == result;
+// }
+
+// void ParamTraits<URLPattern>::Log(const param_type& p, std::string* l) {
+//   LogParam(p.GetAsString(), l);
+// }
+
+// void ParamTraits<URLPatternSet>::Write(base::Pickle* m, const param_type& p) {
+//   WriteParam(m, p.patterns());
+// }
+
+// bool ParamTraits<URLPatternSet>::Read(const base::Pickle* m,
+//                                       base::PickleIterator* iter,
+//                                       param_type* p) {
+//   std::set<URLPattern> patterns;
+//   if (!ReadParam(m, iter, &patterns))
+//     return false;
+
+//   for (auto i = patterns.begin(); i != patterns.end(); ++i)
+//     p->AddPattern(*i);
+//   return true;
+// }
+
+// void ParamTraits<URLPatternSet>::Log(const param_type& p, std::string* l) {
+//   LogParam(p.patterns(), l);
+// }
+
+// void ParamTraits<APIPermission::ID>::Write(base::Pickle* m,
+//                                            const param_type& p) {
+//   WriteParam(m, static_cast<int>(p));
+// }
+
+// bool ParamTraits<APIPermission::ID>::Read(const base::Pickle* m,
+//                                           base::PickleIterator* iter,
+//                                           param_type* p) {
+//   int api_id = -2;
+//   if (!ReadParam(m, iter, &api_id))
+//     return false;
+
+//   *p = static_cast<APIPermission::ID>(api_id);
+//   return true;
+// }
+
+// void ParamTraits<APIPermission::ID>::Log(
+//     const param_type& p, std::string* l) {
+//   LogParam(static_cast<int>(p), l);
+// }
+
+// void ParamTraits<APIPermissionSet>::Write(base::Pickle* m,
+//                                           const param_type& p) {
+//   APIPermissionSet::const_iterator it = p.begin();
+//   const APIPermissionSet::const_iterator end = p.end();
+//   WriteParam(m, static_cast<uint32_t>(p.size()));
+//   for (; it != end; ++it) {
+//     WriteParam(m, it->id());
+//     it->Write(m);
+//   }
+// }
+
+// bool ParamTraits<APIPermissionSet>::Read(const base::Pickle* m,
+//                                          base::PickleIterator* iter,
+//                                          param_type* r) {
+//   uint32_t size;
+//   if (!ReadParam(m, iter, &size))
+//     return false;
+//   for (uint32_t i = 0; i < size; ++i) {
+//     APIPermission::ID id;
+//     if (!ReadParam(m, iter, &id))
+//       return false;
+//     const APIPermissionInfo* permission_info =
+//       extensions::PermissionsInfo::GetInstance()->GetByID(id);
+//     if (!permission_info)
+//       return false;
+//     std::unique_ptr<APIPermission> p(permission_info->CreateAPIPermission());
+//     if (!p->Read(m, iter))
+//       return false;
+//     r->insert(std::move(p));
+//   }
+//   return true;
+// }
+
+// void ParamTraits<APIPermissionSet>::Log(
+//     const param_type& p, std::string* l) {
+//   LogParam(p.map(), l);
+// }
+
+// void ParamTraits<ManifestPermissionSet>::Write(base::Pickle* m,
+//                                                const param_type& p) {
+//   ManifestPermissionSet::const_iterator it = p.begin();
+//   const ManifestPermissionSet::const_iterator end = p.end();
+//   WriteParam(m, static_cast<uint32_t>(p.size()));
+//   for (; it != end; ++it) {
+//     WriteParam(m, it->name());
+//     it->Write(m);
+//   }
+// }
+
+// bool ParamTraits<ManifestPermissionSet>::Read(const base::Pickle* m,
+//                                               base::PickleIterator* iter,
+//                                               param_type* r) {
+//   uint32_t size;
+//   if (!ReadParam(m, iter, &size))
+//     return false;
+//   for (uint32_t i = 0; i < size; ++i) {
+//     std::string name;
+//     if (!ReadParam(m, iter, &name))
+//       return false;
+//     std::unique_ptr<ManifestPermission> p(
+//         ManifestHandler::CreatePermission(name));
+//     if (!p)
+//       return false;
+//     if (!p->Read(m, iter))
+//       return false;
+//     r->insert(std::move(p));
+//   }
+//   return true;
+// }
+
+// void ParamTraits<ManifestPermissionSet>::Log(
+//     const param_type& p, std::string* l) {
+//   LogParam(p.map(), l);
+// }
+
+void ParamTraits<HostID>::Write(base::Pickle* m, const param_type& p) {
+  WriteParam(m, p.type());
+  WriteParam(m, p.id());
+}
+
+bool ParamTraits<HostID>::Read(const base::Pickle* m,
+                               base::PickleIterator* iter,
+                               param_type* r) {
+  HostID::HostType type;
+  std::string id;
+  if (!ReadParam(m, iter, &type))
+    return false;
+  if (!ReadParam(m, iter, &id))
+    return false;
+  *r = HostID(type, id);
+  return true;
+}
+
+void ParamTraits<HostID>::Log(
+    const param_type& p, std::string* l) {
+  LogParam(p.type(), l);
+  LogParam(p.id(), l);
+}
+
+// void ParamTraits<ExtensionMsg_PermissionSetStruct>::Write(base::Pickle* m,
+//                                                           const param_type& p) {
+//   WriteParam(m, p.apis);
+//   WriteParam(m, p.manifest_permissions);
+//   WriteParam(m, p.explicit_hosts);
+//   WriteParam(m, p.scriptable_hosts);
+// }
+
+// bool ParamTraits<ExtensionMsg_PermissionSetStruct>::Read(
+//     const base::Pickle* m,
+//     base::PickleIterator* iter,
+//     param_type* p) {
+//   return ReadParam(m, iter, &p->apis) &&
+//          ReadParam(m, iter, &p->manifest_permissions) &&
+//          ReadParam(m, iter, &p->explicit_hosts) &&
+//          ReadParam(m, iter, &p->scriptable_hosts);
+// }
+
+// void ParamTraits<ExtensionMsg_PermissionSetStruct>::Log(const param_type& p,
+//                                                         std::string* l) {
+//   LogParam(p.apis, l);
+//   LogParam(p.manifest_permissions, l);
+//   LogParam(p.explicit_hosts, l);
+//   LogParam(p.scriptable_hosts, l);
+// }
+
+// void ParamTraits<ExtensionMsg_Loaded_Params>::Write(base::Pickle* m,
+//                                                     const param_type& p) {
+//   WriteParam(m, p.location);
+//   WriteParam(m, p.path);
+//   WriteParam(m, p.manifest);
+//   WriteParam(m, p.creation_flags);
+//   WriteParam(m, p.id);
+//   WriteParam(m, p.active_permissions);
+//   WriteParam(m, p.withheld_permissions);
+//   WriteParam(m, p.tab_specific_permissions);
+//   WriteParam(m, p.policy_blocked_hosts);
+//   WriteParam(m, p.policy_allowed_hosts);
+//   WriteParam(m, p.uses_default_policy_blocked_allowed_hosts);
+//   WriteParam(m, p.worker_activation_sequence);
+// }
+
+// bool ParamTraits<ExtensionMsg_Loaded_Params>::Read(const base::Pickle* m,
+//                                                    base::PickleIterator* iter,
+//                                                    param_type* p) {
+//   p->manifest.Clear();
+//   return ReadParam(m, iter, &p->location) && ReadParam(m, iter, &p->path) &&
+//          ReadParam(m, iter, &p->manifest) &&
+//          ReadParam(m, iter, &p->creation_flags) && ReadParam(m, iter, &p->id) &&
+//          ReadParam(m, iter, &p->active_permissions) &&
+//          ReadParam(m, iter, &p->withheld_permissions) &&
+//          ReadParam(m, iter, &p->tab_specific_permissions) &&
+//          ReadParam(m, iter, &p->policy_blocked_hosts) &&
+//          ReadParam(m, iter, &p->policy_allowed_hosts) &&
+//          ReadParam(m, iter, &p->uses_default_policy_blocked_allowed_hosts) &&
+//          ReadParam(m, iter, &p->worker_activation_sequence);
+// }
+
+// void ParamTraits<ExtensionMsg_Loaded_Params>::Log(const param_type& p,
+//                                                   std::string* l) {
+//   l->append(p.id);
+// }
+
+}  // namespace IPC
diff --git a/components/user_scripts/common/extension_messages.h b/components/user_scripts/common/extension_messages.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/extension_messages.h
@@ -0,0 +1,1128 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// IPC messages for extensions.
+
+#ifndef EXTENSIONS_COMMON_EXTENSION_MESSAGES_H_
+#define EXTENSIONS_COMMON_EXTENSION_MESSAGES_H_
+
+#include <stdint.h>
+
+#include <map>
+#include <memory>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/memory/read_only_shared_memory_region.h"
+#include "base/values.h"
+#include "content/public/common/common_param_traits.h"
+//#include "content/public/common/socket_permission_request.h"
+// #include "extensions/common/activation_sequence.h"
+// #include "extensions/common/api/messaging/message.h"
+// #include "extensions/common/api/messaging/messaging_endpoint.h"
+// #include "extensions/common/api/messaging/port_context.h"
+// #include "extensions/common/api/messaging/port_id.h"
+// #include "extensions/common/common_param_traits.h"
+#include "constants.h"
+//#include "extensions/common/draggable_region.h"
+//#include "extensions/common/event_filtering_info.h"
+//#include "extensions/common/extension.h"
+//#include "extensions/common/extensions_client.h"
+#include "host_id.h"
+//#include "extensions/common/permissions/permission_set.h"
+//#include "extensions/common/permissions/socket_permission_data.h"
+//#include "extensions/common/permissions/usb_device_permission_data.h"
+//#include "extensions/common/stack_frame.h"
+//#include "extensions/common/url_pattern.h"
+//#include "extensions/common/url_pattern_set.h"
+//#include "extensions/common/user_script.h"
+//#include "extensions/common/view_type.h"
+#include "ipc/ipc_message_macros.h"
+//#include "ui/accessibility/ax_param_traits.h"
+#include "url/gurl.h"
+#include "url/origin.h"
+
+#define IPC_MESSAGE_START ExtensionMsgStart
+
+// IPC_ENUM_TRAITS_MAX_VALUE(extensions::CSSOrigin, extensions::CSS_ORIGIN_LAST)
+
+// IPC_ENUM_TRAITS_MAX_VALUE(extensions::ViewType, extensions::VIEW_TYPE_LAST)
+// IPC_ENUM_TRAITS_MAX_VALUE(content::SocketPermissionRequest::OperationType,
+//                           content::SocketPermissionRequest::OPERATION_TYPE_LAST)
+
+// IPC_ENUM_TRAITS_MAX_VALUE(extensions::UserScript::InjectionType,
+//                           extensions::UserScript::INJECTION_TYPE_LAST)
+
+// IPC_ENUM_TRAITS_MAX_VALUE(extensions::UserScript::RunLocation,
+//                           extensions::UserScript::RUN_LOCATION_LAST - 1)
+
+// IPC_ENUM_TRAITS_MAX_VALUE(extensions::MessagingEndpoint::Type,
+//                           extensions::MessagingEndpoint::Type::kLast)
+
+IPC_ENUM_TRAITS_MAX_VALUE(HostID::HostType, HostID::HOST_TYPE_LAST)
+
+// // Parameters structure for ExtensionHostMsg_AddAPIActionToActivityLog and
+// // ExtensionHostMsg_AddEventToActivityLog.
+// IPC_STRUCT_BEGIN(ExtensionHostMsg_APIActionOrEvent_Params)
+//   // API name.
+//   IPC_STRUCT_MEMBER(std::string, api_call)
+
+//   // List of arguments.
+//   IPC_STRUCT_MEMBER(base::ListValue, arguments)
+
+//   // Extra logging information.
+//   IPC_STRUCT_MEMBER(std::string, extra)
+// IPC_STRUCT_END()
+
+// // Parameters structure for ExtensionHostMsg_AddDOMActionToActivityLog.
+// IPC_STRUCT_BEGIN(ExtensionHostMsg_DOMAction_Params)
+//   // URL of the page.
+//   IPC_STRUCT_MEMBER(GURL, url)
+
+//   // Title of the page.
+//   IPC_STRUCT_MEMBER(base::string16, url_title)
+
+//   // API name.
+//   IPC_STRUCT_MEMBER(std::string, api_call)
+
+//   // List of arguments.
+//   IPC_STRUCT_MEMBER(base::ListValue, arguments)
+
+//   // Type of DOM API call.
+//   IPC_STRUCT_MEMBER(int, call_type)
+// IPC_STRUCT_END()
+
+// // Parameters structure for ExtensionHostMsg_Request.
+// IPC_STRUCT_BEGIN(ExtensionHostMsg_Request_Params)
+//   // Message name.
+//   IPC_STRUCT_MEMBER(std::string, name)
+
+//   // List of message arguments.
+//   IPC_STRUCT_MEMBER(base::ListValue, arguments)
+
+//   // Extension ID this request was sent from. This can be empty, in the case
+//   // where we expose APIs to normal web pages using the extension function
+//   // system.
+//   IPC_STRUCT_MEMBER(std::string, extension_id)
+
+//   // URL of the frame the request was sent from. This isn't necessarily an
+//   // extension url. Extension requests can also originate from content scripts,
+//   // in which case extension_id will indicate the ID of the associated
+//   // extension. Or, they can originate from hosted apps or normal web pages.
+//   IPC_STRUCT_MEMBER(GURL, source_url)
+
+//   // Unique request id to match requests and responses.
+//   IPC_STRUCT_MEMBER(int, request_id)
+
+//   // True if request has a callback specified.
+//   IPC_STRUCT_MEMBER(bool, has_callback)
+
+//   // True if request is executed in response to an explicit user gesture.
+//   IPC_STRUCT_MEMBER(bool, user_gesture)
+
+//   // If this API call is for a service worker, then this is the worker thread
+//   // id. Otherwise, this is kMainThreadId.
+//   IPC_STRUCT_MEMBER(int, worker_thread_id)
+
+//   // If this API call is for a service worker, then this is the service
+//   // worker version id. Otherwise, this is set to
+//   // blink::mojom::kInvalidServiceWorkerVersionId.
+//   IPC_STRUCT_MEMBER(int64_t, service_worker_version_id)
+// IPC_STRUCT_END()
+
+// IPC_STRUCT_BEGIN(ExtensionMsg_DispatchEvent_Params)
+//   // If this event is for a service worker, then this is the worker thread
+//   // id. Otherwise, this is 0.
+//   IPC_STRUCT_MEMBER(int, worker_thread_id)
+
+//   // The id of the extension to dispatch the event to.
+//   IPC_STRUCT_MEMBER(std::string, extension_id)
+
+//   // The name of the event to dispatch.
+//   IPC_STRUCT_MEMBER(std::string, event_name)
+
+//   // The id of the event for use in the EventAck response message.
+//   IPC_STRUCT_MEMBER(int, event_id)
+
+//   // Whether or not the event is part of a user gesture.
+//   IPC_STRUCT_MEMBER(bool, is_user_gesture)
+
+//   // Additional filtering info for the event.
+//   IPC_STRUCT_MEMBER(extensions::EventFilteringInfo, filtering_info)
+// IPC_STRUCT_END()
+
+// // Allows an extension to execute code in a tab.
+// IPC_STRUCT_BEGIN(ExtensionMsg_ExecuteCode_Params)
+//   // The extension API request id, for responding.
+//   IPC_STRUCT_MEMBER(int, request_id)
+
+//   // The ID of the requesting injection host.
+//   IPC_STRUCT_MEMBER(HostID, host_id)
+
+//   // Whether the code is JavaScript or CSS.
+//   IPC_STRUCT_MEMBER(bool, is_javascript)
+
+//   // String of code to execute.
+//   IPC_STRUCT_MEMBER(std::string, code)
+
+//   // The webview guest source who calls to execute code.
+//   IPC_STRUCT_MEMBER(GURL, webview_src)
+
+//   // Whether to inject into about:blank (sub)frames.
+//   IPC_STRUCT_MEMBER(bool, match_about_blank)
+
+//   // When to inject the code.
+//   IPC_STRUCT_MEMBER(extensions::UserScript::RunLocation, run_at)
+
+//   // Whether the request is coming from a <webview>.
+//   IPC_STRUCT_MEMBER(bool, is_web_view)
+
+//   // Whether the caller is interested in the result value. Manifest-declared
+//   // content scripts and executeScript() calls without a response callback
+//   // are examples of when this will be false.
+//   IPC_STRUCT_MEMBER(bool, wants_result)
+
+//   // The URL of the script that was injected, if any.
+//   IPC_STRUCT_MEMBER(GURL, script_url)
+
+//   // Whether the code to be executed should be associated with a user gesture.
+//   IPC_STRUCT_MEMBER(bool, user_gesture)
+
+//   // The origin of the CSS.
+//   IPC_STRUCT_MEMBER(base::Optional<extensions::CSSOrigin>, css_origin)
+
+//   // The autogenerated key for the CSS injection.
+//   IPC_STRUCT_MEMBER(base::Optional<std::string>, injection_key)
+// IPC_STRUCT_END()
+
+// // Struct containing information about the sender of connect() calls that
+// // originate from a tab.
+// IPC_STRUCT_BEGIN(ExtensionMsg_TabConnectionInfo)
+//   // The tab from where the connection was created.
+//   IPC_STRUCT_MEMBER(base::DictionaryValue, tab)
+
+//   // The ID of the frame that initiated the connection.
+//   // 0 if main frame, positive otherwise. -1 if not initiated from a frame.
+//   IPC_STRUCT_MEMBER(int, frame_id)
+// IPC_STRUCT_END()
+
+// // Struct containing information about the destination of tab.connect().
+// IPC_STRUCT_BEGIN(ExtensionMsg_TabTargetConnectionInfo)
+//   // The destination tab's ID.
+//   IPC_STRUCT_MEMBER(int, tab_id)
+
+//   // Frame ID of the destination. -1 for all frames, 0 for main frame and
+//   // positive if the destination is a specific child frame.
+//   IPC_STRUCT_MEMBER(int, frame_id)
+// IPC_STRUCT_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::MessagingEndpoint)
+//   IPC_STRUCT_TRAITS_MEMBER(type)
+//   IPC_STRUCT_TRAITS_MEMBER(extension_id)
+//   IPC_STRUCT_TRAITS_MEMBER(native_app_name)
+// IPC_STRUCT_TRAITS_END()
+
+// // Struct containing the data for external connections to extensions. Used to
+// // handle the IPCs initiated by both connect() and onConnect().
+// IPC_STRUCT_BEGIN(ExtensionMsg_ExternalConnectionInfo)
+//   // The ID of the extension that is the target of the request.
+//   IPC_STRUCT_MEMBER(std::string, target_id)
+
+//   // Specifies the type and the ID of the endpoint that initiated the request.
+//   IPC_STRUCT_MEMBER(extensions::MessagingEndpoint, source_endpoint)
+
+//   // The URL of the frame that initiated the request.
+//   IPC_STRUCT_MEMBER(GURL, source_url)
+
+//   // The origin of the object that initiated the request.
+//   IPC_STRUCT_MEMBER(base::Optional<url::Origin>, source_origin)
+
+//   // The process ID of the webview that initiated the request.
+//   IPC_STRUCT_MEMBER(int, guest_process_id)
+
+//   // The render frame routing ID of the webview that initiated the request.
+//   IPC_STRUCT_MEMBER(int, guest_render_frame_routing_id)
+// IPC_STRUCT_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::DraggableRegion)
+//   IPC_STRUCT_TRAITS_MEMBER(draggable)
+//   IPC_STRUCT_TRAITS_MEMBER(bounds)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(content::SocketPermissionRequest)
+//   IPC_STRUCT_TRAITS_MEMBER(type)
+//   IPC_STRUCT_TRAITS_MEMBER(host)
+//   IPC_STRUCT_TRAITS_MEMBER(port)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::PortContext::FrameContext)
+//   IPC_STRUCT_TRAITS_MEMBER(routing_id)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::PortContext::WorkerContext)
+//   IPC_STRUCT_TRAITS_MEMBER(thread_id)
+//   IPC_STRUCT_TRAITS_MEMBER(version_id)
+//   IPC_STRUCT_TRAITS_MEMBER(extension_id)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::PortContext)
+//   IPC_STRUCT_TRAITS_MEMBER(frame)
+//   IPC_STRUCT_TRAITS_MEMBER(worker)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::SocketPermissionEntry)
+//   IPC_STRUCT_TRAITS_MEMBER(pattern_)
+//   IPC_STRUCT_TRAITS_MEMBER(match_subdomains_)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::SocketPermissionData)
+//   IPC_STRUCT_TRAITS_MEMBER(entry())
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::StackFrame)
+//   IPC_STRUCT_TRAITS_MEMBER(line_number)
+//   IPC_STRUCT_TRAITS_MEMBER(column_number)
+//   IPC_STRUCT_TRAITS_MEMBER(source)
+//   IPC_STRUCT_TRAITS_MEMBER(function)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::UsbDevicePermissionData)
+//   IPC_STRUCT_TRAITS_MEMBER(vendor_id())
+//   IPC_STRUCT_TRAITS_MEMBER(product_id())
+//   IPC_STRUCT_TRAITS_MEMBER(interface_class())
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::Message)
+//   IPC_STRUCT_TRAITS_MEMBER(data)
+//   IPC_STRUCT_TRAITS_MEMBER(user_gesture)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::PortId)
+//   IPC_STRUCT_TRAITS_MEMBER(context_id)
+//   IPC_STRUCT_TRAITS_MEMBER(port_number)
+//   IPC_STRUCT_TRAITS_MEMBER(is_opener)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::EventFilteringInfo)
+//   IPC_STRUCT_TRAITS_MEMBER(url)
+//   IPC_STRUCT_TRAITS_MEMBER(service_type)
+//   IPC_STRUCT_TRAITS_MEMBER(instance_id)
+//   IPC_STRUCT_TRAITS_MEMBER(window_type)
+//   IPC_STRUCT_TRAITS_MEMBER(window_exposed_by_default)
+// IPC_STRUCT_TRAITS_END()
+
+// // Identifier containing info about a service worker, used in event listener
+// // IPCs.
+// IPC_STRUCT_BEGIN(ServiceWorkerIdentifier)
+//   IPC_STRUCT_MEMBER(GURL, scope)
+//   IPC_STRUCT_MEMBER(int64_t, version_id)
+//   IPC_STRUCT_MEMBER(int, thread_id)
+// IPC_STRUCT_END()
+
+// Singly-included section for custom IPC traits.
+#ifndef INTERNAL_EXTENSIONS_COMMON_EXTENSION_MESSAGES_H_
+#define INTERNAL_EXTENSIONS_COMMON_EXTENSION_MESSAGES_H_
+
+// // IPC_MESSAGE macros choke on extra , in the std::map, when expanding. We need
+// // to typedef it to avoid that.
+// // Substitution map for l10n messages.
+// typedef std::map<std::string, std::string> SubstitutionMap;
+
+// // Map of extensions IDs to the executing script paths.
+// typedef std::map<std::string, std::set<std::string> > ExecutingScriptsMap;
+
+// struct ExtensionMsg_PermissionSetStruct {
+//   ExtensionMsg_PermissionSetStruct();
+//   explicit ExtensionMsg_PermissionSetStruct(
+//       const extensions::PermissionSet& permissions);
+//   ~ExtensionMsg_PermissionSetStruct();
+
+//   ExtensionMsg_PermissionSetStruct(ExtensionMsg_PermissionSetStruct&& other);
+//   ExtensionMsg_PermissionSetStruct& operator=(
+//       ExtensionMsg_PermissionSetStruct&& other);
+
+//   std::unique_ptr<const extensions::PermissionSet> ToPermissionSet() const;
+
+//   extensions::APIPermissionSet apis;
+//   extensions::ManifestPermissionSet manifest_permissions;
+//   extensions::URLPatternSet explicit_hosts;
+//   extensions::URLPatternSet scriptable_hosts;
+
+//   DISALLOW_COPY_AND_ASSIGN(ExtensionMsg_PermissionSetStruct);
+// };
+
+// struct ExtensionMsg_Loaded_Params {
+//   ExtensionMsg_Loaded_Params();
+//   ~ExtensionMsg_Loaded_Params();
+//   ExtensionMsg_Loaded_Params(const extensions::Extension* extension,
+//                              bool include_tab_permissions,
+//                              base::Optional<extensions::ActivationSequence>
+//                                  worker_activation_sequence);
+
+//   ExtensionMsg_Loaded_Params(ExtensionMsg_Loaded_Params&& other);
+//   ExtensionMsg_Loaded_Params& operator=(ExtensionMsg_Loaded_Params&& other);
+
+//   // Creates a new extension from the data in this object.
+//   // A context_id needs to be passed because each browser context can have
+//   // different values for default_policy_blocked/allowed_hosts.
+//   // (see extension_util.cc#GetBrowserContextId)
+//   scoped_refptr<extensions::Extension> ConvertToExtension(
+//       int context_id,
+//       std::string* error) const;
+
+//   // The subset of the extension manifest data we send to renderers.
+//   base::DictionaryValue manifest;
+
+//   // The location the extension was installed from.
+//   extensions::Manifest::Location location;
+
+//   // The path the extension was loaded from. This is used in the renderer only
+//   // to generate the extension ID for extensions that are loaded unpacked.
+//   base::FilePath path;
+
+//   // The extension's active and withheld permissions.
+//   ExtensionMsg_PermissionSetStruct active_permissions;
+//   ExtensionMsg_PermissionSetStruct withheld_permissions;
+//   std::map<int, ExtensionMsg_PermissionSetStruct> tab_specific_permissions;
+
+//   // Contains URLPatternSets defining which URLs an extension may not interact
+//   // with by policy.
+//   extensions::URLPatternSet policy_blocked_hosts;
+//   extensions::URLPatternSet policy_allowed_hosts;
+
+//   // If the extension uses the default list of blocked / allowed URLs.
+//   bool uses_default_policy_blocked_allowed_hosts = true;
+
+//   // We keep this separate so that it can be used in logging.
+//   std::string id;
+
+//   // If this extension is Service Worker based, then this contains the
+//   // activation sequence of the extension.
+//   base::Optional<extensions::ActivationSequence> worker_activation_sequence;
+
+//   // Send creation flags so extension is initialized identically.
+//   int creation_flags;
+
+//  private:
+//   DISALLOW_COPY_AND_ASSIGN(ExtensionMsg_Loaded_Params);
+// };
+
+// struct ExtensionHostMsg_AutomationQuerySelector_Error {
+//   enum Value { kNone, kNoDocument, kNodeDestroyed };
+
+//   ExtensionHostMsg_AutomationQuerySelector_Error() : value(kNone) {}
+
+//   Value value;
+// };
+
+namespace IPC {
+
+// template <>
+// struct ParamTraits<URLPattern> {
+//   typedef URLPattern param_type;
+//   static void Write(base::Pickle* m, const param_type& p);
+//   static bool Read(const base::Pickle* m,
+//                    base::PickleIterator* iter,
+//                    param_type* p);
+//   static void Log(const param_type& p, std::string* l);
+// };
+
+// template <>
+// struct ParamTraits<extensions::URLPatternSet> {
+//   typedef extensions::URLPatternSet param_type;
+//   static void Write(base::Pickle* m, const param_type& p);
+//   static bool Read(const base::Pickle* m,
+//                    base::PickleIterator* iter,
+//                    param_type* p);
+//   static void Log(const param_type& p, std::string* l);
+// };
+
+// template <>
+// struct ParamTraits<extensions::APIPermission::ID> {
+//   typedef extensions::APIPermission::ID param_type;
+//   static void Write(base::Pickle* m, const param_type& p);
+//   static bool Read(const base::Pickle* m,
+//                    base::PickleIterator* iter,
+//                    param_type* p);
+//   static void Log(const param_type& p, std::string* l);
+// };
+
+// template <>
+// struct ParamTraits<extensions::APIPermissionSet> {
+//   typedef extensions::APIPermissionSet param_type;
+//   static void Write(base::Pickle* m, const param_type& p);
+//   static bool Read(const base::Pickle* m,
+//                    base::PickleIterator* iter,
+//                    param_type* r);
+//   static void Log(const param_type& p, std::string* l);
+// };
+
+// template <>
+// struct ParamTraits<extensions::ManifestPermissionSet> {
+//   typedef extensions::ManifestPermissionSet param_type;
+//   static void Write(base::Pickle* m, const param_type& p);
+//   static bool Read(const base::Pickle* m,
+//                    base::PickleIterator* iter,
+//                    param_type* r);
+//   static void Log(const param_type& p, std::string* l);
+// };
+
+template <>
+struct ParamTraits<HostID> {
+  typedef HostID param_type;
+  static void Write(base::Pickle* m, const param_type& p);
+  static bool Read(const base::Pickle* m,
+                   base::PickleIterator* iter,
+                   param_type* r);
+  static void Log(const param_type& p, std::string* l);
+};
+
+// template <>
+// struct ParamTraits<ExtensionMsg_PermissionSetStruct> {
+//   typedef ExtensionMsg_PermissionSetStruct param_type;
+//   static void Write(base::Pickle* m, const param_type& p);
+//   static bool Read(const base::Pickle* m,
+//                    base::PickleIterator* iter,
+//                    param_type* p);
+//   static void Log(const param_type& p, std::string* l);
+// };
+
+// template <>
+// struct ParamTraits<ExtensionMsg_Loaded_Params> {
+//   typedef ExtensionMsg_Loaded_Params param_type;
+//   static void Write(base::Pickle* m, const param_type& p);
+//   static bool Read(const base::Pickle* m,
+//                    base::PickleIterator* iter,
+//                    param_type* p);
+//   static void Log(const param_type& p, std::string* l);
+// };
+
+}  // namespace IPC
+
+#endif  // INTERNAL_EXTENSIONS_COMMON_EXTENSION_MESSAGES_H_
+
+// IPC_ENUM_TRAITS_MAX_VALUE(
+//     ExtensionHostMsg_AutomationQuerySelector_Error::Value,
+//     ExtensionHostMsg_AutomationQuerySelector_Error::kNodeDestroyed)
+
+// IPC_STRUCT_TRAITS_BEGIN(ExtensionHostMsg_AutomationQuerySelector_Error)
+// IPC_STRUCT_TRAITS_MEMBER(value)
+// IPC_STRUCT_TRAITS_END()
+
+// // Parameters structure for ExtensionMsg_UpdatePermissions.
+// IPC_STRUCT_BEGIN(ExtensionMsg_UpdatePermissions_Params)
+//   IPC_STRUCT_MEMBER(std::string, extension_id)
+//   IPC_STRUCT_MEMBER(ExtensionMsg_PermissionSetStruct, active_permissions)
+//   IPC_STRUCT_MEMBER(ExtensionMsg_PermissionSetStruct, withheld_permissions)
+//   IPC_STRUCT_MEMBER(extensions::URLPatternSet, policy_blocked_hosts)
+//   IPC_STRUCT_MEMBER(extensions::URLPatternSet, policy_allowed_hosts)
+//   IPC_STRUCT_MEMBER(bool, uses_default_policy_host_restrictions)
+// IPC_STRUCT_END()
+
+// // Parameters structure for ExtensionMsg_UpdateDefaultPolicyHostRestrictions.
+// IPC_STRUCT_BEGIN(ExtensionMsg_UpdateDefaultPolicyHostRestrictions_Params)
+//   IPC_STRUCT_MEMBER(extensions::URLPatternSet, default_policy_blocked_hosts)
+//   IPC_STRUCT_MEMBER(extensions::URLPatternSet, default_policy_allowed_hosts)
+// IPC_STRUCT_END()
+
+// // Messages sent from the browser to the renderer:
+
+// // The browser sends this message in response to all extension api calls. The
+// // response data (if any) is one of the base::Value subclasses, wrapped as the
+// // first element in a ListValue.
+// IPC_MESSAGE_ROUTED4(ExtensionMsg_Response,
+//                     int /* request_id */,
+//                     bool /* success */,
+//                     base::ListValue /* response wrapper (see comment above) */,
+//                     std::string /* error */)
+
+// // Sent to the renderer to dispatch an event to an extension.
+// // Note: |event_args| is separate from the params to avoid having the message
+// // take ownership.
+// IPC_MESSAGE_CONTROL2(ExtensionMsg_DispatchEvent,
+//                      ExtensionMsg_DispatchEvent_Params /* params */,
+//                      base::ListValue /* event_args */)
+
+// // This message is optionally routed.  If used as a control message, it will
+// // call a javascript function |function_name| from module |module_name| in
+// // every registered context in the target process.  If routed, it will be
+// // restricted to the contexts that are part of the target RenderView.
+// //
+// // If |extension_id| is non-empty, the function will be invoked only in
+// // contexts owned by the extension. |args| is a list of primitive Value types
+// // that are passed to the function.
+// IPC_MESSAGE_ROUTED4(ExtensionMsg_MessageInvoke,
+//                     std::string /* extension_id */,
+//                     std::string /* module_name */,
+//                     std::string /* function_name */,
+//                     base::ListValue /* args */)
+
+// // Set the top-level frame to the provided name.
+// IPC_MESSAGE_ROUTED1(ExtensionMsg_SetFrameName,
+//                     std::string /* frame_name */)
+
+// // Tell the renderer process the platforms system font.
+// IPC_MESSAGE_CONTROL2(ExtensionMsg_SetSystemFont,
+//                      std::string /* font_family */,
+//                      std::string /* font_size */)
+
+// // Marks an extension as 'active' in an extension process. 'Active' extensions
+// // have more privileges than other extension content that might end up running
+// // in the process (e.g. because of iframes or content scripts).
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_ActivateExtension,
+//                      std::string /* extension_id */)
+
+// // Notifies the renderer that extensions were loaded in the browser.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_Loaded,
+//                      std::vector<ExtensionMsg_Loaded_Params>)
+
+// // Notifies the renderer that an extension was unloaded in the browser.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_Unloaded,
+//                      std::string)
+
+// // Updates the scripting allowlist for extensions in the render process. This is
+// // only used for testing.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_SetScriptingAllowlist,
+//                      // extension ids
+//                      extensions::ExtensionsClient::ScriptingAllowlist)
+
+// // Notification that renderer should run some JavaScript code.
+// IPC_MESSAGE_ROUTED1(ExtensionMsg_ExecuteCode,
+//                     ExtensionMsg_ExecuteCode_Params)
+
+// Notification that the user scripts have been updated. It has one
+// ReadOnlySharedMemoryRegion argument consisting of the pickled script data.
+// This memory region is valid in the context of the renderer.
+// If |owner| is not empty, then the shared memory handle refers to |owner|'s
+// programmatically-defined scripts. Otherwise, the handle refers to all
+// hosts' statically defined scripts. So far, only extension-hosts support
+// statically defined scripts; WebUI-hosts don't.
+// If |changed_hosts| is not empty, only the host in that set will
+// be updated. Otherwise, all hosts that have scripts in the shared memory
+// region will be updated. Note that the empty set => all hosts case is not
+// supported for per-extension programmatically-defined script regions; in such
+// regions, the owner is expected to list itself as the only changed host.
+// If |whitelisted_only| is true, this process should only run whitelisted
+// scripts and not all user scripts.
+IPC_MESSAGE_CONTROL1(ExtensionMsg_UpdateUserScripts,
+                     base::ReadOnlySharedMemoryRegion)
+                     //,HostID /* owner */,
+                     //std::set<HostID> /* changed hosts */,
+                     //bool /* whitelisted_only */)
+
+// // Trigger to execute declarative content script under browser control.
+// IPC_MESSAGE_ROUTED4(ExtensionMsg_ExecuteDeclarativeScript,
+//                     int /* tab identifier */,
+//                     extensions::ExtensionId /* extension identifier */,
+//                     int /* script identifier */,
+//                     GURL /* page URL where script should be injected */)
+
+// // Tell the render view which browser window it's being attached to.
+// IPC_MESSAGE_ROUTED1(ExtensionMsg_UpdateBrowserWindowId,
+//                     int /* id of browser window */)
+
+// // Tell the render view what its tab ID is.
+// IPC_MESSAGE_ROUTED1(ExtensionMsg_SetTabId,
+//                     int /* id of tab */)
+
+// // Tell the renderer to update an extension's permission set.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_UpdatePermissions,
+//                      ExtensionMsg_UpdatePermissions_Params)
+
+// // Tell the renderer to update an extension's policy_blocked_hosts set.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_UpdateDefaultPolicyHostRestrictions,
+//                      ExtensionMsg_UpdateDefaultPolicyHostRestrictions_Params)
+
+// // Tell the render view about new tab-specific permissions for an extension.
+// IPC_MESSAGE_CONTROL5(ExtensionMsg_UpdateTabSpecificPermissions,
+//                      GURL /* url */,
+//                      std::string /* extension_id */,
+//                      extensions::URLPatternSet /* hosts */,
+//                      bool /* update origin whitelist */,
+//                      int /* tab_id */)
+
+// // Tell the render view to clear tab-specific permissions for some extensions.
+// IPC_MESSAGE_CONTROL3(ExtensionMsg_ClearTabSpecificPermissions,
+//                      std::vector<std::string> /* extension_ids */,
+//                      bool /* update origin whitelist */,
+//                      int /* tab_id */)
+
+// // Tell the renderer which type this view is.
+// IPC_MESSAGE_ROUTED1(ExtensionMsg_NotifyRenderViewType,
+//                     extensions::ViewType /* view_type */)
+
+// // The browser's response to the ExtensionMsg_WakeEventPage IPC.
+// IPC_MESSAGE_CONTROL2(ExtensionMsg_WakeEventPageResponse,
+//                      int /* request_id */,
+//                      bool /* success */)
+
+// // Ask the lazy background page if it is ready to be suspended. This is sent
+// // when the page is considered idle. The renderer will reply with the same
+// // sequence_id so that we can tell which message it is responding to.
+// IPC_MESSAGE_CONTROL2(ExtensionMsg_ShouldSuspend,
+//                      std::string /* extension_id */,
+//                      uint64_t /* sequence_id */)
+
+// // If we complete a round of ShouldSuspend->ShouldSuspendAck messages without
+// // the lazy background page becoming active again, we are ready to unload. This
+// // message tells the page to dispatch the suspend event.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_Suspend,
+//                      std::string /* extension_id */)
+
+// // The browser changed its mind about suspending this extension.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_CancelSuspend,
+//                      std::string /* extension_id */)
+
+// // Response to the renderer for ExtensionHostMsg_GetAppInstallState.
+// IPC_MESSAGE_ROUTED2(ExtensionMsg_GetAppInstallStateResponse,
+//                     std::string /* state */,
+//                     int32_t /* callback_id */)
+
+// // Check whether the Port for extension messaging exists in a frame or a Service
+// // Worker. If the port ID is unknown, the frame replies with
+// // ExtensionHostMsg_CloseMessagePort.
+// IPC_MESSAGE_ROUTED2(ExtensionMsg_ValidateMessagePort,
+//                     // For main thread, this is kMainThreadId.
+//                     int /* worker_thread_id */,
+//                     extensions::PortId /* port_id */)
+
+// // Dispatch the Port.onConnect event for message channels.
+// IPC_MESSAGE_ROUTED5(ExtensionMsg_DispatchOnConnect,
+//                     // For main thread, this is kMainThreadId.
+//                     // TODO(lazyboy): Can this be base::Optional<int> instead?
+//                     int /* worker_thread_id */,
+//                     extensions::PortId /* target_port_id */,
+//                     std::string /* channel_name */,
+//                     ExtensionMsg_TabConnectionInfo /* source */,
+//                     ExtensionMsg_ExternalConnectionInfo)
+
+// // Deliver a message sent with ExtensionHostMsg_PostMessage.
+// IPC_MESSAGE_ROUTED3(ExtensionMsg_DeliverMessage,
+//                     // For main thread, this is kMainThreadId.
+//                     int /* worker_thread_id */,
+//                     extensions::PortId /* target_port_id */,
+//                     extensions::Message)
+
+// // Dispatch the Port.onDisconnect event for message channels.
+// IPC_MESSAGE_ROUTED3(ExtensionMsg_DispatchOnDisconnect,
+//                     // For main thread, this is kMainThreadId.
+//                     int /* worker_thread_id */,
+//                     extensions::PortId /* port_id */,
+//                     std::string /* error_message */)
+
+// // Informs the renderer what channel (dev, beta, stable, etc) and user session
+// // type is running.
+// IPC_MESSAGE_CONTROL3(ExtensionMsg_SetSessionInfo,
+//                      version_info::Channel /* channel */,
+//                      extensions::FeatureSessionType /* session_type */,
+//                      bool /* is_lock_screen_context */)
+
+// // Notify the renderer that its window has closed.
+// IPC_MESSAGE_ROUTED1(ExtensionMsg_AppWindowClosed, bool /* send_onclosed */)
+
+// // Notify the renderer that an extension wants notifications when certain
+// // searches match the active page.  This message replaces the old set of
+// // searches, and triggers ExtensionHostMsg_OnWatchedPageChange messages from
+// // each tab to keep the browser updated about changes.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_WatchPages,
+//                      std::vector<std::string> /* CSS selectors */)
+
+// // Send by the browser to indicate a Blob handle has been transferred to the
+// // renderer. This is sent after the actual extension response, and depends on
+// // the sequential nature of IPCs so that the blob has already been caught.
+// // This is a separate control message, so that the renderer process will send
+// // an acknowledgement even if the RenderView has closed or navigated away.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_TransferBlobs,
+//                      std::vector<std::string> /* blob_uuids */)
+
+// // Report the WebView partition ID to the WebView guest renderer process.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_SetWebViewPartitionID,
+//                      std::string /* webview_partition_id */)
+
+// // Enable or disable spatial navigation.
+// IPC_MESSAGE_ROUTED1(ExtensionMsg_SetSpatialNavigationEnabled,
+//                     bool /* spatial_nav_enabled */)
+
+// // Messages sent from the renderer to the browser:
+
+// // A renderer sends this message when an extension process starts an API
+// // request. The browser will always respond with a ExtensionMsg_Response.
+// IPC_MESSAGE_ROUTED1(ExtensionHostMsg_Request,
+//                     ExtensionHostMsg_Request_Params)
+
+// // Notify the browser that the given extension added a listener to an event.
+// IPC_MESSAGE_CONTROL5(ExtensionHostMsg_AddListener,
+//                      std::string /* extension_id */,
+//                      GURL /* listener_or_worker_scope_url */,
+//                      std::string /* name */,
+//                      int64_t /* service_worker_version_id */,
+//                      int /* worker_thread_id */)
+
+// // Notify the browser that the given extension removed a listener from an
+// // event.
+// IPC_MESSAGE_CONTROL5(ExtensionHostMsg_RemoveListener,
+//                      std::string /* extension_id */,
+//                      GURL /* listener_or_worker_scope_url */,
+//                      std::string /* name */,
+//                      int64_t /* service_worker_version_id */,
+//                      int /* worker_thread_id */)
+
+// // Notify the browser that the given extension added a listener to an event from
+// // a lazy background page.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_AddLazyListener,
+//                      std::string /* extension_id */,
+//                      std::string /* name */)
+
+// // Notify the browser that the given extension is no longer interested in
+// // receiving the given event from a lazy background page.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_RemoveLazyListener,
+//                      std::string /* extension_id */,
+//                      std::string /* event_name */)
+
+// // Notify the browser that the given extension added a listener to an event from
+// // an extension service worker.
+// IPC_MESSAGE_CONTROL3(ExtensionHostMsg_AddLazyServiceWorkerListener,
+//                      std::string /* extension_id */,
+//                      std::string /* name */,
+//                      GURL /* service_worker_scope */)
+
+// // Notify the browser that the given extension is no longer interested in
+// // receiving the given event from an extension service worker.
+// IPC_MESSAGE_CONTROL3(ExtensionHostMsg_RemoveLazyServiceWorkerListener,
+//                      std::string /* extension_id */,
+//                      std::string /* name */,
+//                      GURL /* service_worker_scope */)
+
+// // Notify the browser that the given extension added a listener to instances of
+// // the named event that satisfy the filter.
+// // If |sw_identifier| is specified, it implies that the listener is for a
+// // service worker, and the param is used to identify the worker.
+// IPC_MESSAGE_CONTROL5(
+//     ExtensionHostMsg_AddFilteredListener,
+//     std::string /* extension_id */,
+//     std::string /* name */,
+//     base::Optional<ServiceWorkerIdentifier> /* sw_identifier */,
+//     base::DictionaryValue /* filter */,
+//     bool /* lazy */)
+
+// // Notify the browser that the given extension is no longer interested in
+// // instances of the named event that satisfy the filter.
+// // If |sw_identifier| is specified, it implies that the listener is for a
+// // service worker, and the param is used to identify the worker.
+// IPC_MESSAGE_CONTROL5(
+//     ExtensionHostMsg_RemoveFilteredListener,
+//     std::string /* extension_id */,
+//     std::string /* name */,
+//     base::Optional<ServiceWorkerIdentifier> /* sw_identifier */,
+//     base::DictionaryValue /* filter */,
+//     bool /* lazy */)
+
+// // Notify the browser that an event has finished being dispatched.
+// IPC_MESSAGE_ROUTED1(ExtensionHostMsg_EventAck, int /* message_id */)
+
+// // Open a channel to all listening contexts owned by the extension with
+// // the given ID. This responds asynchronously with ExtensionMsg_AssignPortId.
+// // If an error occurred, the opener will be notified asynchronously.
+// IPC_MESSAGE_CONTROL4(ExtensionHostMsg_OpenChannelToExtension,
+//                      extensions::PortContext /* source_context */,
+//                      ExtensionMsg_ExternalConnectionInfo,
+//                      std::string /* channel_name */,
+//                      extensions::PortId /* port_id */)
+
+// IPC_MESSAGE_CONTROL3(ExtensionHostMsg_OpenChannelToNativeApp,
+//                      extensions::PortContext /* source_context */,
+//                      std::string /* native_app_name */,
+//                      extensions::PortId /* port_id */)
+
+// // Get a port handle to the given tab.  The handle can be used for sending
+// // messages to the extension.
+// IPC_MESSAGE_CONTROL5(ExtensionHostMsg_OpenChannelToTab,
+//                      extensions::PortContext /* source_context */,
+//                      ExtensionMsg_TabTargetConnectionInfo,
+//                      std::string /* extension_id */,
+//                      std::string /* channel_name */,
+//                      extensions::PortId /* port_id */)
+
+// // Sent in response to ExtensionMsg_DispatchOnConnect when the port is accepted.
+// // The handle is the value returned by ExtensionHostMsg_OpenChannelTo*.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_OpenMessagePort,
+//                      extensions::PortContext /* port_context */,
+//                      extensions::PortId /* port_id */)
+
+// // Sent in response to ExtensionMsg_DispatchOnConnect and whenever the port is
+// // closed. The handle is the value returned by ExtensionHostMsg_OpenChannelTo*.
+// IPC_MESSAGE_CONTROL3(ExtensionHostMsg_CloseMessagePort,
+//                      extensions::PortContext /* port_context */,
+//                      extensions::PortId /* port_id */,
+//                      bool /* force_close */)
+
+// // Send a message to an extension process.  The handle is the value returned
+// // by ExtensionHostMsg_OpenChannelTo*.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_PostMessage,
+//                      extensions::PortId /* port_id */,
+//                      extensions::Message)
+
+// // Used to get the extension message bundle.
+// IPC_SYNC_MESSAGE_CONTROL1_1(ExtensionHostMsg_GetMessageBundle,
+//                             std::string /* extension id */,
+//                             SubstitutionMap /* message bundle */)
+
+// // Sent from the renderer to the browser to return the script running result.
+// IPC_MESSAGE_ROUTED4(
+//     ExtensionHostMsg_ExecuteCodeFinished,
+//     int /* request id */,
+//     std::string /* error; empty implies success */,
+//     GURL /* URL of the code executed on. May be empty if unsuccessful. */,
+//     base::ListValue /* result of the script */)
+
+// // Sent from the renderer to the browser to notify that content scripts are
+// // running in the renderer that the IPC originated from.
+// IPC_MESSAGE_ROUTED2(ExtensionHostMsg_ContentScriptsExecuting,
+//                     ExecutingScriptsMap,
+//                     GURL /* url of the _topmost_ frame */)
+
+// // Sent from the renderer to the browser to request permission for a script
+// // injection.
+// // If request id is -1, this signals that the request has already ran, and this
+// // merely serves as a notification. This happens when the feature to disable
+// // scripts running without user consent is not enabled.
+// IPC_MESSAGE_ROUTED4(ExtensionHostMsg_RequestScriptInjectionPermission,
+//                     std::string /* extension id */,
+//                     extensions::UserScript::InjectionType /* script type */,
+//                     extensions::UserScript::RunLocation /* run location */,
+//                     int64_t /* request id */)
+
+// // Sent from the browser to the renderer in reply to a
+// // RequestScriptInjectionPermission message, granting permission for a script
+// // script to run.
+// IPC_MESSAGE_ROUTED1(ExtensionMsg_PermitScriptInjection,
+//                     int64_t /* request id */)
+
+// // Sent by the renderer when a web page is checking if its app is installed.
+// IPC_MESSAGE_ROUTED3(ExtensionHostMsg_GetAppInstallState,
+//                     GURL /* requestor_url */,
+//                     int32_t /* return_route_id */,
+//                     int32_t /* callback_id */)
+
+// // Optional Ack message sent to the browser to notify that the response to a
+// // function has been processed.
+// IPC_MESSAGE_ROUTED1(ExtensionHostMsg_ResponseAck,
+//                     int /* request_id */)
+
+// // Response to ExtensionMsg_ShouldSuspend.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_ShouldSuspendAck,
+//                      std::string /* extension_id */,
+//                      uint64_t /* sequence_id */)
+
+// // Response to ExtensionMsg_Suspend, after we dispatch the suspend event.
+// IPC_MESSAGE_CONTROL1(ExtensionHostMsg_SuspendAck,
+//                      std::string /* extension_id */)
+
+// // Informs the browser to increment the keepalive count for the lazy background
+// // page, keeping it alive.
+// IPC_MESSAGE_ROUTED0(ExtensionHostMsg_IncrementLazyKeepaliveCount)
+
+// // Informs the browser there is one less thing keeping the lazy background page
+// // alive.
+// IPC_MESSAGE_ROUTED0(ExtensionHostMsg_DecrementLazyKeepaliveCount)
+
+// // Notify the browser that an app window is ready and can resume resource
+// // requests.
+// IPC_MESSAGE_ROUTED0(ExtensionHostMsg_AppWindowReady)
+
+// // Sent by the renderer when the draggable regions are updated.
+// IPC_MESSAGE_ROUTED1(ExtensionHostMsg_UpdateDraggableRegions,
+//                     std::vector<extensions::DraggableRegion> /* regions */)
+
+// // Sent by the renderer to log an API action to the extension activity log.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_AddAPIActionToActivityLog,
+//                      std::string /* extension_id */,
+//                      ExtensionHostMsg_APIActionOrEvent_Params)
+
+// // Sent by the renderer to log an event to the extension activity log.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_AddEventToActivityLog,
+//                     std::string /* extension_id */,
+//                     ExtensionHostMsg_APIActionOrEvent_Params)
+
+// // Sent by the renderer to log a DOM action to the extension activity log.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_AddDOMActionToActivityLog,
+//                      std::string /* extension_id */,
+//                      ExtensionHostMsg_DOMAction_Params)
+
+// // Notifies the browser process that a tab has started or stopped matching
+// // certain conditions.  This message is sent in response to several events:
+// //
+// // * ExtensionMsg_WatchPages was received, updating the set of conditions.
+// // * A new page is loaded.  This will be sent after
+// //   mojom::FrameHost::DidCommitProvisionalLoad. Currently this only fires for
+// //   the main frame.
+// // * Something changed on an existing frame causing the set of matching searches
+// //   to change.
+// IPC_MESSAGE_ROUTED1(ExtensionHostMsg_OnWatchedPageChange,
+//                     std::vector<std::string> /* Matching CSS selectors */)
+
+// // Sent by the renderer when it has received a Blob handle from the browser.
+// IPC_MESSAGE_CONTROL1(ExtensionHostMsg_TransferBlobsAck,
+//                      std::vector<std::string> /* blob_uuids */)
+
+// // Asks the browser to wake the event page of an extension.
+// // The browser will reply with ExtensionHostMsg_WakeEventPageResponse.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_WakeEventPage,
+//                      int /* request_id */,
+//                      std::string /* extension_id */)
+
+// // Tells listeners that a detailed message was reported to the console by
+// // WebKit.
+// IPC_MESSAGE_ROUTED4(ExtensionHostMsg_DetailedConsoleMessageAdded,
+//                     base::string16 /* message */,
+//                     base::string16 /* source */,
+//                     extensions::StackTrace /* stack trace */,
+//                     int32_t /* severity level */)
+
+// // Sent when a query selector request is made from the automation API.
+// // acc_obj_id is the accessibility tree ID of the starting element.
+// IPC_MESSAGE_ROUTED3(ExtensionMsg_AutomationQuerySelector,
+//                     int /* request_id */,
+//                     int /* acc_obj_id */,
+//                     base::string16 /* selector */)
+
+// // Result of a query selector request.
+// // result_acc_obj_id is the accessibility tree ID of the result element; 0
+// // indicates no result.
+// IPC_MESSAGE_ROUTED3(ExtensionHostMsg_AutomationQuerySelector_Result,
+//                     int /* request_id */,
+//                     ExtensionHostMsg_AutomationQuerySelector_Error /* error */,
+//                     int /* result_acc_obj_id */)
+
+// // Tells the renderer whether or not activity logging is enabled. This is only
+// // sent if logging is or was previously enabled; not being enabled is assumed
+// // otherwise.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_SetActivityLoggingEnabled, bool /* enabled */)
+
+// // Messages related to Extension Service Worker.
+// #undef IPC_MESSAGE_START
+// #define IPC_MESSAGE_START ExtensionWorkerMsgStart
+// // A service worker thread sends this message when an extension service worker
+// // starts an API request. The browser will always respond with a
+// // ExtensionMsg_ResponseWorker.
+// IPC_MESSAGE_CONTROL1(ExtensionHostMsg_RequestWorker,
+//                      ExtensionHostMsg_Request_Params)
+
+// // The browser sends this message in response to all service worker extension
+// // api calls. The response data (if any) is one of the base::Value subclasses,
+// // wrapped as the first element in a ListValue.
+// IPC_MESSAGE_CONTROL5(ExtensionMsg_ResponseWorker,
+//                      int /* thread_id */,
+//                      int /* request_id */,
+//                      bool /* success */,
+//                      base::ListValue /* response wrapper (see comment above) */,
+//                      std::string /* error */)
+
+// // Asks the browser to increment the pending activity count for
+// // the worker with version id |service_worker_version_id|.
+// // Each request to increment must use unique |request_uuid|. If a request with
+// // |request_uuid| is already in progress (due to race condition or renderer
+// // compromise), browser process ignores the IPC.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_IncrementServiceWorkerActivity,
+//                      int64_t /* service_worker_version_id */,
+//                      std::string /* request_uuid */)
+
+// // Asks the browser to decrement the pending activity count for
+// // the worker with version id |service_worker_version_id|.
+// // |request_uuid| must match the GUID of a previous request, otherwise the
+// // browser process ignores the IPC.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_DecrementServiceWorkerActivity,
+//                      int64_t /* service_worker_version_id */,
+//                      std::string /* request_uuid */)
+
+// // Tells the browser that an event with |event_id| was successfully dispatched
+// // to the worker with version |service_worker_version_id|.
+// IPC_MESSAGE_CONTROL4(ExtensionHostMsg_EventAckWorker,
+//                      std::string /* extension_id */,
+//                      int64_t /* service_worker_version_id */,
+//                      int /* worker_thread_id */,
+//                      int /* event_id */)
+
+// // Tells the browser that an extension service worker context was initialized,
+// // but possibly didn't start executing its top-level JavaScript.
+// IPC_MESSAGE_CONTROL3(ExtensionHostMsg_DidInitializeServiceWorkerContext,
+//                      std::string /* extension_id */,
+//                      int64_t /* service_worker_version_id */,
+//                      int /* worker_thread_id */)
+
+// // Tells the browser that an extension service worker context has started and
+// // finished executing its top-level JavaScript.
+// // Start corresponds to EmbeddedWorkerInstance::OnStarted notification.
+// //
+// // TODO(lazyboy): This is a workaround: ideally this IPC should be redundant
+// // because it directly corresponds to EmbeddedWorkerInstance::OnStarted message.
+// // However, because OnStarted message is on different mojo IPC pipe, and most
+// // extension IPCs are on legacy IPC pipe, this IPC is necessary to ensure FIFO
+// // ordering of this message with rest of the extension IPCs.
+// // Two possible solutions to this:
+// //   - Associate extension IPCs with Service Worker IPCs. This can be done (and
+// //     will be a requirement) when extension IPCs are moved to mojo, but
+// //     requires resolving or defining ordering dependencies amongst the
+// //     extension messages, and any additional messages in Chrome.
+// //   - Make Service Worker IPCs channel-associated so that there's FIFO
+// //     guarantee between extension IPCs and Service Worker IPCs. This isn't
+// //     straightforward as it changes SW IPC ordering with respect of rest of
+// //     Chrome.
+// // See https://crbug.com/879015#c4 for details.
+// IPC_MESSAGE_CONTROL5(ExtensionHostMsg_DidStartServiceWorkerContext,
+//                      std::string /* extension_id */,
+//                      extensions::ActivationSequence /* activation_sequence */,
+//                      GURL /* service_worker_scope */,
+//                      int64_t /* service_worker_version_id */,
+//                      int /* worker_thread_id */)
+
+// // Tells the browser that an extension service worker context has been
+// // destroyed.
+// IPC_MESSAGE_CONTROL5(ExtensionHostMsg_DidStopServiceWorkerContext,
+//                      std::string /* extension_id */,
+//                      extensions::ActivationSequence /* activation_sequence */,
+//                      GURL /* service_worker_scope */,
+//                      int64_t /* service_worker_version_id */,
+//                      int /* worker_thread_id */)
+
+// IPC_STRUCT_BEGIN(ExtensionMsg_AccessibilityEventBundleParams)
+//   // ID of the accessibility tree that this event applies to.
+//   IPC_STRUCT_MEMBER(ui::AXTreeID, tree_id)
+
+//   // Zero or more updates to the accessibility tree to apply first.
+//   IPC_STRUCT_MEMBER(std::vector<ui::AXTreeUpdate>, updates)
+
+//   // Zero or more events to fire after the tree updates have been applied.
+//   IPC_STRUCT_MEMBER(std::vector<ui::AXEvent>, events)
+
+//   // The mouse location in screen coordinates.
+//   IPC_STRUCT_MEMBER(gfx::Point, mouse_location)
+// IPC_STRUCT_END()
+
+// IPC_STRUCT_BEGIN(ExtensionMsg_AccessibilityLocationChangeParams)
+//   // ID of the accessibility tree that this event applies to.
+//   IPC_STRUCT_MEMBER(ui::AXTreeID, tree_id)
+
+//   // ID of the object whose location is changing.
+//   IPC_STRUCT_MEMBER(int, id)
+
+//   // The object's new location info.
+//   IPC_STRUCT_MEMBER(ui::AXRelativeBounds, new_location)
+// IPC_STRUCT_END()
+
+// // Forward an accessibility message to an extension process where an
+// // extension is using the automation API to listen for accessibility events.
+// IPC_MESSAGE_CONTROL2(ExtensionMsg_AccessibilityEventBundle,
+//                      ExtensionMsg_AccessibilityEventBundleParams /* events */,
+//                      bool /* is_active_profile */)
+
+// // Forward an accessibility location change message to an extension process
+// // where an extension is using the automation API to listen for
+// // accessibility events.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_AccessibilityLocationChange,
+//                      ExtensionMsg_AccessibilityLocationChangeParams)
+
+#endif  // EXTENSIONS_COMMON_EXTENSION_MESSAGES_H_
diff --git a/components/user_scripts/common/host_id.cc b/components/user_scripts/common/host_id.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/host_id.cc
@@ -0,0 +1,31 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "host_id.h"
+
+#include <tuple>
+
+HostID::HostID()
+    : type_(HostType::EXTENSIONS) {
+}
+
+HostID::HostID(HostType type, const std::string& id)
+    : type_(type), id_(id) {
+}
+
+HostID::HostID(const HostID& host_id)
+    : type_(host_id.type()),
+      id_(host_id.id()) {
+}
+
+HostID::~HostID() {
+}
+
+bool HostID::operator<(const HostID& host_id) const {
+  return std::tie(type_, id_) < std::tie(host_id.type_, host_id.id_);
+}
+
+bool HostID::operator==(const HostID& host_id) const {
+  return type_ == host_id.type_ && id_ == host_id.id_;
+}
diff --git a/components/user_scripts/common/host_id.h b/components/user_scripts/common/host_id.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/host_id.h
@@ -0,0 +1,35 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_COMMON_HOST_ID_H_
+#define EXTENSIONS_COMMON_HOST_ID_H_
+
+#include <string>
+
+// IDs of hosts who own user scripts.
+// A HostID is immutable after creation.
+struct HostID {
+  enum HostType { EXTENSIONS, WEBUI, HOST_TYPE_LAST = WEBUI };
+
+  HostID();
+  HostID(HostType type, const std::string& id);
+  HostID(const HostID& host_id);
+  ~HostID();
+
+  bool operator<(const HostID& host_id) const;
+  bool operator==(const HostID& host_id) const;
+
+  HostType type() const { return type_; }
+  const std::string& id() const { return id_; }
+
+ private:
+  // The type of the host.
+  HostType type_;
+
+  // Similar to extension_id, host_id is a unique indentifier for a host,
+  // e.g., an Extension or WebUI.
+  std::string id_;
+};
+
+#endif  // EXTENSIONS_COMMON_HOST_ID_H_
diff --git a/components/user_scripts/common/script_constants.h b/components/user_scripts/common/script_constants.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/script_constants.h
@@ -0,0 +1,33 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_COMMON_SCRIPT_CONSTANTS_H_
+#define EXTENSIONS_COMMON_SCRIPT_CONSTANTS_H_
+
+namespace user_scripts {
+
+// Whether to fall back to matching the origin for frames where the URL
+// cannot be matched directly, such as those with about: or data: schemes.
+enum class MatchOriginAsFallbackBehavior {
+  // Never fall back on the origin; this means scripts will never match on
+  // these frames.
+  kNever,
+  // Match the origin only for about:-scheme frames, and then climb the frame
+  // tree to find an appropriate ancestor to get a full URL (including path).
+  // This is for supporting the "match_about_blank" key.
+  // TODO(devlin): I wonder if we could simplify this to be "MatchForAbout",
+  // and not worry about climbing the frame tree. It would be a behavior
+  // change, but I wonder how many extensions it would impact in practice.
+  kMatchForAboutSchemeAndClimbTree,
+  // Match the origin as a fallback whenever applicable. This won't have a
+  // corresponding path.
+  kAlways,
+};
+
+// TODO(devlin): Move the other non-UserScript-specific constants like
+// RunLocation and InjectionType from UserScript into here.
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_COMMON_SCRIPT_CONSTANTS_H_
diff --git a/components/user_scripts/common/url_pattern.cc b/components/user_scripts/common/url_pattern.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/url_pattern.cc
@@ -0,0 +1,807 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "url_pattern.h"
+
+#include <stddef.h>
+
+#include <ostream>
+
+#include "base/logging.h"
+#include "base/stl_util.h"
+#include "base/strings/pattern.h"
+#include "base/strings/strcat.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_split.h"
+#include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "content/public/common/url_constants.h"
+#include "constants.h"
+#include "net/base/registry_controlled_domains/registry_controlled_domain.h"
+#include "net/base/url_util.h"
+#include "url/gurl.h"
+#include "url/url_util.h"
+
+const char URLPattern::kAllUrlsPattern[] = "<all_urls>";
+
+namespace {
+
+// TODO(aa): What about more obscure schemes like javascript: ?
+// Note: keep this array in sync with kValidSchemeMasks.
+const char* const kValidSchemes[] = {
+    url::kHttpScheme,         url::kHttpsScheme,
+    url::kFileScheme,         url::kFtpScheme,
+    /*content::kChromeUIScheme,*/ /*extensions::kExtensionScheme,*/
+    url::kFileSystemScheme,   url::kWsScheme,
+    url::kWssScheme,          url::kDataScheme,
+};
+
+const int kValidSchemeMasks[] = {
+    URLPattern::SCHEME_HTTP,       URLPattern::SCHEME_HTTPS,
+    URLPattern::SCHEME_FILE,       URLPattern::SCHEME_FTP,
+    /*URLPattern::SCHEME_CHROMEUI,*/   /*URLPattern::SCHEME_EXTENSION,*/
+    URLPattern::SCHEME_FILESYSTEM, URLPattern::SCHEME_WS,
+    URLPattern::SCHEME_WSS,        URLPattern::SCHEME_DATA,
+};
+
+static_assert(base::size(kValidSchemes) == base::size(kValidSchemeMasks),
+              "must keep these arrays in sync");
+
+const char kParseSuccess[] = "Success.";
+const char kParseErrorMissingSchemeSeparator[] = "Missing scheme separator.";
+const char kParseErrorInvalidScheme[] = "Invalid scheme.";
+const char kParseErrorWrongSchemeType[] = "Wrong scheme type.";
+const char kParseErrorEmptyHost[] = "Host can not be empty.";
+const char kParseErrorInvalidHostWildcard[] = "Invalid host wildcard.";
+const char kParseErrorEmptyPath[] = "Empty path.";
+const char kParseErrorInvalidPort[] = "Invalid port.";
+const char kParseErrorInvalidHost[] = "Invalid host.";
+
+// Message explaining each URLPattern::ParseResult.
+const char* const kParseResultMessages[] = {
+  kParseSuccess,
+  kParseErrorMissingSchemeSeparator,
+  kParseErrorInvalidScheme,
+  kParseErrorWrongSchemeType,
+  kParseErrorEmptyHost,
+  kParseErrorInvalidHostWildcard,
+  kParseErrorEmptyPath,
+  kParseErrorInvalidPort,
+  kParseErrorInvalidHost,
+};
+
+static_assert(static_cast<int>(URLPattern::ParseResult::kNumParseResults) ==
+                  base::size(kParseResultMessages),
+              "must add message for each parse result");
+
+const char kPathSeparator[] = "/";
+
+bool IsStandardScheme(base::StringPiece scheme) {
+  // "*" gets the same treatment as a standard scheme.
+  if (scheme == "*")
+    return true;
+
+  return url::IsStandard(scheme.data(),
+                         url::Component(0, static_cast<int>(scheme.length())));
+}
+
+bool IsValidPortForScheme(base::StringPiece scheme, base::StringPiece port) {
+  if (port == "*")
+    return true;
+
+  // Only accept non-wildcard ports if the scheme uses ports.
+  if (url::DefaultPortForScheme(scheme.data(), scheme.length()) ==
+      url::PORT_UNSPECIFIED) {
+    return false;
+  }
+
+  int parsed_port = url::PORT_UNSPECIFIED;
+  if (!base::StringToInt(port, &parsed_port))
+    return false;
+  return (parsed_port >= 0) && (parsed_port < 65536);
+}
+
+// Returns |path| with the trailing wildcard stripped if one existed.
+//
+// The functions that rely on this (OverlapsWith and Contains) are only
+// called for the patterns inside URLPatternSet. In those cases, we know that
+// the path will have only a single wildcard at the end. This makes figuring
+// out overlap much easier. It seems like there is probably a computer-sciency
+// way to solve the general case, but we don't need that yet.
+base::StringPiece StripTrailingWildcard(base::StringPiece path) {
+  if (base::EndsWith(path, "*"))
+    path.remove_suffix(1);
+  return path;
+}
+
+// Removes trailing dot from |host_piece| if any.
+base::StringPiece CanonicalizeHostForMatching(base::StringPiece host_piece) {
+  if (base::EndsWith(host_piece, "."))
+    host_piece.remove_suffix(1);
+  return host_piece;
+}
+
+}  // namespace
+
+// static
+bool URLPattern::IsValidSchemeForExtensions(base::StringPiece scheme) {
+  for (size_t i = 0; i < base::size(kValidSchemes); ++i) {
+    if (scheme == kValidSchemes[i])
+      return true;
+  }
+  return false;
+}
+
+// static
+int URLPattern::GetValidSchemeMaskForExtensions() {
+  int result = 0;
+  for (size_t i = 0; i < base::size(kValidSchemeMasks); ++i)
+    result |= kValidSchemeMasks[i];
+  return result;
+}
+
+URLPattern::URLPattern()
+    : valid_schemes_(SCHEME_NONE),
+      match_all_urls_(false),
+      match_subdomains_(false),
+      port_("*") {}
+
+URLPattern::URLPattern(int valid_schemes)
+    : valid_schemes_(valid_schemes),
+      match_all_urls_(false),
+      match_subdomains_(false),
+      port_("*") {}
+
+URLPattern::URLPattern(int valid_schemes, base::StringPiece pattern)
+    // Strict error checking is used, because this constructor is only
+    // appropriate when we know |pattern| is valid.
+    : valid_schemes_(valid_schemes),
+      match_all_urls_(false),
+      match_subdomains_(false),
+      port_("*") {
+  ParseResult result = Parse(pattern);
+  if (result != ParseResult::kSuccess) {
+    const char* error_string = GetParseResultString(result);
+    // Temporarily add more logging to investigate why this code path is
+    // reached. For http://crbug.com/856948
+    LOG(ERROR) << "Invalid pattern was given " << pattern << " result "
+               << error_string;
+    NOTREACHED() << "URLPattern invalid: '" << pattern
+                 << "'; error: " << error_string;
+  }
+}
+
+URLPattern::URLPattern(const URLPattern& other) = default;
+
+URLPattern::URLPattern(URLPattern&& other) = default;
+
+URLPattern::~URLPattern() {
+}
+
+URLPattern& URLPattern::operator=(const URLPattern& other) = default;
+
+URLPattern& URLPattern::operator=(URLPattern&& other) = default;
+
+bool URLPattern::operator<(const URLPattern& other) const {
+  return GetAsString() < other.GetAsString();
+}
+
+bool URLPattern::operator>(const URLPattern& other) const {
+  return GetAsString() > other.GetAsString();
+}
+
+bool URLPattern::operator==(const URLPattern& other) const {
+  return GetAsString() == other.GetAsString();
+}
+
+std::ostream& operator<<(std::ostream& out, const URLPattern& url_pattern) {
+  return out << '"' << url_pattern.GetAsString() << '"';
+}
+
+URLPattern::ParseResult URLPattern::Parse(base::StringPiece pattern) {
+  spec_.clear();
+  SetMatchAllURLs(false);
+  SetMatchSubdomains(false);
+  SetPort("*");
+
+  // Special case pattern to match every valid URL.
+  if (pattern == kAllUrlsPattern) {
+    SetMatchAllURLs(true);
+    return ParseResult::kSuccess;
+  }
+
+  // Parse out the scheme.
+  size_t scheme_end_pos = pattern.find(url::kStandardSchemeSeparator);
+  bool has_standard_scheme_separator = true;
+
+  // Some urls also use ':' alone as the scheme separator.
+  if (scheme_end_pos == base::StringPiece::npos) {
+    scheme_end_pos = pattern.find(':');
+    has_standard_scheme_separator = false;
+  }
+
+  if (scheme_end_pos == base::StringPiece::npos)
+    return ParseResult::kMissingSchemeSeparator;
+
+  if (!SetScheme(pattern.substr(0, scheme_end_pos)))
+    return ParseResult::kInvalidScheme;
+
+  bool standard_scheme = IsStandardScheme(scheme_);
+  if (standard_scheme != has_standard_scheme_separator)
+    return ParseResult::kWrongSchemeSeparator;
+
+  // Advance past the scheme separator.
+  scheme_end_pos +=
+      (standard_scheme ? strlen(url::kStandardSchemeSeparator) : 1);
+  if (scheme_end_pos >= pattern.size())
+    return ParseResult::kEmptyHost;
+
+  // Parse out the host and path.
+  size_t host_start_pos = scheme_end_pos;
+  size_t path_start_pos = 0;
+
+  if (!standard_scheme) {
+    path_start_pos = host_start_pos;
+  } else if (scheme_ == url::kFileScheme) {
+    size_t host_end_pos = pattern.find(kPathSeparator, host_start_pos);
+    if (host_end_pos == base::StringPiece::npos) {
+      // Allow hostname omission.
+      // e.g. file://* is interpreted as file:///*,
+      // file://foo* is interpreted as file:///foo*.
+      path_start_pos = host_start_pos - 1;
+    } else {
+      // Ignore hostname if scheme is file://.
+      // e.g. file://localhost/foo is equal to file:///foo.
+      path_start_pos = host_end_pos;
+    }
+  } else {
+    size_t host_end_pos = pattern.find(kPathSeparator, host_start_pos);
+
+    // Host is required.
+    if (host_start_pos == host_end_pos)
+      return ParseResult::kEmptyHost;
+
+    if (host_end_pos == base::StringPiece::npos)
+      return ParseResult::kEmptyPath;
+
+    base::StringPiece host_and_port =
+        pattern.substr(host_start_pos, host_end_pos - host_start_pos);
+
+    size_t port_separator_pos = base::StringPiece::npos;
+    if (host_and_port[0] != '[') {
+      // Not IPv6 (either IPv4 or just a normal address).
+      port_separator_pos = host_and_port.find(':');
+    } else {  // IPv6.
+      size_t host_end_pos = host_and_port.find(']');
+      if (host_end_pos == base::StringPiece::npos)
+        return ParseResult::kInvalidHost;
+      if (host_end_pos == 1)
+        return ParseResult::kEmptyHost;
+
+      if (host_end_pos < host_and_port.length() - 1) {
+        // The host isn't the only component. Check for a port. This would
+        // require a ':' to follow the closing ']' from the host.
+        if (host_and_port[host_end_pos + 1] != ':')
+          return ParseResult::kInvalidHost;
+
+        port_separator_pos = host_end_pos + 1;
+      }
+    }
+
+    if (port_separator_pos != base::StringPiece::npos &&
+        !SetPort(host_and_port.substr(port_separator_pos + 1))) {
+      return ParseResult::kInvalidPort;
+    }
+
+    // Note: this substr() will be the entire string if the port position
+    // wasn't found.
+    base::StringPiece host_piece = host_and_port.substr(0, port_separator_pos);
+
+    if (host_piece.empty())
+      return ParseResult::kEmptyHost;
+
+    if (host_piece == "*") {
+      match_subdomains_ = true;
+      host_piece = base::StringPiece();
+    } else if (base::StartsWith(host_piece, "*.")) {
+      if (host_piece.length() == 2) {
+        // We don't allow just '*.' as a host.
+        return ParseResult::kEmptyHost;
+      }
+      match_subdomains_ = true;
+      host_piece = host_piece.substr(2);
+    }
+
+    host_ = host_piece.as_string();
+
+    path_start_pos = host_end_pos;
+  }
+
+  SetPath(pattern.substr(path_start_pos));
+
+  // No other '*' can occur in the host, though. This isn't necessary, but is
+  // done as a convenience to developers who might otherwise be confused and
+  // think '*' works as a glob in the host.
+  if (host_.find('*') != std::string::npos)
+    return ParseResult::kInvalidHostWildcard;
+
+  if (!host_.empty()) {
+    // If |host_| is present (i.e., isn't a wildcard), we need to canonicalize
+    // it.
+    url::CanonHostInfo host_info;
+    host_ = net::CanonicalizeHost(host_, &host_info);
+    // net::CanonicalizeHost() returns an empty string on failure.
+    if (host_.empty())
+      return ParseResult::kInvalidHost;
+  }
+
+  // Null characters are not allowed in hosts.
+  if (host_.find('\0') != std::string::npos)
+    return ParseResult::kInvalidHost;
+
+  return ParseResult::kSuccess;
+}
+
+void URLPattern::SetValidSchemes(int valid_schemes) {
+  // TODO(devlin): Should we check that valid_schemes agrees with |scheme_|
+  // here? Otherwise, valid_schemes_ and schemes_ may stop agreeing with each
+  // other (e.g., in the case of `*://*/*`, where the scheme should only be
+  // http or https).
+  spec_.clear();
+  valid_schemes_ = valid_schemes;
+}
+
+void URLPattern::SetHost(base::StringPiece host) {
+  spec_.clear();
+  host_.assign(host.data(), host.size());
+}
+
+void URLPattern::SetMatchAllURLs(bool val) {
+  spec_.clear();
+  match_all_urls_ = val;
+
+  if (val) {
+    match_subdomains_ = true;
+    scheme_ = "*";
+    host_.clear();
+    SetPath("/*");
+  }
+}
+
+void URLPattern::SetMatchSubdomains(bool val) {
+  spec_.clear();
+  match_subdomains_ = val;
+}
+
+bool URLPattern::SetScheme(base::StringPiece scheme) {
+  spec_.clear();
+  scheme_.assign(scheme.data(), scheme.size());
+  if (scheme_ == "*") {
+    valid_schemes_ &= (SCHEME_HTTP | SCHEME_HTTPS);
+  } else if (!IsValidScheme(scheme_)) {
+    return false;
+  }
+  return true;
+}
+
+bool URLPattern::IsValidScheme(base::StringPiece scheme) const {
+  if (valid_schemes_ == SCHEME_ALL)
+    return true;
+
+  for (size_t i = 0; i < base::size(kValidSchemes); ++i) {
+    if (scheme == kValidSchemes[i] && (valid_schemes_ & kValidSchemeMasks[i]))
+      return true;
+  }
+
+  return false;
+}
+
+void URLPattern::SetPath(base::StringPiece path) {
+  spec_.clear();
+  path_.assign(path.data(), path.size());
+  path_escaped_ = path_;
+  base::ReplaceSubstringsAfterOffset(&path_escaped_, 0, "\\", "\\\\");
+  base::ReplaceSubstringsAfterOffset(&path_escaped_, 0, "?", "\\?");
+}
+
+bool URLPattern::SetPort(base::StringPiece port) {
+  spec_.clear();
+  if (IsValidPortForScheme(scheme_, port)) {
+    port_.assign(port.data(), port.size());
+    return true;
+  }
+  return false;
+}
+
+bool URLPattern::MatchesURL(const GURL& test) const {
+  // Invalid URLs can never match.
+  if (!test.is_valid())
+    return false;
+
+  const GURL* test_url = &test;
+  bool has_inner_url = test.inner_url() != nullptr;
+
+  if (has_inner_url) {
+    if (!test.SchemeIsFileSystem())
+      return false;  // The only nested URLs we handle are filesystem URLs.
+    test_url = test.inner_url();
+  }
+
+  // Ensure the scheme matches first, since <all_urls> may not match this URL if
+  // the scheme is excluded.
+  if (!MatchesScheme(test_url->scheme_piece()))
+    return false;
+
+  if (match_all_urls_)
+    return true;
+
+  // Unless |match_all_urls_| is true, the grammar only permits matching
+  // URLs with nonempty paths.
+  if (!test.has_path())
+    return false;
+
+  std::string path_for_request = test.PathForRequest();
+  if (has_inner_url) {
+    path_for_request = base::StringPrintf("%s%s", test_url->path_piece().data(),
+                                          path_for_request.c_str());
+  }
+
+  return MatchesSecurityOriginHelper(*test_url) &&
+         MatchesPath(path_for_request);
+}
+
+bool URLPattern::MatchesSecurityOrigin(const GURL& test) const {
+  const GURL* test_url = &test;
+  bool has_inner_url = test.inner_url() != NULL;
+
+  if (has_inner_url) {
+    if (!test.SchemeIsFileSystem())
+      return false;  // The only nested URLs we handle are filesystem URLs.
+    test_url = test.inner_url();
+  }
+
+  if (!MatchesScheme(test_url->scheme()))
+    return false;
+
+  if (match_all_urls_)
+    return true;
+
+  return MatchesSecurityOriginHelper(*test_url);
+}
+
+bool URLPattern::MatchesScheme(base::StringPiece test) const {
+  if (!IsValidScheme(test))
+    return false;
+
+  return scheme_ == "*" || test == scheme_;
+}
+
+bool URLPattern::MatchesHost(base::StringPiece host) const {
+  // TODO(devlin): This is a bit sad. Parsing urls is expensive. However, it's
+  // important that we do this conversion to a GURL in order to canonicalize the
+  // host (the pattern's host_ already is canonicalized from Parse()). We can't
+  // just do string comparison.
+  return MatchesHost(
+      GURL(base::StringPrintf("%s%s%s/", url::kHttpScheme,
+                              url::kStandardSchemeSeparator, host.data())));
+}
+
+bool URLPattern::MatchesHost(const GURL& test) const {
+  base::StringPiece test_host(CanonicalizeHostForMatching(test.host_piece()));
+  const base::StringPiece pattern_host(CanonicalizeHostForMatching(host_));
+
+  // If the hosts are exactly equal, we have a match.
+  if (test_host == pattern_host)
+    return true;
+
+  // If we're matching subdomains, and we have no host in the match pattern,
+  // that means that we're matching all hosts, which means we have a match no
+  // matter what the test host is.
+  if (match_subdomains_ && pattern_host.empty())
+    return true;
+
+  // Otherwise, we can only match if our match pattern matches subdomains.
+  if (!match_subdomains_)
+    return false;
+
+  // We don't do subdomain matching against IP addresses, so we can give up now
+  // if the test host is an IP address.
+  if (test.HostIsIPAddress())
+    return false;
+
+  // Check if the test host is a subdomain of our host.
+  if (test_host.length() <= (pattern_host.length() + 1))
+    return false;
+
+  if (!base::EndsWith(test_host, pattern_host))
+    return false;
+
+  return test_host[test_host.length() - pattern_host.length() - 1] == '.';
+}
+
+bool URLPattern::MatchesEffectiveTld(
+    net::registry_controlled_domains::PrivateRegistryFilter private_filter,
+    net::registry_controlled_domains::UnknownRegistryFilter unknown_filter)
+    const {
+  // Check if it matches all urls or is a pattern like http://*/*.
+  if (match_all_urls_ || (match_subdomains_ && host_.empty()))
+    return true;
+
+  // If this doesn't even match subdomains, it can't possibly be a TLD wildcard.
+  if (!match_subdomains_)
+    return false;
+
+  // If there was more than just a TLD in the host (e.g., *.foobar.com), it
+  // doesn't match all hosts in an effective TLD.
+  if (net::registry_controlled_domains::HostHasRegistryControlledDomain(
+          host_, unknown_filter, private_filter)) {
+    return false;
+  }
+
+  // At this point the host could either be just a TLD ("com") or some unknown
+  // TLD-like string ("notatld"). To disambiguate between them construct a
+  // fake URL, and check the registry.
+  //
+  // If we recognized this TLD, then this is a pattern like *.com, and it
+  // matches an effective TLD.
+  return net::registry_controlled_domains::HostHasRegistryControlledDomain(
+      "notatld." + host_, unknown_filter, private_filter);
+}
+
+bool URLPattern::MatchesSingleOrigin() const {
+  // Strictly speaking, the port is part of the origin, but in URLPattern it
+  // defaults to *. It's not very interesting anyway, so leave it out.
+  return !MatchesEffectiveTld() && scheme_ != "*" && !match_subdomains_;
+}
+
+bool URLPattern::MatchesPath(base::StringPiece test) const {
+  // Make the behaviour of OverlapsWith consistent with MatchesURL, which is
+  // need to match hosted apps on e.g. 'google.com' also run on 'google.com/'.
+  // The below if is a no-copy way of doing (test + "/*" == path_escaped_).
+  if (path_escaped_.length() == test.length() + 2 &&
+      base::StartsWith(path_escaped_.c_str(), test) &&
+      base::EndsWith(path_escaped_, "/*")) {
+    return true;
+  }
+
+  return base::MatchPattern(test, path_escaped_);
+}
+
+const std::string& URLPattern::GetAsString() const {
+  if (!spec_.empty())
+    return spec_;
+
+  if (match_all_urls_) {
+    spec_ = kAllUrlsPattern;
+    return spec_;
+  }
+
+  bool standard_scheme = IsStandardScheme(scheme_);
+
+  std::string spec = scheme_ +
+      (standard_scheme ? url::kStandardSchemeSeparator : ":");
+
+  if (scheme_ != url::kFileScheme && standard_scheme) {
+    if (match_subdomains_) {
+      spec += "*";
+      if (!host_.empty())
+        spec += ".";
+    }
+
+    if (!host_.empty())
+      spec += host_;
+
+    if (port_ != "*") {
+      spec += ":";
+      spec += port_;
+    }
+  }
+
+  if (!path_.empty())
+    spec += path_;
+
+  spec_ = std::move(spec);
+  return spec_;
+}
+
+bool URLPattern::OverlapsWith(const URLPattern& other) const {
+  if (match_all_urls() || other.match_all_urls())
+    return true;
+  return (MatchesAnyScheme(other.GetExplicitSchemes()) ||
+          other.MatchesAnyScheme(GetExplicitSchemes()))
+      && (MatchesHost(other.host()) || other.MatchesHost(host()))
+      && (MatchesPortPattern(other.port()) || other.MatchesPortPattern(port()))
+      && (MatchesPath(StripTrailingWildcard(other.path())) ||
+          other.MatchesPath(StripTrailingWildcard(path())));
+}
+
+bool URLPattern::Contains(const URLPattern& other) const {
+  // Important: it's not enough to just check match_all_urls(); we also need to
+  // make sure that the schemes in this pattern are a superset of those in
+  // |other|.
+  if (match_all_urls() &&
+      (valid_schemes_ & other.valid_schemes_) == other.valid_schemes_) {
+    return true;
+  }
+
+  return MatchesAllSchemes(other.GetExplicitSchemes()) &&
+         MatchesHost(other.host()) &&
+         (!other.match_subdomains_ || match_subdomains_) &&
+         MatchesPortPattern(other.port()) &&
+         MatchesPath(StripTrailingWildcard(other.path()));
+}
+
+base::Optional<URLPattern> URLPattern::CreateIntersection(
+    const URLPattern& other) const {
+  // Easy case: Schemes don't overlap. Return nullopt.
+  int intersection_schemes = URLPattern::SCHEME_NONE;
+  if (valid_schemes_ == URLPattern::SCHEME_ALL)
+    intersection_schemes = other.valid_schemes_;
+  else if (other.valid_schemes_ == URLPattern::SCHEME_ALL)
+    intersection_schemes = valid_schemes_;
+  else
+    intersection_schemes = valid_schemes_ & other.valid_schemes_;
+
+  if (intersection_schemes == URLPattern::SCHEME_NONE)
+    return base::nullopt;
+
+  {
+    // In a few cases, we can (mostly) return a copy of one of the patterns.
+    // This can happen when either:
+    // - The URLPattern's are identical (possibly excluding valid_schemes_)
+    // - One of the patterns has match_all_urls() equal to true.
+    // NOTE(devlin): Theoretically, we could use Contains() instead of
+    // match_all_urls() here. However, Contains() strips the trailing wildcard
+    // from the path, which could yield the incorrect result.
+    const URLPattern* copy_source = nullptr;
+    if (*this == other || other.match_all_urls())
+      copy_source = this;
+    else if (match_all_urls())
+      copy_source = &other;
+
+    if (copy_source) {
+      // NOTE: equality checks don't take into account valid_schemes_, and
+      // schemes can be different in the case of match_all_urls() as well, so
+      // we can't always just return *copy_source.
+      if (intersection_schemes == copy_source->valid_schemes_)
+        return *copy_source;
+      URLPattern result(intersection_schemes);
+      ParseResult parse_result = result.Parse(copy_source->GetAsString());
+      CHECK_EQ(ParseResult::kSuccess, parse_result);
+      return result;
+    }
+  }
+
+  // No more easy cases. Go through component by component to find the patterns
+  // that intersect.
+
+  // Note: Alias the function type (rather than using auto) because
+  // MatchesHost() is overloaded.
+  using match_function_type = bool (URLPattern::*)(base::StringPiece) const;
+
+  auto get_intersection = [this, &other](base::StringPiece own_str,
+                                         base::StringPiece other_str,
+                                         match_function_type match_function,
+                                         base::StringPiece* out) {
+    if ((this->*match_function)(other_str)) {
+      *out = other_str;
+      return true;
+    }
+    if ((other.*match_function)(own_str)) {
+      *out = own_str;
+      return true;
+    }
+    return false;
+  };
+
+  base::StringPiece scheme;
+  base::StringPiece host;
+  base::StringPiece port;
+  base::StringPiece path;
+  // If any pieces fail to overlap, then there is no intersection.
+  if (!get_intersection(scheme_, other.scheme_, &URLPattern::MatchesScheme,
+                        &scheme) ||
+      !get_intersection(host_, other.host_, &URLPattern::MatchesHost, &host) ||
+      !get_intersection(port_, other.port_, &URLPattern::MatchesPortPattern,
+                        &port) ||
+      !get_intersection(path_, other.path_, &URLPattern::MatchesPath, &path)) {
+    return base::nullopt;
+  }
+
+  // Only match subdomains if both patterns match subdomains.
+  base::StringPiece subdomains;
+  if (match_subdomains_ && other.match_subdomains_) {
+    // The host may be empty (e.g., in the case of *://*/* - in that case, only
+    // append '*' instead of '*.'.
+    subdomains = host.empty() ? "*" : "*.";
+  }
+
+  base::StringPiece scheme_separator =
+      IsStandardScheme(scheme) ? url::kStandardSchemeSeparator : ":";
+
+  std::string pattern_str = base::StrCat(
+      {scheme, scheme_separator, subdomains, host, ":", port, path});
+
+  URLPattern pattern(intersection_schemes);
+  ParseResult result = pattern.Parse(pattern_str);
+  // TODO(devlin): I don't think there's any way this should ever fail, but
+  // use a CHECK() to flush any cases out. If nothing crops up, downgrade this
+  // to a DCHECK in M72.
+  CHECK_EQ(ParseResult::kSuccess, result);
+
+  return pattern;
+}
+
+bool URLPattern::MatchesAnyScheme(
+    const std::vector<std::string>& schemes) const {
+  for (auto i = schemes.cbegin(); i != schemes.cend(); ++i) {
+    if (MatchesScheme(*i))
+      return true;
+  }
+
+  return false;
+}
+
+bool URLPattern::MatchesAllSchemes(
+    const std::vector<std::string>& schemes) const {
+  for (auto i = schemes.cbegin(); i != schemes.cend(); ++i) {
+    if (!MatchesScheme(*i))
+      return false;
+  }
+
+  return true;
+}
+
+bool URLPattern::MatchesSecurityOriginHelper(const GURL& test) const {
+  // Ignore hostname if scheme is file://.
+  if (scheme_ != url::kFileScheme && !MatchesHost(test))
+    return false;
+
+  if (!MatchesPortPattern(base::NumberToString(test.EffectiveIntPort())))
+    return false;
+
+  return true;
+}
+
+bool URLPattern::MatchesPortPattern(base::StringPiece port) const {
+  return port_ == "*" || port_ == port;
+}
+
+std::vector<std::string> URLPattern::GetExplicitSchemes() const {
+  std::vector<std::string> result;
+
+  if (scheme_ != "*" && !match_all_urls_ && IsValidScheme(scheme_)) {
+    result.push_back(scheme_);
+    return result;
+  }
+
+  for (size_t i = 0; i < base::size(kValidSchemes); ++i) {
+    if (MatchesScheme(kValidSchemes[i])) {
+      result.push_back(kValidSchemes[i]);
+    }
+  }
+
+  return result;
+}
+
+std::vector<URLPattern> URLPattern::ConvertToExplicitSchemes() const {
+  std::vector<std::string> explicit_schemes = GetExplicitSchemes();
+  std::vector<URLPattern> result;
+
+  for (std::vector<std::string>::const_iterator i = explicit_schemes.begin();
+       i != explicit_schemes.end(); ++i) {
+    URLPattern temp = *this;
+    temp.SetScheme(*i);
+    temp.SetMatchAllURLs(false);
+    result.push_back(temp);
+  }
+
+  return result;
+}
+
+// static
+const char* URLPattern::GetParseResultString(
+    URLPattern::ParseResult parse_result) {
+  return kParseResultMessages[static_cast<int>(parse_result)];
+}
diff --git a/components/user_scripts/common/url_pattern.h b/components/user_scripts/common/url_pattern.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/url_pattern.h
@@ -0,0 +1,301 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+#ifndef EXTENSIONS_COMMON_URL_PATTERN_H_
+#define EXTENSIONS_COMMON_URL_PATTERN_H_
+
+#include <functional>
+#include <iosfwd>
+#include <string>
+#include <vector>
+
+#include "base/strings/string_piece.h"
+#include "net/base/registry_controlled_domains/registry_controlled_domain.h"
+
+class GURL;
+
+// A pattern that can be used to match URLs. A URLPattern is a very restricted
+// subset of URL syntax:
+//
+// <url-pattern> := <scheme>://<host><port><path> | '<all_urls>'
+// <scheme> := '*' | 'http' | 'https' | 'file' | 'ftp' | 'chrome' |
+//             'chrome-extension' | 'filesystem'
+// <host> := '*' | <IPv4 address> | [<IPv6 address>] |
+//           '*.' <anychar except '/' and '*'>+
+// <port> := [':' ('*' | <port number between 0 and 65535>)]
+// <path> := '/' <any chars>
+//
+// * Host is not used when the scheme is 'file'.
+// * The path can have embedded '*' characters which act as glob wildcards.
+// * '<all_urls>' is a special pattern that matches any valid URL that contains
+//   a valid scheme (as specified by valid_schemes_).
+// * The '*' scheme pattern excludes file URLs.
+//
+// Examples of valid patterns:
+// - http://*/*
+// - http://*/foo*
+// - https://*.google.com/foo*bar
+// - file://monkey*
+// - http://127.0.0.1/*
+// - http://[2607:f8b0:4005:805::200e]/*
+//
+// Examples of invalid patterns:
+// - http://* -- path not specified
+// - http://*foo/bar -- * not allowed as substring of host component
+// - http://foo.*.bar/baz -- * must be first component
+// - http:/bar -- scheme separator not found
+// - foo://* -- invalid scheme
+// - chrome:// -- we don't support chrome internal URLs
+class URLPattern {
+ public:
+  // A collection of scheme bitmasks for use with valid_schemes.
+  enum SchemeMasks {
+    SCHEME_NONE = 0,
+    SCHEME_HTTP = 1 << 0,
+    SCHEME_HTTPS = 1 << 1,
+    SCHEME_FILE = 1 << 2,
+    SCHEME_FTP = 1 << 3,
+    SCHEME_CHROMEUI = 1 << 4,
+    SCHEME_EXTENSION = 1 << 5,
+    SCHEME_FILESYSTEM = 1 << 6,
+    SCHEME_WS = 1 << 7,
+    SCHEME_WSS = 1 << 8,
+    SCHEME_DATA = 1 << 9,
+
+    // IMPORTANT!
+    // SCHEME_ALL will match every scheme, including chrome://, chrome-
+    // extension://, about:, etc. Because this has lots of security
+    // implications, third-party extensions should usually not be able to get
+    // access to URL patterns initialized this way. If there is a reason
+    // for violating this general rule, document why this it safe.
+    SCHEME_ALL = -1,
+  };
+
+  // Error codes returned from Parse().
+  enum class ParseResult {
+    kSuccess = 0,
+    kMissingSchemeSeparator,
+    kInvalidScheme,
+    kWrongSchemeSeparator,
+    kEmptyHost,
+    kInvalidHostWildcard,
+    kEmptyPath,
+    kInvalidPort,
+    kInvalidHost,
+    kNumParseResults,
+  };
+
+  // The <all_urls> string pattern.
+  static const char kAllUrlsPattern[];
+
+  // Returns true if the given |scheme| is considered valid for extensions.
+  static bool IsValidSchemeForExtensions(base::StringPiece scheme);
+
+  // Returns the mask for all schemes considered valid for extensions.
+  static int GetValidSchemeMaskForExtensions();
+
+  explicit URLPattern(int valid_schemes);
+
+  // Convenience to construct a URLPattern from a string. If the string is not
+  // known ahead of time, use Parse() instead, which returns success or failure.
+  URLPattern(int valid_schemes, base::StringPiece pattern);
+
+  URLPattern();
+  URLPattern(const URLPattern& other);
+  URLPattern(URLPattern&& other);
+  ~URLPattern();
+
+  URLPattern& operator=(const URLPattern& other);
+  URLPattern& operator=(URLPattern&& other);
+
+  bool operator<(const URLPattern& other) const;
+  bool operator>(const URLPattern& other) const;
+  bool operator==(const URLPattern& other) const;
+
+  // Initializes this instance by parsing the provided string. Returns
+  // URLPattern::ParseResult::kSuccess on success, or an error code otherwise.
+  // On failure, this instance will have some intermediate values and is in an
+  // invalid state.
+  ParseResult Parse(base::StringPiece pattern_str);
+
+  // Gets the bitmask of valid schemes.
+  int valid_schemes() const { return valid_schemes_; }
+  void SetValidSchemes(int valid_schemes);
+
+  // Gets the host the pattern matches. This can be an empty string if the
+  // pattern matches all hosts (the input was <scheme>://*/<whatever>).
+  const std::string& host() const { return host_; }
+  void SetHost(base::StringPiece host);
+
+  // Gets whether to match subdomains of host().
+  bool match_subdomains() const { return match_subdomains_; }
+  void SetMatchSubdomains(bool val);
+
+  // Gets the path the pattern matches with the leading slash. This can have
+  // embedded asterisks which are interpreted using glob rules.
+  const std::string& path() const { return path_; }
+  void SetPath(base::StringPiece path);
+
+  // Returns true if this pattern matches all (valid) urls.
+  bool match_all_urls() const { return match_all_urls_; }
+  void SetMatchAllURLs(bool val);
+
+  // Sets the scheme for pattern matches. This can be a single '*' if the
+  // pattern matches all valid schemes (as defined by the valid_schemes_
+  // property). Returns false on failure (if the scheme is not valid).
+  bool SetScheme(base::StringPiece scheme);
+  // Note: You should use MatchesScheme() instead of this getter unless you
+  // absolutely need the exact scheme. This is exposed for testing.
+  const std::string& scheme() const { return scheme_; }
+
+  // Returns true if the specified scheme can be used in this URL pattern, and
+  // false otherwise. Uses valid_schemes_ to determine validity.
+  bool IsValidScheme(base::StringPiece scheme) const;
+
+  // Returns true if this instance matches the specified URL. Always returns
+  // false for invalid URLs.
+  bool MatchesURL(const GURL& test) const;
+
+  // Returns true if this instance matches the specified security origin.
+  bool MatchesSecurityOrigin(const GURL& test) const;
+
+  // Returns true if |test| matches our scheme.
+  // Note that if test is "filesystem", this may fail whereas MatchesURL
+  // may succeed.  MatchesURL is smart enough to look at the inner_url instead
+  // of the outer "filesystem:" part.
+  bool MatchesScheme(base::StringPiece test) const;
+
+  // Returns true if |test| matches our host.
+  bool MatchesHost(base::StringPiece test) const;
+  bool MatchesHost(const GURL& test) const;
+
+  // Returns true if |test| matches our path.
+  bool MatchesPath(base::StringPiece test) const;
+
+  // Returns true if the pattern matches all patterns in an (e)TLD. This
+  // includes patterns like *://*.com/*, *://*.co.uk/*, etc. A pattern that
+  // matches all domains (e.g., *://*/*) will return true.
+  // |private_filter| specifies whether private registries (like appspot.com)
+  // should be considered; if included, patterns like *://*.appspot.com/* will
+  // return true. By default, we exclude private registries (so *.appspot.com
+  // returns false).
+  // Note: This is an expensive method, and should be used sparingly!
+  // You should probably use URLPatternSet::ShouldWarnAllHosts(), which is
+  // cached.
+  bool MatchesEffectiveTld(
+      net::registry_controlled_domains::PrivateRegistryFilter private_filter =
+          net::registry_controlled_domains::EXCLUDE_PRIVATE_REGISTRIES,
+      net::registry_controlled_domains::UnknownRegistryFilter unknown_filter =
+          net::registry_controlled_domains::EXCLUDE_UNKNOWN_REGISTRIES) const;
+
+  // Returns true if the pattern only matches a single origin. The pattern may
+  // include a path.
+  bool MatchesSingleOrigin() const;
+
+  // Sets the port. Returns false if the port is invalid.
+  bool SetPort(base::StringPiece port);
+  const std::string& port() const { return port_; }
+
+  // Returns a string representing this instance.
+  const std::string& GetAsString() const;
+
+  // Determines whether there is a URL that would match this instance and
+  // another instance. This method is symmetrical: Calling
+  // other.OverlapsWith(this) would result in the same answer.
+  bool OverlapsWith(const URLPattern& other) const;
+
+  // Returns true if this pattern matches all possible URLs that |other| can
+  // match. For example, http://*.google.com encompasses http://www.google.com.
+  bool Contains(const URLPattern& other) const;
+
+  // Creates a new URLPattern that represents the intersection of this
+  // URLPattern with the |other|, or base::nullopt if no intersection exists.
+  // For instance, given the patterns http://*.google.com/* and
+  // *://maps.google.com/*, the intersection is http://maps.google.com/*.
+  // NOTES:
+  // - Though scheme intersections are supported, the serialization of
+  //   URLPatternSet does not record them. Be sure that this is safe for your
+  //   use cases.
+  // - Path intersection is done on a best-effort basis. If one path clearly
+  //   contains another, it will be handled correctly, but this method does not
+  //   deal with cases like /*a* and /*b* (where technically the intersection
+  //   is /*a*b*|/*b*a*); the intersection returned for that case will be empty.
+  base::Optional<URLPattern> CreateIntersection(const URLPattern& other) const;
+
+  // Converts this URLPattern into an equivalent set of URLPatterns that don't
+  // use a wildcard in the scheme component. If this URLPattern doesn't use a
+  // wildcard scheme, then the returned set will contain one element that is
+  // equivalent to this instance.
+  std::vector<URLPattern> ConvertToExplicitSchemes() const;
+
+  static bool EffectiveHostCompare(const URLPattern& a, const URLPattern& b) {
+    if (a.match_all_urls_ && b.match_all_urls_)
+      return false;
+    return a.host_.compare(b.host_) < 0;
+  }
+
+  // Used for origin comparisons in a std::set.
+  class EffectiveHostCompareFunctor {
+   public:
+    bool operator()(const URLPattern& a, const URLPattern& b) const {
+      return EffectiveHostCompare(a, b);
+    }
+  };
+
+  // Get an error string for a ParseResult.
+  static const char* GetParseResultString(URLPattern::ParseResult parse_result);
+
+ private:
+  // Returns true if any of the |schemes| items matches our scheme.
+  bool MatchesAnyScheme(const std::vector<std::string>& schemes) const;
+
+  // Returns true if all of the |schemes| items matches our scheme.
+  bool MatchesAllSchemes(const std::vector<std::string>& schemes) const;
+
+  bool MatchesSecurityOriginHelper(const GURL& test) const;
+
+  // Returns true if our port matches the |port| pattern (it may be "*").
+  bool MatchesPortPattern(base::StringPiece port) const;
+
+  // If the URLPattern contains a wildcard scheme, returns a list of
+  // equivalent literal schemes, otherwise returns the current scheme.
+  std::vector<std::string> GetExplicitSchemes() const;
+
+  // A bitmask containing the schemes which are considered valid for this
+  // pattern. Parse() uses this to decide whether a pattern contains a valid
+  // scheme.
+  int valid_schemes_;
+
+  // True if this is a special-case "<all_urls>" pattern.
+  bool match_all_urls_;
+
+  // The scheme for the pattern.
+  std::string scheme_;
+
+  // The host without any leading "*" components.
+  std::string host_;
+
+  // Whether we should match subdomains of the host. This is true if the first
+  // component of the pattern's host was "*".
+  bool match_subdomains_;
+
+  // The port.
+  std::string port_;
+
+  // The path to match. This is everything after the host of the URL, or
+  // everything after the scheme in the case of file:// URLs.
+  std::string path_;
+
+  // The path with "?" and "\" characters escaped for use with the
+  // MatchPattern() function.
+  std::string path_escaped_;
+
+  // A string representing this URLPattern.
+  mutable std::string spec_;
+};
+
+std::ostream& operator<<(std::ostream& out, const URLPattern& url_pattern);
+
+typedef std::vector<URLPattern> URLPatternList;
+
+#endif  // EXTENSIONS_COMMON_URL_PATTERN_H_
diff --git a/components/user_scripts/common/url_pattern_set.cc b/components/user_scripts/common/url_pattern_set.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/url_pattern_set.cc
@@ -0,0 +1,327 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "url_pattern_set.h"
+
+#include <iterator>
+#include <ostream>
+
+#include "base/logging.h"
+#include "base/stl_util.h"
+#include "base/values.h"
+#include "error_utils.h"
+#include "url_pattern.h"
+#include "url/gurl.h"
+#include "url/origin.h"
+#include "url/url_constants.h"
+
+namespace user_scripts {
+
+namespace {
+
+const char kInvalidURLPatternError[] = "Invalid url pattern '*'";
+
+}  // namespace
+
+// static
+URLPatternSet URLPatternSet::CreateDifference(const URLPatternSet& set1,
+                                              const URLPatternSet& set2) {
+  return URLPatternSet(base::STLSetDifference<std::set<URLPattern>>(
+      set1.patterns_, set2.patterns_));
+}
+
+// static
+URLPatternSet URLPatternSet::CreateIntersection(
+    const URLPatternSet& set1,
+    const URLPatternSet& set2,
+    IntersectionBehavior intersection_behavior) {
+  // Note: leverage return value optimization; always return the same object.
+  URLPatternSet result;
+
+  if (intersection_behavior == IntersectionBehavior::kStringComparison) {
+    // String comparison just relies on STL set behavior, which looks at the
+    // string representation.
+    result = URLPatternSet(base::STLSetIntersection<std::set<URLPattern>>(
+        set1.patterns_, set2.patterns_));
+    return result;
+  }
+
+  // Look for a semantic intersection.
+
+  // Step 1: Iterate over each set. Find any patterns that are completely
+  // contained by the other (thus being necessarily present in any intersection)
+  // and add them, collecting the others in a set of unique items.
+  // Note: Use a collection of pointers for the uniques to avoid excessive
+  // copies. Since these are owned by the URLPatternSet passed in, which is
+  // const, this should be safe.
+  std::vector<const URLPattern*> unique_set1;
+  for (const URLPattern& pattern : set1) {
+    if (set2.ContainsPattern(pattern))
+      result.patterns_.insert(pattern);
+    else
+      unique_set1.push_back(&pattern);
+  }
+  std::vector<const URLPattern*> unique_set2;
+  for (const URLPattern& pattern : set2) {
+    if (set1.ContainsPattern(pattern))
+      result.patterns_.insert(pattern);
+    else
+      unique_set2.push_back(&pattern);
+  }
+
+  // If we're just looking for patterns contained by both, we're done.
+  if (intersection_behavior == IntersectionBehavior::kPatternsContainedByBoth)
+    return result;
+
+  DCHECK_EQ(IntersectionBehavior::kDetailed, intersection_behavior);
+
+  // Step 2: Iterate over all the unique patterns and find the intersections
+  // they have with the other patterns.
+  for (const auto* pattern : unique_set1) {
+    for (const auto* pattern2 : unique_set2) {
+      base::Optional<URLPattern> intersection =
+          pattern->CreateIntersection(*pattern2);
+      if (intersection)
+        result.patterns_.insert(std::move(*intersection));
+    }
+  }
+
+  return result;
+}
+
+// static
+URLPatternSet URLPatternSet::CreateUnion(const URLPatternSet& set1,
+                                         const URLPatternSet& set2) {
+  return URLPatternSet(
+      base::STLSetUnion<std::set<URLPattern>>(set1.patterns_, set2.patterns_));
+}
+
+// static
+URLPatternSet URLPatternSet::CreateUnion(
+    const std::vector<URLPatternSet>& sets) {
+  URLPatternSet result;
+  if (sets.empty())
+    return result;
+
+  // N-way union algorithm is basic O(nlog(n)) merge algorithm.
+  //
+  // Do the first merge step into a working set so that we don't mutate any of
+  // the input.
+  // TODO(devlin): Looks like this creates a bunch of copies; we can probably
+  // clean that up.
+  std::vector<URLPatternSet> working;
+  for (size_t i = 0; i < sets.size(); i += 2) {
+    if (i + 1 < sets.size())
+      working.push_back(CreateUnion(sets[i], sets[i + 1]));
+    else
+      working.push_back(sets[i].Clone());
+  }
+
+  for (size_t skip = 1; skip < working.size(); skip *= 2) {
+    for (size_t i = 0; i < (working.size() - skip); i += skip) {
+      URLPatternSet u = CreateUnion(working[i], working[i + skip]);
+      working[i].patterns_.swap(u.patterns_);
+    }
+  }
+
+  result.patterns_.swap(working[0].patterns_);
+  return result;
+}
+
+URLPatternSet::URLPatternSet() = default;
+
+URLPatternSet::URLPatternSet(URLPatternSet&& rhs) = default;
+
+URLPatternSet::URLPatternSet(const std::set<URLPattern>& patterns)
+    : patterns_(patterns) {}
+
+URLPatternSet::~URLPatternSet() = default;
+
+URLPatternSet& URLPatternSet::operator=(URLPatternSet&& rhs) = default;
+
+bool URLPatternSet::operator==(const URLPatternSet& other) const {
+  return patterns_ == other.patterns_;
+}
+
+std::ostream& operator<<(std::ostream& out,
+                         const URLPatternSet& url_pattern_set) {
+  out << "{ ";
+
+  auto iter = url_pattern_set.patterns().cbegin();
+  if (!url_pattern_set.patterns().empty()) {
+    out << *iter;
+    ++iter;
+  }
+
+  for (;iter != url_pattern_set.patterns().end(); ++iter)
+    out << ", " << *iter;
+
+  if (!url_pattern_set.patterns().empty())
+    out << " ";
+
+  out << "}";
+  return out;
+}
+
+URLPatternSet URLPatternSet::Clone() const {
+  return URLPatternSet(patterns_);
+}
+
+bool URLPatternSet::is_empty() const {
+  return patterns_.empty();
+}
+
+size_t URLPatternSet::size() const {
+  return patterns_.size();
+}
+
+bool URLPatternSet::AddPattern(const URLPattern& pattern) {
+  return patterns_.insert(pattern).second;
+}
+
+void URLPatternSet::AddPatterns(const URLPatternSet& set) {
+  patterns_.insert(set.patterns().begin(),
+                   set.patterns().end());
+}
+
+void URLPatternSet::ClearPatterns() {
+  patterns_.clear();
+}
+
+bool URLPatternSet::AddOrigin(int valid_schemes, const GURL& origin) {
+  if (origin.is_empty())
+    return false;
+  const url::Origin real_origin = url::Origin::Create(origin);
+  DCHECK(real_origin.IsSameOriginWith(url::Origin::Create(origin.GetOrigin())));
+  URLPattern origin_pattern(valid_schemes);
+  // Origin adding could fail if |origin| does not match |valid_schemes|.
+  if (origin_pattern.Parse(origin.spec()) !=
+      URLPattern::ParseResult::kSuccess) {
+    return false;
+  }
+  origin_pattern.SetPath("/*");
+  return AddPattern(origin_pattern);
+}
+
+bool URLPatternSet::Contains(const URLPatternSet& other) const {
+  for (auto it = other.begin(); it != other.end(); ++it) {
+    if (!ContainsPattern(*it))
+      return false;
+  }
+
+  return true;
+}
+
+bool URLPatternSet::ContainsPattern(const URLPattern& pattern) const {
+  for (auto it = begin(); it != end(); ++it) {
+    if (it->Contains(pattern))
+      return true;
+  }
+  return false;
+}
+
+bool URLPatternSet::MatchesURL(const GURL& url) const {
+  LOG(INFO) << "---URLPatternSet::MatchesURL  " << url.spec();
+
+  for (auto pattern = patterns_.cbegin(); pattern != patterns_.cend();
+       ++pattern) {
+    if (pattern->MatchesURL(url)) {
+      LOG(INFO) << "---URLPatternSet::MatchesURL    true";
+      return true;
+    }
+  }
+
+  LOG(INFO) << "---URLPatternSet::MatchesURL    false";
+  return false;
+}
+
+bool URLPatternSet::MatchesAllURLs() const {
+  for (auto host = begin(); host != end(); ++host) {
+    if (host->match_all_urls() ||
+        (host->match_subdomains() && host->host().empty()))
+      return true;
+  }
+  return false;
+}
+
+bool URLPatternSet::MatchesSecurityOrigin(const GURL& origin) const {
+  for (auto pattern = patterns_.begin(); pattern != patterns_.end();
+       ++pattern) {
+    if (pattern->MatchesSecurityOrigin(origin))
+      return true;
+  }
+
+  return false;
+}
+
+bool URLPatternSet::OverlapsWith(const URLPatternSet& other) const {
+  // Two extension extents overlap if there is any one URL that would match at
+  // least one pattern in each of the extents.
+  for (auto i = patterns_.cbegin(); i != patterns_.cend(); ++i) {
+    for (auto j = other.patterns().cbegin(); j != other.patterns().cend();
+         ++j) {
+      if (i->OverlapsWith(*j))
+        return true;
+    }
+  }
+
+  return false;
+}
+
+std::unique_ptr<base::ListValue> URLPatternSet::ToValue() const {
+  std::unique_ptr<base::ListValue> value(new base::ListValue);
+  for (auto i = patterns_.cbegin(); i != patterns_.cend(); ++i)
+    value->AppendIfNotPresent(std::make_unique<base::Value>(i->GetAsString()));
+  return value;
+}
+
+bool URLPatternSet::Populate(const std::vector<std::string>& patterns,
+                             int valid_schemes,
+                             bool allow_file_access,
+                             std::string* error) {
+  ClearPatterns();
+  for (size_t i = 0; i < patterns.size(); ++i) {
+    URLPattern pattern(valid_schemes);
+    if (pattern.Parse(patterns[i]) != URLPattern::ParseResult::kSuccess) {
+      if (error) {
+        *error = ErrorUtils::FormatErrorMessage(kInvalidURLPatternError,
+                                                patterns[i]);
+      } else {
+        LOG(ERROR) << "Invalid url pattern: " << patterns[i];
+      }
+      return false;
+    }
+    if (!allow_file_access && pattern.MatchesScheme(url::kFileScheme)) {
+      pattern.SetValidSchemes(
+          pattern.valid_schemes() & ~URLPattern::SCHEME_FILE);
+    }
+    AddPattern(pattern);
+  }
+  return true;
+}
+
+std::unique_ptr<std::vector<std::string>> URLPatternSet::ToStringVector()
+    const {
+  std::unique_ptr<std::vector<std::string>> value(new std::vector<std::string>);
+  for (auto i = patterns_.cbegin(); i != patterns_.cend(); ++i) {
+    value->push_back(i->GetAsString());
+  }
+  return value;
+}
+
+bool URLPatternSet::Populate(const base::ListValue& value,
+                             int valid_schemes,
+                             bool allow_file_access,
+                             std::string* error) {
+  std::vector<std::string> patterns;
+  for (size_t i = 0; i < value.GetSize(); ++i) {
+    std::string item;
+    if (!value.GetString(i, &item))
+      return false;
+    patterns.push_back(item);
+  }
+  return Populate(patterns, valid_schemes, allow_file_access, error);
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/common/url_pattern_set.h b/components/user_scripts/common/url_pattern_set.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/url_pattern_set.h
@@ -0,0 +1,161 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_COMMON_URL_PATTERN_SET_H_
+#define EXTENSIONS_COMMON_URL_PATTERN_SET_H_
+
+#include <stddef.h>
+
+#include <iosfwd>
+#include <memory>
+#include <set>
+
+#include "base/macros.h"
+#include "url_pattern.h"
+
+class GURL;
+
+namespace base {
+class ListValue;
+class Value;
+}
+
+namespace user_scripts {
+
+// Represents the set of URLs an extension uses for web content.
+class URLPatternSet {
+ public:
+  typedef std::set<URLPattern>::const_iterator const_iterator;
+  typedef std::set<URLPattern>::iterator iterator;
+
+  // Returns |set1| - |set2|.
+  static URLPatternSet CreateDifference(const URLPatternSet& set1,
+                                        const URLPatternSet& set2);
+
+  enum class IntersectionBehavior {
+    // For the following descriptions, consider the two URLPatternSets:
+    // Set 1: {"https://example.com/*", "https://*.google.com/*", "http://*/*"}
+    // Set 2: {"https://example.com/*", "https://google.com/maps",
+    //         "*://chromium.org/*"}
+
+    // Only includes patterns that are exactly in both sets. The intersection of
+    // the two sets above is {"https://example.com/*"}, since that is the only
+    // pattern that appears exactly in each.
+    kStringComparison,
+
+    // Includes patterns that are effectively contained by both sets. The
+    // intersection of the two sets above is
+    // {
+    //   "https://example.com/*" (contained exactly by each set)
+    //   "https://google.com/maps" (contained exactly by set 2 and a strict
+    //                              subset of https://*.google.com/* in set 1)
+    // }
+    kPatternsContainedByBoth,
+
+    // Includes patterns that are contained by both sets and creates new
+    // patterns to represent the intersection of any others. The intersection of
+    // the two sets above is
+    // {
+    //   "https://example.com/*" (contained exactly by each set)
+    //   "https://google.com/maps" (contained exactly by set 2 and a strict
+    //                              subset of https://*.google.com/* in set 1)
+    //   "http://chromium.org/*" (the overlap between "http://*/*" in set 1 and
+    //                            *://chromium.org/*" in set 2).
+    // }
+    // Note that this is the most computationally expensive - potentially
+    // O(n^2) - since it can require comparing each pattern in one set to every
+    // pattern in the other set.
+    kDetailed,
+  };
+
+  // Returns the intersection of |set1| and |set2| according to
+  // |intersection_behavior|.
+  static URLPatternSet CreateIntersection(
+      const URLPatternSet& set1,
+      const URLPatternSet& set2,
+      IntersectionBehavior intersection_behavior);
+
+  // Returns the union of |set1| and |set2|.
+  static URLPatternSet CreateUnion(const URLPatternSet& set1,
+                                   const URLPatternSet& set2);
+
+  // Returns the union of all sets in |sets|.
+  static URLPatternSet CreateUnion(const std::vector<URLPatternSet>& sets);
+
+  URLPatternSet();
+  URLPatternSet(URLPatternSet&& rhs);
+  explicit URLPatternSet(const std::set<URLPattern>& patterns);
+  ~URLPatternSet();
+
+  URLPatternSet& operator=(URLPatternSet&& rhs);
+  bool operator==(const URLPatternSet& rhs) const;
+
+  bool is_empty() const;
+  size_t size() const;
+  const std::set<URLPattern>& patterns() const { return patterns_; }
+  const_iterator begin() const { return patterns_.begin(); }
+  const_iterator end() const { return patterns_.end(); }
+  iterator erase(iterator iter) { return patterns_.erase(iter); }
+
+  // Returns a copy of this URLPatternSet; not instrumented as a copy
+  // constructor to avoid accidental/unnecessary copies.
+  URLPatternSet Clone() const;
+
+  // Adds a pattern to the set. Returns true if a new pattern was inserted,
+  // false if the pattern was already in the set.
+  bool AddPattern(const URLPattern& pattern);
+
+  // Adds all patterns from |set| into this.
+  void AddPatterns(const URLPatternSet& set);
+
+  void ClearPatterns();
+
+  // Adds a pattern based on |origin| to the set.
+  bool AddOrigin(int valid_schemes, const GURL& origin);
+
+  // Returns true if every URL that matches |set| is matched by this. In other
+  // words, if every pattern in |set| is encompassed by a pattern in this.
+  bool Contains(const URLPatternSet& set) const;
+
+  // Returns true if any pattern in this set encompasses |pattern|.
+  bool ContainsPattern(const URLPattern& pattern) const;
+
+  // Test if the extent contains a URL.
+  bool MatchesURL(const GURL& url) const;
+
+  // Test if the extent matches all URLs (for example, <all_urls>).
+  bool MatchesAllURLs() const;
+
+  bool MatchesSecurityOrigin(const GURL& origin) const;
+
+  // Returns true if there is a single URL that would be in two extents.
+  bool OverlapsWith(const URLPatternSet& other) const;
+
+  // Converts to and from Value for serialization to preferences.
+  std::unique_ptr<base::ListValue> ToValue() const;
+  bool Populate(const base::ListValue& value,
+                int valid_schemes,
+                bool allow_file_access,
+                std::string* error);
+
+  // Converts to and from a vector of strings.
+  std::unique_ptr<std::vector<std::string>> ToStringVector() const;
+  bool Populate(const std::vector<std::string>& patterns,
+                int valid_schemes,
+                bool allow_file_access,
+                std::string* error);
+
+ private:
+  // The list of URL patterns that comprise the extent.
+  std::set<URLPattern> patterns_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLPatternSet);
+};
+
+std::ostream& operator<<(std::ostream& out,
+                         const URLPatternSet& url_pattern_set);
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_COMMON_URL_PATTERN_SET_H_
diff --git a/components/user_scripts/common/user_script.cc b/components/user_scripts/common/user_script.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/user_script.cc
@@ -0,0 +1,337 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "user_script.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <memory>
+#include <utility>
+
+#include "base/atomic_sequence_num.h"
+#include "base/command_line.h"
+#include "base/pickle.h"
+#include "base/strings/pattern.h"
+#include "base/strings/string_util.h"
+//#include "switches.h"
+
+namespace {
+
+// This cannot be a plain int or int64_t because we need to generate unique IDs
+// from multiple threads.
+base::AtomicSequenceNumber g_user_script_id_generator;
+
+bool UrlMatchesGlobs(const std::vector<std::string>* globs,
+                     const GURL& url) {
+  for (auto glob = globs->cbegin(); glob != globs->cend(); ++glob) {
+    if (base::MatchPattern(url.spec(), *glob))
+      return true;
+  }
+
+  return false;
+}
+
+}  // namespace
+
+namespace user_scripts {
+
+// The bitmask for valid user script injectable schemes used by URLPattern.
+enum {
+  kValidUserScriptSchemes = //URLPattern::SCHEME_CHROMEUI |
+                            URLPattern::SCHEME_HTTP |
+                            URLPattern::SCHEME_HTTPS
+                            //| URLPattern::SCHEME_FILE |
+                            //URLPattern::SCHEME_FTP
+};
+
+// static
+const char UserScript::kFileExtension[] = ".user.js";
+
+// static
+int UserScript::GenerateUserScriptID() {
+  return g_user_script_id_generator.GetNext();
+}
+
+bool UserScript::IsURLUserScript(const GURL& url,
+                                 const std::string& mime_type) {
+  return base::EndsWith(url.ExtractFileName(), kFileExtension,
+                        base::CompareCase::INSENSITIVE_ASCII) &&
+         mime_type != "text/html";
+}
+
+// static
+int UserScript::ValidUserScriptSchemes(bool canExecuteScriptEverywhere) {
+  if (canExecuteScriptEverywhere)
+    return URLPattern::SCHEME_ALL;
+  int valid_schemes = kValidUserScriptSchemes;
+  // if (!base::CommandLine::ForCurrentProcess()->HasSwitch(
+  //         switches::kExtensionsOnChromeURLs)) {
+  //   valid_schemes &= ~URLPattern::SCHEME_CHROMEUI;
+  // }
+  return valid_schemes;
+}
+
+UserScript::File::File(const base::FilePath& extension_root,
+                       const base::FilePath& relative_path,
+                       const GURL& url)
+    : extension_root_(extension_root),
+      relative_path_(relative_path),
+      url_(url) {
+}
+
+UserScript::File::File() {}
+
+// File content is not copied.
+UserScript::File::File(const File& other)
+    : extension_root_(other.extension_root_),
+      relative_path_(other.relative_path_),
+      url_(other.url_) {}
+
+UserScript::File::~File() {}
+
+UserScript::UserScript() = default;
+UserScript::~UserScript() = default;
+
+// static.
+std::unique_ptr<UserScript> UserScript::CopyMetadataFrom(
+    const UserScript& other) {
+  std::unique_ptr<UserScript> script(new UserScript());
+  script->run_location_ = other.run_location_;
+  script->name_space_ = other.name_space_;
+  script->name_ = other.name_;
+  script->description_ = other.description_;
+  script->version_ = other.version_;
+  script->globs_ = other.globs_;
+  script->exclude_globs_ = other.exclude_globs_;
+  script->url_set_ = other.url_set_.Clone();
+  script->exclude_url_set_ = other.exclude_url_set_.Clone();
+
+  // Note: File content is not copied.
+  for (const std::unique_ptr<File>& file : other.js_scripts()) {
+    std::unique_ptr<File> file_copy(new File(*file));
+    script->js_scripts_.push_back(std::move(file_copy));
+  }
+  for (const std::unique_ptr<File>& file : other.css_scripts()) {
+    std::unique_ptr<File> file_copy(new File(*file));
+    script->css_scripts_.push_back(std::move(file_copy));
+  }
+  script->host_id_ = other.host_id_;
+  script->consumer_instance_type_ = other.consumer_instance_type_;
+  script->user_script_id_ = other.user_script_id_;
+  script->emulate_greasemonkey_ = other.emulate_greasemonkey_;
+  script->match_all_frames_ = other.match_all_frames_;
+  script->match_origin_as_fallback_ = other.match_origin_as_fallback_;
+  script->incognito_enabled_ = other.incognito_enabled_;
+
+  return script;
+}
+
+void UserScript::add_url_pattern(const URLPattern& pattern) {
+  url_set_.AddPattern(pattern);
+}
+
+void UserScript::add_exclude_url_pattern(const URLPattern& pattern) {
+  exclude_url_set_.AddPattern(pattern);
+}
+
+bool UserScript::MatchesURL(const GURL& url) const {
+  if (!url_set_.is_empty()) {
+    if (!url_set_.MatchesURL(url))
+      return false;
+  }
+
+  if (!exclude_url_set_.is_empty()) {
+    if (exclude_url_set_.MatchesURL(url))
+      return false;
+  }
+
+  if (!globs_.empty()) {
+    if (!UrlMatchesGlobs(&globs_, url))
+      return false;
+  }
+
+  if (!exclude_globs_.empty()) {
+    if (UrlMatchesGlobs(&exclude_globs_, url))
+      return false;
+  }
+
+  return true;
+}
+
+bool UserScript::MatchesDocument(const GURL& effective_document_url,
+                                 bool is_subframe) const {
+  if (is_subframe && !match_all_frames())
+    return false;
+
+  return MatchesURL(effective_document_url);
+}
+
+void UserScript::File::Pickle(base::Pickle* pickle) const {
+  pickle->WriteString(url_.spec());
+  // Do not write path. It's not needed in the renderer.
+  // Do not write content. It will be serialized by other means.
+}
+
+void UserScript::File::Unpickle(const base::Pickle& pickle,
+                                base::PickleIterator* iter) {
+  // Read the url from the pickle.
+  std::string url;
+  CHECK(iter->ReadString(&url));
+  set_url(GURL(url));
+}
+
+void UserScript::Pickle(base::Pickle* pickle) const {
+  // Write the simple types to the pickle.
+  pickle->WriteInt(run_location());
+  pickle->WriteInt(user_script_id_);
+  pickle->WriteBool(emulate_greasemonkey());
+  pickle->WriteBool(match_all_frames());
+  pickle->WriteInt(static_cast<int>(match_origin_as_fallback()));
+  pickle->WriteBool(is_incognito_enabled());
+
+  PickleHostID(pickle, host_id_);
+  pickle->WriteInt(consumer_instance_type());
+  PickleGlobs(pickle, globs_);
+  PickleGlobs(pickle, exclude_globs_);
+  PickleURLPatternSet(pickle, url_set_);
+  PickleURLPatternSet(pickle, exclude_url_set_);
+  PickleScripts(pickle, js_scripts_);
+  PickleScripts(pickle, css_scripts_);
+}
+
+void UserScript::PickleGlobs(base::Pickle* pickle,
+                             const std::vector<std::string>& globs) const {
+  pickle->WriteUInt32(globs.size());
+  for (auto glob = globs.cbegin(); glob != globs.cend(); ++glob) {
+    pickle->WriteString(*glob);
+  }
+}
+
+void UserScript::PickleHostID(base::Pickle* pickle,
+                              const HostID& host_id) const {
+  pickle->WriteInt(host_id.type());
+  pickle->WriteString(host_id.id());
+}
+
+void UserScript::PickleURLPatternSet(base::Pickle* pickle,
+                                     const URLPatternSet& pattern_list) const {
+  pickle->WriteUInt32(pattern_list.patterns().size());
+  for (auto pattern = pattern_list.begin(); pattern != pattern_list.end();
+       ++pattern) {
+    pickle->WriteInt(pattern->valid_schemes());
+    pickle->WriteString(pattern->GetAsString());
+  }
+}
+
+void UserScript::PickleScripts(base::Pickle* pickle,
+                               const FileList& scripts) const {
+  pickle->WriteUInt32(scripts.size());
+  for (const std::unique_ptr<File>& file : scripts)
+    file->Pickle(pickle);
+}
+
+void UserScript::Unpickle(const base::Pickle& pickle,
+                          base::PickleIterator* iter) {
+  // Read the run location.
+  int run_location = 0;
+  CHECK(iter->ReadInt(&run_location));
+  CHECK(run_location >= 0 && run_location < RUN_LOCATION_LAST);
+  run_location_ = static_cast<RunLocation>(run_location);
+
+  CHECK(iter->ReadInt(&user_script_id_));
+  CHECK(iter->ReadBool(&emulate_greasemonkey_));
+  CHECK(iter->ReadBool(&match_all_frames_));
+  int match_origin_as_fallback_int = 0;
+  CHECK(iter->ReadInt(&match_origin_as_fallback_int));
+  match_origin_as_fallback_ =
+      static_cast<MatchOriginAsFallbackBehavior>(match_origin_as_fallback_int);
+  CHECK(iter->ReadBool(&incognito_enabled_));
+
+  UnpickleHostID(pickle, iter, &host_id_);
+
+  int consumer_instance_type = 0;
+  CHECK(iter->ReadInt(&consumer_instance_type));
+  consumer_instance_type_ =
+      static_cast<ConsumerInstanceType>(consumer_instance_type);
+
+  UnpickleGlobs(pickle, iter, &globs_);
+  UnpickleGlobs(pickle, iter, &exclude_globs_);
+  UnpickleURLPatternSet(pickle, iter, &url_set_);
+  UnpickleURLPatternSet(pickle, iter, &exclude_url_set_);
+  UnpickleScripts(pickle, iter, &js_scripts_);
+  UnpickleScripts(pickle, iter, &css_scripts_);
+}
+
+void UserScript::UnpickleGlobs(const base::Pickle& pickle,
+                               base::PickleIterator* iter,
+                               std::vector<std::string>* globs) {
+  uint32_t num_globs = 0;
+  CHECK(iter->ReadUInt32(&num_globs));
+  globs->clear();
+  for (uint32_t i = 0; i < num_globs; ++i) {
+    std::string glob;
+    CHECK(iter->ReadString(&glob));
+    globs->push_back(glob);
+  }
+}
+
+void UserScript::UnpickleHostID(const base::Pickle& pickle,
+                                base::PickleIterator* iter,
+                                HostID* host_id) {
+  int type = 0;
+  std::string id;
+  CHECK(iter->ReadInt(&type));
+  CHECK(iter->ReadString(&id));
+  *host_id = HostID(static_cast<HostID::HostType>(type), id);
+}
+
+void UserScript::UnpickleURLPatternSet(const base::Pickle& pickle,
+                                       base::PickleIterator* iter,
+                                       URLPatternSet* pattern_list) {
+  uint32_t num_patterns = 0;
+  CHECK(iter->ReadUInt32(&num_patterns));
+
+  pattern_list->ClearPatterns();
+  for (uint32_t i = 0; i < num_patterns; ++i) {
+    int valid_schemes;
+    CHECK(iter->ReadInt(&valid_schemes));
+
+    std::string pattern_str;
+    CHECK(iter->ReadString(&pattern_str));
+
+    URLPattern pattern(kValidUserScriptSchemes);
+    URLPattern::ParseResult result = pattern.Parse(pattern_str);
+    CHECK(URLPattern::ParseResult::kSuccess == result)
+        << URLPattern::GetParseResultString(result) << " "
+        << pattern_str.c_str();
+
+    pattern.SetValidSchemes(valid_schemes);
+    pattern_list->AddPattern(pattern);
+  }
+}
+
+void UserScript::UnpickleScripts(const base::Pickle& pickle,
+                                 base::PickleIterator* iter,
+                                 FileList* scripts) {
+  uint32_t num_files = 0;
+  CHECK(iter->ReadUInt32(&num_files));
+  scripts->clear();
+  for (uint32_t i = 0; i < num_files; ++i) {
+    std::unique_ptr<File> file(new File());
+    file->Unpickle(pickle, iter);
+    scripts->push_back(std::move(file));
+  }
+}
+
+UserScriptIDPair::UserScriptIDPair(int id, const HostID& host_id)
+    : id(id), host_id(host_id) {}
+
+UserScriptIDPair::UserScriptIDPair(int id) : id(id), host_id(HostID()) {}
+
+bool operator<(const UserScriptIDPair& a, const UserScriptIDPair& b) {
+  return a.id < b.id;
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/common/user_script.h b/components/user_scripts/common/user_script.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/user_script.h
@@ -0,0 +1,364 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_COMMON_USER_SCRIPT_H_
+#define EXTENSIONS_COMMON_USER_SCRIPT_H_
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/files/file_path.h"
+#include "base/strings/string_piece.h"
+#include "script_constants.h"
+#include "host_id.h"
+#include "url_pattern.h"
+#include "url_pattern_set.h"
+#include "url/gurl.h"
+
+namespace base {
+class Pickle;
+class PickleIterator;
+}
+
+namespace user_scripts {
+
+// Represents a user script, either a standalone one, or one that is part of an
+// extension.
+class UserScript {
+ public:
+  // The file extension for standalone user scripts.
+  static const char kFileExtension[];
+
+  static int GenerateUserScriptID();
+
+  // Check if a URL should be treated as a user script and converted to an
+  // extension.
+  static bool IsURLUserScript(const GURL& url, const std::string& mime_type);
+
+  // Get the valid user script schemes for the current process. If
+  // canExecuteScriptEverywhere is true, this will return ALL_SCHEMES.
+  static int ValidUserScriptSchemes(bool canExecuteScriptEverywhere = false);
+
+  // TODO(rdevlin.cronin) This and RunLocation don't really belong here, since
+  // they are used for more than UserScripts (e.g., tabs.executeScript()).
+  // The type of injected script.
+  enum InjectionType {
+    // A content script specified in the extension's manifest.
+    CONTENT_SCRIPT,
+    // A script injected via, e.g. tabs.executeScript().
+    //PROGRAMMATIC_SCRIPT
+  };
+  // The last type of injected script; used for enum verification in IPC.
+  // Update this if you add more injected script types!
+  static const InjectionType INJECTION_TYPE_LAST = CONTENT_SCRIPT/*PROGRAMMATIC_SCRIPT*/;
+
+  // Locations that user scripts can be run inside the document.
+  // The three run locations must strictly follow each other in both load order
+  // (i.e., start *always* comes before end) and numerically, as we use
+  // arithmetic checking (e.g., curr == last + 1). So, no bitmasks here!!
+  enum RunLocation {
+    UNDEFINED,
+    DOCUMENT_START,  // After the documentElement is created, but before
+                     // anything else happens.
+    DOCUMENT_END,  // After the entire document is parsed. Same as
+                   // DOMContentLoaded.
+    DOCUMENT_IDLE,  // Sometime after DOMContentLoaded, as soon as the document
+                    // is "idle". Currently this uses the simple heuristic of:
+                    // min(DOM_CONTENT_LOADED + TIMEOUT, ONLOAD), but no
+                    // particular injection point is guaranteed.
+    RUN_DEFERRED,  // The user script's injection was deferred for permissions
+                   // reasons, and was executed at a later time.
+    BROWSER_DRIVEN,  // The user script will be injected when triggered by an
+                     // IPC in the browser process.
+    RUN_LOCATION_LAST  // Leave this as the last item.
+  };
+
+  // Holds script file info.
+  class File {
+   public:
+    File(const base::FilePath& extension_root,
+         const base::FilePath& relative_path,
+         const GURL& url);
+    File();
+    File(const File& other);
+    ~File();
+
+    const base::FilePath& extension_root() const { return extension_root_; }
+    const base::FilePath& relative_path() const { return relative_path_; }
+
+    const GURL& url() const { return url_; }
+    void set_url(const GURL& url) { url_ = url; }
+
+    // If external_content_ is set returns it as content otherwise it returns
+    // content_
+    const base::StringPiece GetContent() const {
+      if (external_content_.data())
+        return external_content_;
+      else
+        return content_;
+    }
+    void set_external_content(const base::StringPiece& content) {
+      external_content_ = content;
+    }
+    void set_content(const base::StringPiece& content) {
+      content_.assign(content.begin(), content.end());
+    }
+    
+    const std::string& key() const { return key_; }
+    void set_key(const std::string& key) {
+      key_ = key;
+    }
+
+    // Serialization support. The content and FilePath members will not be
+    // serialized!
+    void Pickle(base::Pickle* pickle) const;
+    void Unpickle(const base::Pickle& pickle, base::PickleIterator* iter);
+
+   private:
+    // Where the script file lives on the disk. We keep the path split so that
+    // it can be localized at will.
+    base::FilePath extension_root_;
+    base::FilePath relative_path_;
+
+    // The url to this script file.
+    GURL url_;
+
+    // The script content. It can be set to either loaded_content_ or
+    // externally allocated string.
+    base::StringPiece external_content_;
+
+    // Set when the content is loaded by LoadContent
+    std::string content_;
+
+    std::string key_;
+  };
+
+  using FileList = std::vector<std::unique_ptr<File>>;
+
+  // Type of a API consumer instance that user scripts will be injected on.
+  enum ConsumerInstanceType { TAB, WEBVIEW };
+
+  // Constructor. Default the run location to document end, which is like
+  // Greasemonkey and probably more useful for typical scripts.
+  UserScript();
+  ~UserScript();
+
+  // Performs a copy of all fields except file contents.
+  static std::unique_ptr<UserScript> CopyMetadataFrom(const UserScript& other);
+
+  const std::string& name_space() const { return name_space_; }
+  void set_name_space(const std::string& name_space) {
+    name_space_ = name_space;
+  }
+
+  const std::string& name() const { return name_; }
+  void set_name(const std::string& name) { name_ = name; }
+
+  const std::string& version() const { return version_; }
+  void set_version(const std::string& version) {
+    version_ = version;
+  }
+
+  const std::string& description() const { return description_; }
+  void set_description(const std::string& description) {
+    description_ = description;
+  }
+
+  // The place in the document to run the script.
+  RunLocation run_location() const { return run_location_; }
+  void set_run_location(RunLocation location) { run_location_ = location; }
+
+  // Whether to emulate greasemonkey when running this script.
+  bool emulate_greasemonkey() const { return emulate_greasemonkey_; }
+  void set_emulate_greasemonkey(bool val) { emulate_greasemonkey_ = val; }
+
+  // Whether to match all frames, or only the top one.
+  bool match_all_frames() const { return match_all_frames_; }
+  void set_match_all_frames(bool val) { match_all_frames_ = val; }
+
+  // Whether to match the origin as a fallback if the URL cannot be used
+  // directly.
+  MatchOriginAsFallbackBehavior match_origin_as_fallback() const {
+    return match_origin_as_fallback_;
+  }
+  void set_match_origin_as_fallback(MatchOriginAsFallbackBehavior val) {
+    match_origin_as_fallback_ = val;
+  }
+
+  // The globs, if any, that determine which pages this script runs against.
+  // These are only used with "standalone" Greasemonkey-like user scripts.
+  const std::vector<std::string>& globs() const { return globs_; }
+  void add_glob(const std::string& glob) { globs_.push_back(glob); }
+  void clear_globs() { globs_.clear(); }
+  const std::vector<std::string>& exclude_globs() const {
+    return exclude_globs_;
+  }
+  void add_exclude_glob(const std::string& glob) {
+    exclude_globs_.push_back(glob);
+  }
+  void clear_exclude_globs() { exclude_globs_.clear(); }
+
+  // The URLPatterns, if any, that determine which pages this script runs
+  // against.
+  const URLPatternSet& url_patterns() const { return url_set_; }
+  void add_url_pattern(const URLPattern& pattern);
+  const URLPatternSet& exclude_url_patterns() const {
+    return exclude_url_set_;
+  }
+  void add_exclude_url_pattern(const URLPattern& pattern);
+
+  // List of js scripts for this user script
+  FileList& js_scripts() { return js_scripts_; }
+  const FileList& js_scripts() const { return js_scripts_; }
+
+  // List of css scripts for this user script
+  FileList& css_scripts() { return css_scripts_; }
+  const FileList& css_scripts() const { return css_scripts_; }
+
+  const std::string& extension_id() const { return host_id_.id(); }
+
+  const HostID& host_id() const { return host_id_; }
+  void set_host_id(const HostID& host_id) { host_id_ = host_id; }
+
+  const ConsumerInstanceType& consumer_instance_type() const {
+    return consumer_instance_type_;
+  }
+  void set_consumer_instance_type(
+      const ConsumerInstanceType& consumer_instance_type) {
+    consumer_instance_type_ = consumer_instance_type;
+  }
+
+  int id() const { return user_script_id_; }
+  void set_id(int id) { user_script_id_ = id; }
+
+  // TODO(lazyboy): Incognito information is extension specific, it doesn't
+  // belong here. We should be able to determine this in the renderer/ where it
+  // is used.
+  bool is_incognito_enabled() const { return incognito_enabled_; }
+  void set_incognito_enabled(bool enabled) { incognito_enabled_ = enabled; }
+
+  // Returns true if the script should be applied to the specified URL, false
+  // otherwise.
+  bool MatchesURL(const GURL& url) const;
+
+  // Returns true if the script should be applied to the given
+  // |effective_document_url|. It is the caller's responsibility to calculate
+  // |effective_document_url| based on match_origin_as_fallback().
+  bool MatchesDocument(const GURL& effective_document_url,
+                       bool is_subframe) const;
+
+  // Serializes the UserScript into a pickle. The content of the scripts and
+  // paths to UserScript::Files will not be serialized!
+  void Pickle(base::Pickle* pickle) const;
+
+  // Deserializes the script from a pickle. Note that this always succeeds
+  // because presumably we were the one that pickled it, and we did it
+  // correctly.
+  void Unpickle(const base::Pickle& pickle, base::PickleIterator* iter);
+
+ private:
+  // base::Pickle helper functions used to pickle the individual types of
+  // components.
+  void PickleGlobs(base::Pickle* pickle,
+                   const std::vector<std::string>& globs) const;
+  void PickleHostID(base::Pickle* pickle, const HostID& host_id) const;
+  void PickleURLPatternSet(base::Pickle* pickle,
+                           const URLPatternSet& pattern_list) const;
+  void PickleScripts(base::Pickle* pickle, const FileList& scripts) const;
+
+  // Unpickle helper functions used to unpickle individual types of components.
+  void UnpickleGlobs(const base::Pickle& pickle,
+                     base::PickleIterator* iter,
+                     std::vector<std::string>* globs);
+  void UnpickleHostID(const base::Pickle& pickle,
+                      base::PickleIterator* iter,
+                      HostID* host_id);
+  void UnpickleURLPatternSet(const base::Pickle& pickle,
+                             base::PickleIterator* iter,
+                             URLPatternSet* pattern_list);
+  void UnpickleScripts(const base::Pickle& pickle,
+                       base::PickleIterator* iter,
+                       FileList* scripts);
+
+  // The location to run the script inside the document.
+  RunLocation run_location_ = DOCUMENT_IDLE;
+
+  // The namespace of the script. This is used by Greasemonkey in the same way
+  // as XML namespaces. Only used when parsing Greasemonkey-style scripts.
+  std::string name_space_;
+
+  // The script's name. Only used when parsing Greasemonkey-style scripts.
+  std::string name_;
+
+  // A longer description. Only used when parsing Greasemonkey-style scripts.
+  std::string description_;
+
+  // A version number of the script. Only used when parsing Greasemonkey-style
+  // scripts.
+  std::string version_;
+
+  // Greasemonkey-style globs that determine pages to inject the script into.
+  // These are only used with standalone scripts.
+  std::vector<std::string> globs_;
+  std::vector<std::string> exclude_globs_;
+
+  // URLPatterns that determine pages to inject the script into. These are
+  // only used with scripts that are part of extensions.
+  URLPatternSet url_set_;
+  URLPatternSet exclude_url_set_;
+
+  // List of js scripts defined in content_scripts
+  FileList js_scripts_;
+
+  // List of css scripts defined in content_scripts
+  FileList css_scripts_;
+
+  // The ID of the host this script is a part of. The |ID| of the
+  // |host_id| can be empty if the script is a "standlone" user script.
+  HostID host_id_;
+
+  // The type of the consumer instance that the script will be injected.
+  ConsumerInstanceType consumer_instance_type_ = TAB;
+
+  // The globally-unique id associated with this user script. -1 indicates
+  // "invalid".
+  int user_script_id_ = -1;
+
+  // Whether we should try to emulate Greasemonkey's APIs when running this
+  // script.
+  bool emulate_greasemonkey_ = false;
+
+  // Whether the user script should run in all frames, or only just the top one.
+  bool match_all_frames_ = false;
+
+  // Whether the user script should run in frames whose initiator / precursor
+  // origin matches a match pattern, if an appropriate URL cannot be found for
+  // the frame for matching purposes, such as in the case of about:, data:, and
+  // other schemes.
+  MatchOriginAsFallbackBehavior match_origin_as_fallback_ =
+      MatchOriginAsFallbackBehavior::kNever;
+
+  // True if the script should be injected into an incognito tab.
+  bool incognito_enabled_ = false;
+
+  DISALLOW_COPY_AND_ASSIGN(UserScript);
+};
+
+// Information we need while removing scripts from a UserScriptLoader.
+struct UserScriptIDPair {
+  UserScriptIDPair(int id, const HostID& host_id);
+  explicit UserScriptIDPair(int id);
+
+  int id;
+  HostID host_id;
+};
+
+bool operator<(const UserScriptIDPair& a, const UserScriptIDPair& b);
+
+using UserScriptList = std::vector<std::unique_ptr<UserScript>>;
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_COMMON_USER_SCRIPT_H_
diff --git a/components/user_scripts/common/view_type.cc b/components/user_scripts/common/view_type.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/view_type.cc
@@ -0,0 +1,39 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "view_type.h"
+
+#include "base/strings/string_piece.h"
+
+namespace user_scripts {
+
+bool GetViewTypeFromString(const std::string& view_type,
+                           ViewType* view_type_out) {
+  // TODO(devlin): This map doesn't contain the following values:
+  // - VIEW_TYPE_BACKGROUND_CONTENTS
+  // - VIEW_TYPE_COMPONENT
+  // - VIEW_TYPE_EXTENSION_GUEST
+  // Why? Is it just because we don't expose those types to JS?
+  static const struct {
+    ViewType type;
+    base::StringPiece name;
+  } constexpr kTypeMap[] = {
+      // {VIEW_TYPE_APP_WINDOW, "APP_WINDOW"},
+      // {VIEW_TYPE_EXTENSION_BACKGROUND_PAGE, "BACKGROUND"},
+      // {VIEW_TYPE_EXTENSION_DIALOG, "EXTENSION_DIALOG"},
+      // {VIEW_TYPE_EXTENSION_POPUP, "POPUP"},
+      {VIEW_TYPE_TAB_CONTENTS, "TAB"},
+  };
+
+  for (const auto& entry : kTypeMap) {
+    if (entry.name == view_type) {
+      *view_type_out = entry.type;
+      return true;
+    }
+  }
+
+  return false;
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/common/view_type.h b/components/user_scripts/common/view_type.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/common/view_type.h
@@ -0,0 +1,48 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef USERSCRIPTS_COMMON_VIEW_TYPE_H_
+#define USERSCRIPTS_COMMON_VIEW_TYPE_H_
+
+#include <string>
+
+namespace user_scripts {
+
+// Icky RTTI used by a few systems to distinguish the host type of a given
+// WebContents.
+//
+// Do not change or reuse the the entry values in this list as this is used in
+// ExtensionViewType enum in tools/metrics/histograms/enums.xml.
+//
+// TODO(aa): Remove this and teach those systems to keep track of their own
+// data.
+enum ViewType {
+  VIEW_TYPE_INVALID = 0,
+  // VIEW_TYPE_APP_WINDOW = 1,
+  // VIEW_TYPE_BACKGROUND_CONTENTS = 2,
+
+  // // For custom parts of Chrome if no other type applies.
+  // VIEW_TYPE_COMPONENT = 3,
+
+  // VIEW_TYPE_EXTENSION_BACKGROUND_PAGE = 4,
+  // VIEW_TYPE_EXTENSION_DIALOG = 5,
+  // VIEW_TYPE_EXTENSION_GUEST = 6,
+  // VIEW_TYPE_EXTENSION_POPUP = 7,
+
+  // Panels were removed in https://crbug.com/571511.
+  // DEPRECATED_VIEW_TYPE_PANEL = 8,
+
+  VIEW_TYPE_TAB_CONTENTS = 9,
+
+  VIEW_TYPE_LAST = VIEW_TYPE_TAB_CONTENTS
+};
+
+// Matches the |view_type| to the corresponding ViewType, and populates
+// |view_type_out|. Returns true if a match is found.
+bool GetViewTypeFromString(const std::string& view_type,
+                           ViewType* view_type_out);
+
+}  // namespace extensions
+
+#endif  // USERSCRIPTS_COMMON_VIEW_TYPE_H_
diff --git a/components/user_scripts/renderer/BUILD.gn b/components/user_scripts/renderer/BUILD.gn
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/BUILD.gn
@@ -0,0 +1,98 @@
+# Copyright 2015 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//tools/grit/grit_rule.gni")
+import("//tools/grit/repack.gni")
+
+group("user_scripts_resources") {
+  public_deps = [
+    ":user_scripts_renderer_resources",
+  ]
+}
+
+grit("user_scripts_renderer_resources") {
+  source = "resources/user_scripts_renderer_resources.grd"
+  outputs = [
+    "grit/user_scripts_renderer_resources.h",
+    "user_scripts_renderer_resources.pak",
+  ]
+  grit_flags = [
+    "-E",
+    "mojom_root=" + rebase_path(root_gen_dir, root_build_dir),
+  ]
+}
+
+static_library("renderer") {
+  sources = [
+    # "../common/constants.cc",
+    # "../common/constants.h",
+    # "../common/extension_id.h",
+    # "../common/host_id.cc",
+    # "../common/host_id.h",
+    # "../common/script_constants.h",
+    # "../common/url_pattern_set.cc",
+    # "../common/url_pattern_set.h",
+    # "../common/url_pattern.cc",
+    # "../common/url_pattern.h",
+    # "../common/user_script.cc",
+    # "../common/user_script.h",
+    # "../common/view_type.cc",
+    # "../common/view_type.h",
+    # "../common/extension_messages.cc",
+    # "../common/extension_messages.h",
+    # "../common/extension_message_generator.cc",
+    # "../common/extension_message_generator.h",
+#    "dispatcher_delegate.cc",
+#    "dispatcher_delegate.h",
+    "extension_frame_helper.cc",
+    "extension_frame_helper.h",
+    "injection_host.cc",
+    "injection_host.h",
+#    "programmatic_script_injector.cc",
+#    "programmatic_script_injector.h",
+    "script_injection_manager.cc",
+    "script_injection_manager.h",
+    "script_injection_callback.cc",
+    "script_injection_callback.h",
+    "script_injection.cc",
+    "script_injection.h",
+    "script_injector.h",
+    "script_context.cc",
+    "script_context.h",
+    "scripts_run_info.cc",
+    "scripts_run_info.h",
+    "user_script_injector.cc",
+    "user_script_injector.h",
+    "user_script_set_manager.cc",
+    "user_script_set_manager.h",
+    "user_script_set.cc",
+    "user_script_set.h",
+#    "user_scripts_dispatcher_delegate.cc",
+#    "user_scripts_dispatcher_delegate.h",
+    "user_scripts_dispatcher.cc",
+    "user_scripts_dispatcher.h",
+    "user_scripts_renderer_client.cc",
+    "user_scripts_renderer_client.h",
+    "web_ui_injection_host.cc",
+    "web_ui_injection_host.h",
+  ]
+
+  #public_deps = [ "//components/user_scripts/core/proto" ]
+  deps = [
+    ":user_scripts_resources",
+    "//base",
+    #"//components/dom_distiller/content/common/mojom",
+    #"//components/dom_distiller/core",
+    #"//components/dom_distiller/core/mojom",
+    "//content/public/common",
+    "//content/public/renderer",
+    "//components/user_scripts/common",
+    #"//gin",
+    "//mojo/public/cpp/bindings",
+    #"//services/service_manager/public/cpp",
+    #"//skia",
+    "//third_party/blink/public:blink_headers",
+    "//v8",
+  ]
+}
diff --git a/components/user_scripts/renderer/extension_frame_helper.cc b/components/user_scripts/renderer/extension_frame_helper.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/extension_frame_helper.cc
@@ -0,0 +1,531 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "extension_frame_helper.h"
+
+#include <set>
+
+#include "base/metrics/histogram_macros.h"
+#include "base/strings/string_util.h"
+#include "base/timer/elapsed_timer.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/renderer/render_view.h"
+//#include "extensions/common/api/messaging/message.h"
+//#include "extensions/common/api/messaging/port_id.h"
+#include "../common/constants.h"
+//#include "extensions/common/extension_messages.h"
+//#include "extensions/common/manifest_handlers/background_info.h"
+//#include "extensions/renderer/api/automation/automation_api_helper.h"
+//#include "extensions/renderer/console.h"
+//#include "extensions/renderer/dispatcher.h"
+//#include "extensions/renderer/native_extension_bindings_system.h"
+//#include "extensions/renderer/native_renderer_messaging_service.h"
+//#include "extensions/renderer/script_context.h"
+//#include "extensions/renderer/script_context_set.h"
+#include "third_party/blink/public/platform/web_security_origin.h"
+#include "third_party/blink/public/web/web_console_message.h"
+#include "third_party/blink/public/web/web_document.h"
+#include "third_party/blink/public/web/web_document_loader.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "third_party/blink/public/web/web_settings.h"
+#include "third_party/blink/public/web/web_view.h"
+
+namespace user_scripts {
+
+namespace {
+
+// constexpr int kMainWorldId = 0;
+
+base::LazyInstance<std::set<const ExtensionFrameHelper*>>::DestructorAtExit
+    g_frame_helpers = LAZY_INSTANCE_INITIALIZER;
+
+// // Returns true if the render frame corresponding with |frame_helper| matches
+// // the given criteria.
+// bool RenderFrameMatches(const ExtensionFrameHelper* frame_helper,
+//                         ViewType match_view_type,
+//                         int match_window_id,
+//                         int match_tab_id,
+//                         const std::string& match_extension_id) {
+//   if (match_view_type != VIEW_TYPE_INVALID &&
+//       frame_helper->view_type() != match_view_type)
+//     return false;
+
+//   // Not all frames have a valid ViewType, e.g. devtools, most GuestViews, and
+//   // unclassified detached WebContents.
+//   if (frame_helper->view_type() == VIEW_TYPE_INVALID)
+//     return false;
+
+//   // This logic matches ExtensionWebContentsObserver::GetExtensionFromFrame.
+//   blink::WebSecurityOrigin origin =
+//       frame_helper->render_frame()->GetWebFrame()->GetSecurityOrigin();
+//   if (origin.IsOpaque() ||
+//       !base::EqualsASCII(origin.Protocol().Utf16(), kExtensionScheme) ||
+//       !base::EqualsASCII(origin.Host().Utf16(), match_extension_id.c_str()))
+//     return false;
+
+//   if (match_window_id != extension_misc::kUnknownWindowId &&
+//       frame_helper->browser_window_id() != match_window_id)
+//     return false;
+
+//   if (match_tab_id != extension_misc::kUnknownTabId &&
+//       frame_helper->tab_id() != match_tab_id)
+//     return false;
+
+//   return true;
+// }
+
+// Runs every callback in |callbacks_to_be_run_and_cleared| while |frame_helper|
+// is valid, and clears |callbacks_to_be_run_and_cleared|.
+void RunCallbacksWhileFrameIsValid(
+    base::WeakPtr<ExtensionFrameHelper> frame_helper,
+    std::vector<base::Closure>* callbacks_to_be_run_and_cleared) {
+  // The JavaScript code can cause re-entrancy. To avoid a deadlock, don't run
+  // callbacks that are added during the iteration.
+  std::vector<base::Closure> callbacks;
+  callbacks_to_be_run_and_cleared->swap(callbacks);
+  for (auto& callback : callbacks) {
+    callback.Run();
+    if (!frame_helper.get())
+      return;  // Frame and ExtensionFrameHelper invalidated by callback.
+  }
+}
+
+// enum class PortType {
+//   EXTENSION,
+//   TAB,
+//   NATIVE_APP,
+// };
+
+// // Returns an extension hosted in the |render_frame| (or nullptr if the frame
+// // doesn't host an extension).
+// const Extension* GetExtensionFromFrame(content::RenderFrame* render_frame) {
+//   DCHECK(render_frame);
+//   ScriptContext* context =
+//       ScriptContextSet::GetMainWorldContextForFrame(render_frame);
+//   return context ? context->effective_extension() : nullptr;
+// }
+
+}  // namespace
+
+ExtensionFrameHelper::ExtensionFrameHelper(content::RenderFrame* render_frame /*,
+                                           Dispatcher* extension_dispatcher*/)
+    : content::RenderFrameObserver(render_frame),
+      content::RenderFrameObserverTracker<ExtensionFrameHelper>(render_frame),
+      //view_type_(VIEW_TYPE_INVALID),
+      tab_id_(-1) //,
+      //browser_window_id_(-1),
+      //extension_dispatcher_(extension_dispatcher),
+      /*did_create_current_document_element_(false)*/ {
+  g_frame_helpers.Get().insert(this);
+  // if (render_frame->IsMainFrame()) {
+  //   // Manages its own lifetime.
+  //   new AutomationApiHelper(render_frame);
+  // }
+}
+
+ExtensionFrameHelper::~ExtensionFrameHelper() {
+  g_frame_helpers.Get().erase(this);
+}
+
+void ExtensionFrameHelper::ScheduleAtDocumentStart(
+    const base::Closure& callback) {
+  document_element_created_callbacks_.push_back(callback);
+}
+
+void ExtensionFrameHelper::ScheduleAtDocumentEnd(
+    const base::Closure& callback) {
+  document_load_finished_callbacks_.push_back(callback);
+}
+
+void ExtensionFrameHelper::ScheduleAtDocumentIdle(
+    const base::Closure& callback) {
+  document_idle_callbacks_.push_back(callback);
+}
+
+void ExtensionFrameHelper::RunScriptsAtDocumentStart() {
+  //DCHECK(did_create_current_document_element_);
+  RunCallbacksWhileFrameIsValid(weak_ptr_factory_.GetWeakPtr(),
+                                &document_element_created_callbacks_);
+  // |this| might be dead by now.
+}
+
+void ExtensionFrameHelper::RunScriptsAtDocumentEnd() {
+  RunCallbacksWhileFrameIsValid(weak_ptr_factory_.GetWeakPtr(),
+                                &document_load_finished_callbacks_);
+  // |this| might be dead by now.
+}
+
+void ExtensionFrameHelper::RunScriptsAtDocumentIdle() {
+  RunCallbacksWhileFrameIsValid(weak_ptr_factory_.GetWeakPtr(),
+                                &document_idle_callbacks_);
+  // |this| might be dead by now.
+}
+
+void ExtensionFrameHelper::OnDestruct() {
+  delete this;
+}
+
+
+// // static
+// std::vector<content::RenderFrame*> ExtensionFrameHelper::GetExtensionFrames(
+//     const std::string& extension_id,
+//     int browser_window_id,
+//     int tab_id,
+//     ViewType view_type) {
+//   std::vector<content::RenderFrame*> render_frames;
+//   for (const ExtensionFrameHelper* helper : g_frame_helpers.Get()) {
+//     if (RenderFrameMatches(helper, view_type, browser_window_id, tab_id,
+//                            extension_id))
+//       render_frames.push_back(helper->render_frame());
+//   }
+//   return render_frames;
+// }
+
+// // static
+// v8::Local<v8::Array> ExtensionFrameHelper::GetV8MainFrames(
+//     v8::Local<v8::Context> context,
+//     const std::string& extension_id,
+//     int browser_window_id,
+//     int tab_id,
+//     ViewType view_type) {
+//   // WebFrame::ScriptCanAccess uses the isolate's current context. We need to
+//   // make sure that the current context is the one we're expecting.
+//   DCHECK(context == context->GetIsolate()->GetCurrentContext());
+//   std::vector<content::RenderFrame*> render_frames =
+//       GetExtensionFrames(extension_id, browser_window_id, tab_id, view_type);
+//   v8::Local<v8::Array> v8_frames = v8::Array::New(context->GetIsolate());
+
+//   int v8_index = 0;
+//   for (content::RenderFrame* frame : render_frames) {
+//     if (!frame->IsMainFrame())
+//       continue;
+
+//     blink::WebLocalFrame* web_frame = frame->GetWebFrame();
+//     if (!blink::WebFrame::ScriptCanAccess(web_frame))
+//       continue;
+
+//     v8::Local<v8::Context> frame_context = web_frame->MainWorldScriptContext();
+//     if (!frame_context.IsEmpty()) {
+//       v8::Local<v8::Value> window = frame_context->Global();
+//       CHECK(!window.IsEmpty());
+//       v8::Maybe<bool> maybe =
+//           v8_frames->CreateDataProperty(context, v8_index++, window);
+//       CHECK(maybe.IsJust() && maybe.FromJust());
+//     }
+//   }
+
+//   return v8_frames;
+// }
+
+// // static
+// content::RenderFrame* ExtensionFrameHelper::GetBackgroundPageFrame(
+//     const std::string& extension_id) {
+//   for (const ExtensionFrameHelper* helper : g_frame_helpers.Get()) {
+//     if (RenderFrameMatches(helper, VIEW_TYPE_EXTENSION_BACKGROUND_PAGE,
+//                            extension_misc::kUnknownWindowId,
+//                            extension_misc::kUnknownTabId, extension_id)) {
+//       blink::WebLocalFrame* web_frame = helper->render_frame()->GetWebFrame();
+//       // Check if this is the top frame.
+//       if (web_frame->Top() == web_frame)
+//         return helper->render_frame();
+//     }
+//   }
+//   return nullptr;
+// }
+
+// v8::Local<v8::Value> ExtensionFrameHelper::GetV8BackgroundPageMainFrame(
+//     v8::Isolate* isolate,
+//     const std::string& extension_id) {
+//   content::RenderFrame* main_frame = GetBackgroundPageFrame(extension_id);
+
+//   v8::Local<v8::Value> background_page;
+//   blink::WebLocalFrame* web_frame =
+//       main_frame ? main_frame->GetWebFrame() : nullptr;
+//   if (web_frame && blink::WebFrame::ScriptCanAccess(web_frame))
+//     background_page = web_frame->MainWorldScriptContext()->Global();
+//   else
+//     background_page = v8::Undefined(isolate);
+
+//   return background_page;
+// }
+
+// // static
+// content::RenderFrame* ExtensionFrameHelper::FindFrame(
+//     content::RenderFrame* relative_to_frame,
+//     const std::string& name) {
+//   // Only pierce browsing instance boundaries if |relative_to_frame| is an
+//   // extension.
+//   const Extension* extension = GetExtensionFromFrame(relative_to_frame);
+//   if (!extension)
+//     return nullptr;
+
+//   for (const ExtensionFrameHelper* target : g_frame_helpers.Get()) {
+//     // Skip frames with a mismatched name.
+//     if (target->render_frame()->GetWebFrame()->AssignedName().Utf8() != name)
+//       continue;
+
+//     // Only pierce browsing instance boundaries if the target frame is from the
+//     // same extension (but not when another extension shares the same renderer
+//     // process because of reuse trigerred by process limit).
+//     if (extension != GetExtensionFromFrame(target->render_frame()))
+//       continue;
+
+//     return target->render_frame();
+//   }
+
+//   return nullptr;
+// }
+
+// // static
+// bool ExtensionFrameHelper::IsContextForEventPage(const ScriptContext* context) {
+//   content::RenderFrame* render_frame = context->GetRenderFrame();
+//   return context->extension() && render_frame &&
+//          BackgroundInfo::HasLazyBackgroundPage(context->extension()) &&
+//          ExtensionFrameHelper::Get(render_frame)->view_type() ==
+//               VIEW_TYPE_EXTENSION_BACKGROUND_PAGE;
+// }
+
+// void ExtensionFrameHelper::DidCreateDocumentElement() {
+//   did_create_current_document_element_ = true;
+//   extension_dispatcher_->DidCreateDocumentElement(
+//       render_frame()->GetWebFrame());
+// }
+
+// void ExtensionFrameHelper::DidCreateNewDocument() {
+//   did_create_current_document_element_ = false;
+// }
+
+// void ExtensionFrameHelper::ReadyToCommitNavigation(
+//     blink::WebDocumentLoader* document_loader) {
+//   // New window created by chrome.app.window.create() must not start parsing the
+//   // document immediately. The chrome.app.window.create() callback (if any)
+//   // needs to be called prior to the new window's 'load' event. The parser will
+//   // be resumed when it happens. It doesn't apply to sandboxed pages.
+//   if (view_type_ == VIEW_TYPE_APP_WINDOW && render_frame()->IsMainFrame() &&
+//       !has_started_first_navigation_ &&
+//       GURL(document_loader->GetUrl()).SchemeIs(kExtensionScheme) &&
+//       !ScriptContext::IsSandboxedPage(document_loader->GetUrl())) {
+//     document_loader->BlockParser();
+//   }
+
+//   has_started_first_navigation_ = true;
+
+//   if (!delayed_main_world_script_initialization_)
+//     return;
+
+//   delayed_main_world_script_initialization_ = false;
+//   v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
+//   v8::Local<v8::Context> context =
+//       render_frame()->GetWebFrame()->MainWorldScriptContext();
+//   v8::Context::Scope context_scope(context);
+//   // Normally we would use Document's URL for all kinds of checks, e.g. whether
+//   // to inject a content script. However, when committing a navigation, we
+//   // should use the URL of a Document being committed instead. This URL is
+//   // accessible through WebDocumentLoader::GetURL().
+//   // The scope below temporary maps a frame to a document loader, so that places
+//   // which retrieve URL can use the right one. Ideally, we would plumb the
+//   // correct URL (or maybe WebDocumentLoader) through the callchain, but there
+//   // are many callers which will have to pass nullptr.
+//   ScriptContext::ScopedFrameDocumentLoader scoped_document_loader(
+//       render_frame()->GetWebFrame(), document_loader);
+//   extension_dispatcher_->DidCreateScriptContext(render_frame()->GetWebFrame(),
+//                                                 context, kMainWorldId);
+//   // TODO(devlin): Add constants for main world id, no extension group.
+// }
+
+// void ExtensionFrameHelper::DidCommitProvisionalLoad(
+//     ui::PageTransition transition) {
+//   // Grant cross browsing instance frame lookup if we are an extension. This
+//   // should match the conditions in FindFrame.
+//   content::RenderFrame* frame = render_frame();
+//   if (GetExtensionFromFrame(frame))
+//     frame->SetAllowsCrossBrowsingInstanceFrameLookup();
+// }
+
+// void ExtensionFrameHelper::DidCreateScriptContext(
+//     v8::Local<v8::Context> context,
+//     int32_t world_id) {
+//   if (world_id == kMainWorldId) {
+//     if (render_frame()->IsBrowserSideNavigationPending()) {
+//       // Defer initializing the extensions script context now because it depends
+//       // on having the URL of the provisional load which isn't available at this
+//       // point.
+//       // We can come here twice in the case of window.open(url): first for
+//       // about:blank empty document, then possibly for the actual url load
+//       // (depends on whoever triggers window proxy init), before getting
+//       // ReadyToCommitNavigation.
+//       delayed_main_world_script_initialization_ = true;
+//       return;
+//     }
+//     // Sometimes DidCreateScriptContext comes before ReadyToCommitNavigation.
+//     // In this case we don't have to wait until ReadyToCommitNavigation.
+//     // TODO(dgozman): ensure consistent call order between
+//     // DidCreateScriptContext and ReadyToCommitNavigation.
+//     delayed_main_world_script_initialization_ = false;
+//   }
+//   extension_dispatcher_->DidCreateScriptContext(render_frame()->GetWebFrame(),
+//                                                 context, world_id);
+// }
+
+// void ExtensionFrameHelper::WillReleaseScriptContext(
+//     v8::Local<v8::Context> context,
+//     int32_t world_id) {
+//   extension_dispatcher_->WillReleaseScriptContext(
+//       render_frame()->GetWebFrame(), context, world_id);
+// }
+
+// bool ExtensionFrameHelper::OnMessageReceived(const IPC::Message& message) {
+//   bool handled = true;
+//   IPC_BEGIN_MESSAGE_MAP(ExtensionFrameHelper, message)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_ValidateMessagePort,
+//                         OnExtensionValidateMessagePort)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_DispatchOnConnect,
+//                         OnExtensionDispatchOnConnect)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_DeliverMessage, OnExtensionDeliverMessage)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_DispatchOnDisconnect,
+//                         OnExtensionDispatchOnDisconnect)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_SetTabId, OnExtensionSetTabId)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_UpdateBrowserWindowId,
+//                         OnUpdateBrowserWindowId)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_NotifyRenderViewType,
+//                         OnNotifyRendererViewType)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_Response, OnExtensionResponse)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_MessageInvoke, OnExtensionMessageInvoke)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_SetFrameName, OnSetFrameName)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_AppWindowClosed, OnAppWindowClosed)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_SetSpatialNavigationEnabled,
+//                         OnSetSpatialNavigationEnabled)
+//     IPC_MESSAGE_UNHANDLED(handled = false)
+//   IPC_END_MESSAGE_MAP()
+//   return handled;
+// }
+
+// void ExtensionFrameHelper::OnExtensionValidateMessagePort(int worker_thread_id,
+//                                                           const PortId& id) {
+//   DCHECK_EQ(kMainThreadId, worker_thread_id);
+//   extension_dispatcher_->bindings_system()
+//       ->messaging_service()
+//       ->ValidateMessagePort(
+//           extension_dispatcher_->script_context_set_iterator(), id,
+//           render_frame());
+// }
+
+// void ExtensionFrameHelper::OnExtensionDispatchOnConnect(
+//     int worker_thread_id,
+//     const PortId& target_port_id,
+//     const std::string& channel_name,
+//     const ExtensionMsg_TabConnectionInfo& source,
+//     const ExtensionMsg_ExternalConnectionInfo& info) {
+//   DCHECK_EQ(kMainThreadId, worker_thread_id);
+//   extension_dispatcher_->bindings_system()
+//       ->messaging_service()
+//       ->DispatchOnConnect(extension_dispatcher_->script_context_set_iterator(),
+//                           target_port_id, channel_name, source, info,
+//                           render_frame());
+// }
+
+// void ExtensionFrameHelper::OnExtensionDeliverMessage(int worker_thread_id,
+//                                                      const PortId& target_id,
+//                                                      const Message& message) {
+//   DCHECK_EQ(kMainThreadId, worker_thread_id);
+//   extension_dispatcher_->bindings_system()->messaging_service()->DeliverMessage(
+//       extension_dispatcher_->script_context_set_iterator(), target_id, message,
+//       render_frame());
+// }
+
+// void ExtensionFrameHelper::OnExtensionDispatchOnDisconnect(
+//     int worker_thread_id,
+//     const PortId& id,
+//     const std::string& error_message) {
+//   DCHECK_EQ(kMainThreadId, worker_thread_id);
+//   extension_dispatcher_->bindings_system()
+//       ->messaging_service()
+//       ->DispatchOnDisconnect(
+//           extension_dispatcher_->script_context_set_iterator(), id,
+//           error_message, render_frame());
+// }
+
+// void ExtensionFrameHelper::OnExtensionSetTabId(int tab_id) {
+//   CHECK_EQ(tab_id_, -1);
+//   CHECK_GE(tab_id, 0);
+//   tab_id_ = tab_id;
+// }
+
+// void ExtensionFrameHelper::OnUpdateBrowserWindowId(int browser_window_id) {
+//   browser_window_id_ = browser_window_id;
+// }
+
+// void ExtensionFrameHelper::OnNotifyRendererViewType(ViewType type) {
+//   // TODO(devlin): It'd be really nice to be able to
+//   // DCHECK_EQ(VIEW_TYPE_INVALID, view_type_) here.
+//   view_type_ = type;
+// }
+
+// void ExtensionFrameHelper::OnExtensionResponse(int request_id,
+//                                                bool success,
+//                                                const base::ListValue& response,
+//                                                const std::string& error) {
+//   extension_dispatcher_->OnExtensionResponse(request_id,
+//                                              success,
+//                                              response,
+//                                              error);
+// }
+
+// void ExtensionFrameHelper::OnExtensionMessageInvoke(
+//     const std::string& extension_id,
+//     const std::string& module_name,
+//     const std::string& function_name,
+//     const base::ListValue& args) {
+//   extension_dispatcher_->InvokeModuleSystemMethod(
+//       render_frame(), extension_id, module_name, function_name, args);
+// }
+
+// void ExtensionFrameHelper::OnSetFrameName(const std::string& name) {
+//   render_frame()->GetWebFrame()->SetName(blink::WebString::FromUTF8(name));
+// }
+
+// void ExtensionFrameHelper::OnAppWindowClosed(bool send_onclosed) {
+//   DCHECK(render_frame()->IsMainFrame());
+
+//   if (!send_onclosed)
+//     return;
+
+//   v8::HandleScope scope(v8::Isolate::GetCurrent());
+//   v8::Local<v8::Context> v8_context =
+//       render_frame()->GetWebFrame()->MainWorldScriptContext();
+//   ScriptContext* script_context =
+//       ScriptContextSet::GetContextByV8Context(v8_context);
+//   if (!script_context)
+//     return;
+//   script_context->module_system()->CallModuleMethodSafe("app.window",
+//                                                         "onAppWindowClosed");
+// }
+
+// void ExtensionFrameHelper::OnSetSpatialNavigationEnabled(bool enabled) {
+//   render_frame()
+//       ->GetRenderView()
+//       ->GetWebView()
+//       ->GetSettings()
+//       ->SetSpatialNavigationEnabled(enabled);
+// }
+
+// void ExtensionFrameHelper::DraggableRegionsChanged() {
+//   if (!render_frame()->IsMainFrame())
+//     return;
+
+//   blink::WebVector<blink::WebDraggableRegion> webregions =
+//       render_frame()->GetWebFrame()->GetDocument().DraggableRegions();
+//   std::vector<DraggableRegion> regions;
+//   for (blink::WebDraggableRegion& webregion : webregions) {
+//     render_frame()->ConvertViewportToWindow(&webregion.bounds);
+
+//     regions.push_back(DraggableRegion());
+//     DraggableRegion& region = regions.back();
+//     region.bounds = webregion.bounds;
+//     region.draggable = webregion.draggable;
+//   }
+//   Send(new ExtensionHostMsg_UpdateDraggableRegions(routing_id(), regions));
+// }
+
+}  // namespace extensions
diff --git a/components/user_scripts/renderer/extension_frame_helper.h b/components/user_scripts/renderer/extension_frame_helper.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/extension_frame_helper.h
@@ -0,0 +1,204 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_EXTENSION_FRAME_HELPER_H_
+#define EXTENSIONS_RENDERER_EXTENSION_FRAME_HELPER_H_
+
+#include <string>
+#include <vector>
+
+#include "base/callback_forward.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "content/public/renderer/render_frame_observer.h"
+#include "content/public/renderer/render_frame_observer_tracker.h"
+#include "../common/view_type.h"
+#include "third_party/blink/public/mojom/devtools/console_message.mojom.h"
+#include "v8/include/v8.h"
+
+struct ExtensionMsg_ExternalConnectionInfo;
+struct ExtensionMsg_TabConnectionInfo;
+
+namespace base {
+class ListValue;
+}
+
+namespace user_scripts {
+
+class Dispatcher;
+struct Message;
+struct PortId;
+class ScriptContext;
+
+// RenderFrame-level plumbing for extension features.
+class ExtensionFrameHelper
+    : public content::RenderFrameObserver,
+      public content::RenderFrameObserverTracker<ExtensionFrameHelper> {
+ public:
+  ExtensionFrameHelper(content::RenderFrame* render_frame /*,
+                       Dispatcher* extension_dispatcher*/);
+  ~ExtensionFrameHelper() override;
+
+//   // Returns a list of extension RenderFrames that match the given filter
+//   // criteria. A |browser_window_id| of extension_misc::kUnknownWindowId
+//   // specifies "all", as does a |view_type| of VIEW_TYPE_INVALID.
+//   static std::vector<content::RenderFrame*> GetExtensionFrames(
+//       const std::string& extension_id,
+//       int browser_window_id,
+//       int tab_id,
+//       ViewType view_type);
+//   // Same as above, but returns a v8::Array of the v8 global objects for those
+//   // frames, and only includes main frames. Note: This only returns contexts
+//   // that are accessible by |context|, and |context| must be the current
+//   // context.
+//   // Returns an empty v8::Array if no frames are found.
+//   static v8::Local<v8::Array> GetV8MainFrames(v8::Local<v8::Context> context,
+//                                               const std::string& extension_id,
+//                                               int browser_window_id,
+//                                               int tab_id,
+//                                               ViewType view_type);
+
+//   // Returns the main frame of the extension's background page, or null if there
+//   // isn't one in this process.
+//   static content::RenderFrame* GetBackgroundPageFrame(
+//       const std::string& extension_id);
+//   // Same as above, but returns the background page's main frame, or
+//   // v8::Undefined if there is none. Note: This will assert that the
+//   // isolate's current context can access the returned object; callers should
+//   // ensure that the current context is correct.
+//   static v8::Local<v8::Value> GetV8BackgroundPageMainFrame(
+//       v8::Isolate* isolate,
+//       const std::string& extension_id);
+
+//   // Finds a neighboring extension frame with the same extension as the one
+//   // owning |relative_to_frame| (if |relative_to_frame| is not an extension
+//   // frame, returns nullptr). Pierces the browsing instance boundary because
+//   // certain extensions rely on this behavior.
+//   // TODO(devlin, lukasza): https://crbug.com/786411: Remove this behavior, and
+//   // make extensions follow the web standard for finding frames or use an
+//   // explicit API.
+//   static content::RenderFrame* FindFrame(
+//       content::RenderFrame* relative_to_frame,
+//       const std::string& name);
+
+//   // Returns true if the given |context| is for any frame in the extension's
+//   // event page.
+//   // TODO(devlin): This isn't really used properly, and should probably be
+//   // deleted.
+//   static bool IsContextForEventPage(const ScriptContext* context);
+
+//   ViewType view_type() const { return view_type_; }
+   int tab_id() const { return tab_id_; }
+//   int browser_window_id() const { return browser_window_id_; }
+//   bool did_create_current_document_element() const {
+//     return did_create_current_document_element_;
+//   }
+
+  // Called when the document element has been inserted in this frame. This
+  // method may invoke untrusted JavaScript code that invalidate the frame and
+  // this ExtensionFrameHelper.
+  void RunScriptsAtDocumentStart();
+
+  // Called after the DOMContentLoaded event has fired.
+  void RunScriptsAtDocumentEnd();
+
+  // Called before the window.onload event is fired.
+  void RunScriptsAtDocumentIdle();
+
+  // Schedule a callback, to be run at the next RunScriptsAtDocumentStart
+  // notification. Only call this when you are certain that there will be such a
+  // notification, e.g. from RenderFrameObserver::DidCreateDocumentElement.
+  // Otherwise the callback is never invoked, or invoked for a document that you
+  // were not expecting.
+  void ScheduleAtDocumentStart(const base::Closure& callback);
+
+  // Schedule a callback, to be run at the next RunScriptsAtDocumentEnd call.
+  void ScheduleAtDocumentEnd(const base::Closure& callback);
+
+  // Schedule a callback, to be run at the next RunScriptsAtDocumentIdle call.
+  void ScheduleAtDocumentIdle(const base::Closure& callback);
+
+ private:
+  // RenderFrameObserver implementation.
+//   void DidCreateDocumentElement() override;
+//   void DidCreateNewDocument() override;
+//   void ReadyToCommitNavigation(
+//       blink::WebDocumentLoader* document_loader) override;
+//   void DidCommitProvisionalLoad(ui::PageTransition transition) override;
+//   void DidCreateScriptContext(v8::Local<v8::Context>,
+//                               int32_t world_id) override;
+//   void WillReleaseScriptContext(v8::Local<v8::Context>,
+//                                 int32_t world_id) override;
+//   bool OnMessageReceived(const IPC::Message& message) override;
+  void OnDestruct() override;
+//   void DraggableRegionsChanged() override;
+
+  // IPC handlers.
+//   void OnExtensionValidateMessagePort(int worker_thread_id, const PortId& id);
+//   void OnExtensionDispatchOnConnect(
+//       int worker_thread_id,
+//       const PortId& target_port_id,
+//       const std::string& channel_name,
+//       const ExtensionMsg_TabConnectionInfo& source,
+//       const ExtensionMsg_ExternalConnectionInfo& info);
+//   void OnExtensionDeliverMessage(int worker_thread_id,
+//                                  const PortId& target_port_id,
+//                                  const Message& message);
+//   void OnExtensionDispatchOnDisconnect(int worker_thread_id,
+//                                        const PortId& id,
+//                                        const std::string& error_message);
+//   void OnExtensionSetTabId(int tab_id);
+//   void OnUpdateBrowserWindowId(int browser_window_id);
+//   void OnNotifyRendererViewType(ViewType view_type);
+//   void OnExtensionResponse(int request_id,
+//                            bool success,
+//                            const base::ListValue& response,
+//                            const std::string& error);
+//   void OnExtensionMessageInvoke(const std::string& extension_id,
+//                                 const std::string& module_name,
+//                                 const std::string& function_name,
+//                                 const base::ListValue& args);
+//   void OnSetFrameName(const std::string& name);
+//   void OnAppWindowClosed(bool send_onclosed);
+//   void OnSetSpatialNavigationEnabled(bool enabled);
+
+  // Type of view associated with the RenderFrame.
+  //ViewType view_type_;
+
+  // The id of the tab the render frame is attached to.
+  int tab_id_;
+
+  // The id of the browser window the render frame is attached to.
+  //int browser_window_id_;
+
+  //Dispatcher* extension_dispatcher_;
+
+  // Whether or not the current document element has been created.
+  //bool did_create_current_document_element_;
+
+  // Callbacks to be run at the next RunScriptsAtDocumentStart notification.
+  std::vector<base::Closure> document_element_created_callbacks_;
+
+  // Callbacks to be run at the next RunScriptsAtDocumentEnd notification.
+  std::vector<base::Closure> document_load_finished_callbacks_;
+
+  // Callbacks to be run at the next RunScriptsAtDocumentIdle notification.
+  std::vector<base::Closure> document_idle_callbacks_;
+
+  //bool delayed_main_world_script_initialization_ = false;
+
+  // Whether or not a DocumentLoader has been created at least once for this
+  // RenderFrame.
+  // Note: Chrome Apps intentionally do not support new navigations. When a
+  // navigation happens, it is either the initial one or a reload.
+  //bool has_started_first_navigation_ = false;
+
+  base::WeakPtrFactory<ExtensionFrameHelper> weak_ptr_factory_{this};
+
+  DISALLOW_COPY_AND_ASSIGN(ExtensionFrameHelper);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_EXTENSION_FRAME_HELPER_H_
diff --git a/components/user_scripts/renderer/injection_host.cc b/components/user_scripts/renderer/injection_host.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/injection_host.cc
@@ -0,0 +1,12 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "injection_host.h"
+
+InjectionHost::InjectionHost(const HostID& host_id) :
+    id_(host_id) {
+}
+
+InjectionHost::~InjectionHost() {
+}
diff --git a/components/user_scripts/renderer/injection_host.h b/components/user_scripts/renderer/injection_host.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/injection_host.h
@@ -0,0 +1,50 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_INJECTION_HOST_H_
+#define EXTENSIONS_RENDERER_INJECTION_HOST_H_
+
+#include "base/macros.h"
+#include "../common/host_id.h"
+//#include "../common/permissions/permissions_data.h"
+#include "url/gurl.h"
+
+namespace content {
+class RenderFrame;
+}
+
+// An interface for all kinds of hosts who own user scripts.
+class InjectionHost {
+ public:
+  InjectionHost(const HostID& host_id);
+  virtual ~InjectionHost();
+
+  // Returns the CSP to be used for the isolated world. Currently this only
+  // bypasses the main world CSP. If null is returned, the main world CSP is not
+  // bypassed.
+  virtual const std::string* GetContentSecurityPolicy() const = 0;
+
+  // The base url for the host.
+  virtual const GURL& url() const = 0;
+
+  // The human-readable name of the host.
+  virtual const std::string& name() const = 0;
+
+  // Returns true if the script should execute.
+//  virtual extensions::PermissionsData::PageAccess CanExecuteOnFrame(
+//      const GURL& document_url,
+//      content::RenderFrame* render_frame,
+//      int tab_id,
+//      bool is_declarative) const = 0;
+
+  const HostID& id() const { return id_; }
+
+ private:
+  // The ID of the host.
+  HostID id_;
+
+  DISALLOW_COPY_AND_ASSIGN(InjectionHost);
+};
+
+#endif  // EXTENSIONS_RENDERER_INJECTION_HOST_H_
diff --git a/components/user_scripts/renderer/resources/greasemonkey_api.js b/components/user_scripts/renderer/resources/greasemonkey_api.js
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/resources/greasemonkey_api.js
@@ -0,0 +1,82 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// -----------------------------------------------------------------------------
+// NOTE: If you change this file you need to touch renderer_resources.grd to
+// have your change take effect.
+// -----------------------------------------------------------------------------
+
+// Partial implementation of the Greasemonkey API, see:
+// http://wiki.greasespot.net/Greasemonkey_Manual:APIs
+
+function GM_addStyle(css) {
+  var parent = document.getElementsByTagName("head")[0];
+  if (!parent) {
+    parent = document.documentElement;
+  }
+  var style = document.createElement("style");
+  style.type = "text/css";
+  var textNode = document.createTextNode(css);
+  style.appendChild(textNode);
+  parent.appendChild(style);
+}
+
+function GM_xmlhttpRequest(details) {
+  function setupEvent(xhr, url, eventName, callback) {
+    xhr[eventName] = function () {
+      var isComplete = xhr.readyState == 4;
+      var responseState = {
+        responseText: xhr.responseText,
+        readyState: xhr.readyState,
+        responseHeaders: isComplete ? xhr.getAllResponseHeaders() : "",
+        status: isComplete ? xhr.status : 0,
+        statusText: isComplete ? xhr.statusText : "",
+        finalUrl: isComplete ? url : ""
+      };
+      callback(responseState);
+    };
+  }
+
+  var xhr = new XMLHttpRequest();
+  var eventNames = ["onload", "onerror", "onreadystatechange"];
+  for (var i = 0; i < eventNames.length; i++ ) {
+    var eventName = eventNames[i];
+    if (eventName in details) {
+      setupEvent(xhr, details.url, eventName, details[eventName]);
+    }
+  }
+
+  xhr.open(details.method, details.url);
+
+  if (details.overrideMimeType) {
+    xhr.overrideMimeType(details.overrideMimeType);
+  }
+  if (details.headers) {
+    for (var header in details.headers) {
+      xhr.setRequestHeader(header, details.headers[header]);
+    }
+  }
+  xhr.send(details.data ? details.data : null);
+}
+
+function GM_openInTab(url) {
+  window.open(url, "");
+}
+
+function GM_log(message) {
+  window.console.log(message);
+}
+
+(function() {
+  function generateGreasemonkeyStub(name) {
+    return function() {
+      console.log("%s is not supported.", name);
+    };
+  }
+
+  var apis = ["GM_getValue", "GM_setValue", "GM_registerMenuCommand"];
+  for (var i = 0, api; api = apis[i]; i++) {
+    window[api] = generateGreasemonkeyStub(api);
+  }
+})();
diff --git a/components/user_scripts/renderer/resources/user_scripts_renderer_resources.grd b/components/user_scripts/renderer/resources/user_scripts_renderer_resources.grd
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/resources/user_scripts_renderer_resources.grd
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<grit latest_public_release="0" current_release="1" output_all_resource_defines="false">
+  <outputs>
+    <output filename="grit/user_scripts_renderer_resources.h" type="rc_header">
+      <emit emit_type='prepend'></emit>
+    </output>
+    <output filename="user_scripts_renderer_resources.pak" type="data_package" />
+  </outputs>
+  <release seq="1">
+    <includes>
+      <include name="IDR_GREASEMONKEY_API_JS" file="greasemonkey_api.js" type="BINDATA" />
+    </includes>
+  </release>
+</grit>
diff --git a/components/user_scripts/renderer/script_context.cc b/components/user_scripts/renderer/script_context.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/script_context.cc
@@ -0,0 +1,665 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "script_context.h"
+
+#include "base/command_line.h"
+#include "base/containers/flat_set.h"
+#include "base/logging.h"
+#include "base/stl_util.h"
+#include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/values.h"
+#include "content/public/common/content_switches.h"
+#include "content/public/common/url_constants.h"
+#include "content/public/renderer/render_frame.h"
+#include "../common/constants.h"
+//#include "extensions/common/extension.h"
+//#include "extensions/common/extension_api.h"
+//#include "extensions/common/extension_urls.h"
+//#include "extensions/common/manifest_handlers/sandboxed_page_info.h"
+//#include "extensions/common/permissions/permissions_data.h"
+//#include "extensions/renderer/renderer_extension_registry.h"
+//#include "extensions/renderer/v8_helpers.h"
+#include "third_party/blink/public/mojom/service_worker/service_worker_registration.mojom.h"
+#include "third_party/blink/public/platform/web_security_origin.h"
+#include "third_party/blink/public/web/web_document.h"
+#include "third_party/blink/public/web/web_document_loader.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "third_party/blink/public/web/web_navigation_params.h"
+#include "v8/include/v8.h"
+
+namespace user_scripts {
+
+namespace {
+
+GURL GetEffectiveDocumentURL(
+    blink::WebLocalFrame* frame,
+    const GURL& document_url,
+    MatchOriginAsFallbackBehavior match_origin_as_fallback,
+    bool allow_inaccessible_parents) {
+  auto should_consider_origin = [document_url, match_origin_as_fallback]() {
+    switch (match_origin_as_fallback) {
+      case MatchOriginAsFallbackBehavior::kNever:
+        return false;
+      case MatchOriginAsFallbackBehavior::kMatchForAboutSchemeAndClimbTree:
+        return document_url.SchemeIs(url::kAboutScheme);
+      case MatchOriginAsFallbackBehavior::kAlways:
+        // TODO(devlin): Add more schemes here - blob, filesystem, etc.
+        return document_url.SchemeIs(url::kAboutScheme) ||
+               document_url.SchemeIs(url::kDataScheme);
+    }
+
+    NOTREACHED();
+  };
+
+  // If we don't need to consider the origin, we're done.
+  if (!should_consider_origin())
+    return document_url;
+
+  // Get the "security origin" for the frame. For about: frames, this is the
+  // origin of that of the controlling frame - e.g., an about:blank frame on
+  // https://example.com will have the security origin of https://example.com.
+  // Other frames, like data: frames, will have an opaque origin. For these,
+  // we can get the precursor origin.
+  const blink::WebSecurityOrigin web_frame_origin = frame->GetSecurityOrigin();
+  const url::Origin frame_origin = web_frame_origin;
+  const url::SchemeHostPort& tuple_or_precursor_tuple =
+      frame_origin.GetTupleOrPrecursorTupleIfOpaque();
+
+  // When there's no valid tuple (which can happen in the case of e.g. a
+  // browser-initiated navigation to an opaque URL), there's no origin to
+  // fallback to. Bail.
+  if (!tuple_or_precursor_tuple.IsValid())
+    return document_url;
+
+  const url::Origin origin_or_precursor_origin =
+      url::Origin::Create(tuple_or_precursor_tuple.GetURL());
+
+  if (!allow_inaccessible_parents &&
+      !web_frame_origin.CanAccess(
+          blink::WebSecurityOrigin(origin_or_precursor_origin))) {
+    // The frame can't access its precursor. Bail.
+    return document_url;
+  }
+
+  // Looks like the initiator origin is an appropriate fallback!
+
+  if (match_origin_as_fallback == MatchOriginAsFallbackBehavior::kAlways) {
+    // The easy case! We use the origin directly. We're done.
+    return origin_or_precursor_origin.GetURL();
+  }
+
+  DCHECK_EQ(MatchOriginAsFallbackBehavior::kMatchForAboutSchemeAndClimbTree,
+            match_origin_as_fallback);
+
+  // Unfortunately, in this case, we have to climb the frame tree. This is for
+  // match patterns that are associated with paths as well, not just origins.
+  // For instance, if an extension wants to run on google.com/maps/* with
+  // match_about_blank true, then it should run on about:-scheme frames created
+  // by google.com/maps, but not about:-scheme frames created by google.com
+  // (which is what the precursor tuple origin would be).
+
+  // Traverse the frame/window hierarchy to find the closest non-about:-page
+  // with the same origin as the precursor and return its URL.
+  // Note: This can return the incorrect result, e.g. if a parent frame
+  // navigates a grandchild frame.
+  blink::WebFrame* parent = frame;
+  GURL parent_url;
+  blink::WebDocument parent_document;
+  base::flat_set<blink::WebFrame*> already_visited_frames;
+  do {
+    already_visited_frames.insert(parent);
+    if (parent->Parent())
+      parent = parent->Parent();
+    else
+      parent = parent->Opener();
+
+    // Avoid an infinite loop - see https://crbug.com/568432 and
+    // https://crbug.com/883526.
+    if (base::Contains(already_visited_frames, parent))
+      return document_url;
+
+    parent_document = parent && parent->IsWebLocalFrame()
+                          ? parent->ToWebLocalFrame()->GetDocument()
+                          : blink::WebDocument();
+
+    // We reached the end of the ancestral chain without finding a valid parent,
+    // or found a remote web frame (in which case, it's a different origin).
+    // Bail and use the original URL.
+    if (parent_document.IsNull())
+      return document_url;
+
+    url::SchemeHostPort parent_tuple_or_precursor_tuple =
+        url::Origin(parent->GetSecurityOrigin())
+            .GetTupleOrPrecursorTupleIfOpaque();
+    if (!parent_tuple_or_precursor_tuple.IsValid() ||
+        parent_tuple_or_precursor_tuple != tuple_or_precursor_tuple) {
+      // The parent has a different tuple origin than frame; this could happen
+      // in edge cases where a parent navigates an iframe or popup of a child
+      // frame at a different origin. [1] In this case, bail, since we can't
+      // find a full URL (i.e., one including the path) with the same security
+      // origin to use for the frame in question.
+      // [1] Consider a frame tree like:
+      // <html> <!--example.com-->
+      //   <iframe id="a" src="a.com">
+      //     <iframe id="b" src="b.com"></iframe>
+      //   </iframe>
+      // </html>
+      // Frame "a" is cross-origin from the top-level frame, and so the
+      // example.com top-level frame can't directly access frame "b". However,
+      // it can navigate it through
+      // window.frames[0].frames[0].location.href = 'about:blank';
+      // In that case, the precursor origin tuple origin of frame "b" would be
+      // example.com, but the parent tuple origin is a.com.
+      // Note that usually, this would have bailed earlier with a remote frame,
+      // but it may not if we're at the process limit.
+      return document_url;
+    }
+
+    parent_url = GURL(parent_document.Url());
+  } while (parent_url.SchemeIs(url::kAboutScheme));
+
+  DCHECK(!parent_url.is_empty());
+  DCHECK(!parent_document.IsNull());
+
+  // We should know that the frame can access the parent document (unless we
+  // explicitly allow it not to), since it has the same tuple origin as the
+  // frame, and we checked the frame access above.
+  DCHECK(allow_inaccessible_parents ||
+         web_frame_origin.CanAccess(parent_document.GetSecurityOrigin()));
+  return parent_url;
+}
+
+// std::string GetContextTypeDescriptionString(Feature::Context context_type) {
+//   switch (context_type) {
+//     case Feature::UNSPECIFIED_CONTEXT:
+//       return "UNSPECIFIED";
+//     case Feature::BLESSED_EXTENSION_CONTEXT:
+//       return "BLESSED_EXTENSION";
+//     case Feature::UNBLESSED_EXTENSION_CONTEXT:
+//       return "UNBLESSED_EXTENSION";
+//     case Feature::CONTENT_SCRIPT_CONTEXT:
+//       return "CONTENT_SCRIPT";
+//     case Feature::WEB_PAGE_CONTEXT:
+//       return "WEB_PAGE";
+//     case Feature::BLESSED_WEB_PAGE_CONTEXT:
+//       return "BLESSED_WEB_PAGE";
+//     case Feature::WEBUI_CONTEXT:
+//       return "WEBUI";
+//     case Feature::WEBUI_UNTRUSTED_CONTEXT:
+//       return "WEBUI_UNTRUSTED";
+//     case Feature::LOCK_SCREEN_EXTENSION_CONTEXT:
+//       return "LOCK_SCREEN_EXTENSION";
+//   }
+//   NOTREACHED();
+//   return std::string();
+// }
+
+// static std::string ToStringOrDefault(v8::Isolate* isolate,
+//                                      const v8::Local<v8::String>& v8_string,
+//                                      const std::string& dflt) {
+//   if (v8_string.IsEmpty())
+//     return dflt;
+//   std::string ascii_value = *v8::String::Utf8Value(isolate, v8_string);
+//   return ascii_value.empty() ? dflt : ascii_value;
+// }
+
+using FrameToDocumentLoader =
+    base::flat_map<blink::WebLocalFrame*, blink::WebDocumentLoader*>;
+
+FrameToDocumentLoader& FrameDocumentLoaderMap() {
+  static base::NoDestructor<FrameToDocumentLoader> map;
+  return *map;
+}
+
+blink::WebDocumentLoader* CurrentDocumentLoader(
+    const blink::WebLocalFrame* frame) {
+  auto& map = FrameDocumentLoaderMap();
+  auto it = map.find(frame);
+  return it == map.end() ? frame->GetDocumentLoader() : it->second;
+}
+
+}  // namespace
+
+// ScriptContext::ScopedFrameDocumentLoader::ScopedFrameDocumentLoader(
+//     blink::WebLocalFrame* frame,
+//     blink::WebDocumentLoader* document_loader)
+//     : frame_(frame), document_loader_(document_loader) {
+//   auto& map = FrameDocumentLoaderMap();
+//   DCHECK(map.find(frame_) == map.end());
+//   map[frame_] = document_loader_;
+// }
+
+// ScriptContext::ScopedFrameDocumentLoader::~ScopedFrameDocumentLoader() {
+//   auto& map = FrameDocumentLoaderMap();
+//   DCHECK_EQ(document_loader_, map.find(frame_)->second);
+//   map.erase(frame_);
+// }
+
+// ScriptContext::ScriptContext(const v8::Local<v8::Context>& v8_context,
+//                              blink::WebLocalFrame* web_frame,
+//                              const Extension* extension,
+//                              Feature::Context context_type,
+//                              const Extension* effective_extension,
+//                              Feature::Context effective_context_type)
+//     : is_valid_(true),
+//       v8_context_(v8_context->GetIsolate(), v8_context),
+//       web_frame_(web_frame),
+//       extension_(extension),
+//       context_type_(context_type),
+//       effective_extension_(effective_extension),
+//       effective_context_type_(effective_context_type),
+//       context_id_(base::UnguessableToken::Create()),
+//       safe_builtins_(this),
+//       isolate_(v8_context->GetIsolate()),
+//       service_worker_version_id_(blink::mojom::kInvalidServiceWorkerVersionId) {
+//   VLOG(1) << "Created context:\n" << GetDebugString();
+//   v8_context_.AnnotateStrongRetainer("extensions::ScriptContext::v8_context_");
+//   if (web_frame_)
+//     url_ = GetAccessCheckedFrameURL(web_frame_);
+// }
+
+// ScriptContext::~ScriptContext() {
+//   VLOG(1) << "Destroyed context for extension\n"
+//           << "  extension id: " << GetExtensionID() << "\n"
+//           << "  effective extension id: "
+//           << (effective_extension_.get() ? effective_extension_->id() : "");
+//   CHECK(!is_valid_) << "ScriptContexts must be invalidated before destruction";
+// }
+
+// // static
+// bool ScriptContext::IsSandboxedPage(const GURL& url) {
+//   // TODO(kalman): This is checking the wrong thing. See comment in
+//   // HasAccessOrThrowError.
+//   if (url.SchemeIs(kExtensionScheme)) {
+//     const Extension* extension =
+//         RendererExtensionRegistry::Get()->GetByID(url.host());
+//     if (extension) {
+//       return SandboxedPageInfo::IsSandboxedPage(extension, url.path());
+//     }
+//   }
+//   return false;
+// }
+
+// void ScriptContext::SetModuleSystem(
+//     std::unique_ptr<ModuleSystem> module_system) {
+//   module_system_ = std::move(module_system);
+//   module_system_->Initialize();
+// }
+
+// void ScriptContext::Invalidate() {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   CHECK(is_valid_);
+//   is_valid_ = false;
+
+//   // TODO(kalman): Make ModuleSystem use AddInvalidationObserver.
+//   // Ownership graph is a bit weird here.
+//   if (module_system_)
+//     module_system_->Invalidate();
+
+//   // Swap |invalidate_observers_| to a local variable to clear it, and to make
+//   // sure it's not mutated as we iterate.
+//   std::vector<base::OnceClosure> observers;
+//   observers.swap(invalidate_observers_);
+//   for (base::OnceClosure& observer : observers) {
+//     std::move(observer).Run();
+//   }
+//   DCHECK(invalidate_observers_.empty())
+//       << "Invalidation observers cannot be added during invalidation";
+
+//   v8_context_.Reset();
+// }
+
+// void ScriptContext::AddInvalidationObserver(base::OnceClosure observer) {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   invalidate_observers_.push_back(std::move(observer));
+// }
+
+// const std::string& ScriptContext::GetExtensionID() const {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   return extension_.get() ? extension_->id() : base::EmptyString();
+// }
+
+// content::RenderFrame* ScriptContext::GetRenderFrame() const {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   if (web_frame_)
+//     return content::RenderFrame::FromWebFrame(web_frame_);
+//   return NULL;
+// }
+
+// void ScriptContext::SafeCallFunction(const v8::Local<v8::Function>& function,
+//                                      int argc,
+//                                      v8::Local<v8::Value> argv[]) {
+//   SafeCallFunction(function, argc, argv,
+//                    ScriptInjectionCallback::CompleteCallback());
+// }
+
+// void ScriptContext::SafeCallFunction(
+//     const v8::Local<v8::Function>& function,
+//     int argc,
+//     v8::Local<v8::Value> argv[],
+//     const ScriptInjectionCallback::CompleteCallback& callback) {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   v8::HandleScope handle_scope(isolate());
+//   v8::Context::Scope scope(v8_context());
+//   v8::MicrotasksScope microtasks(isolate(),
+//                                  v8::MicrotasksScope::kDoNotRunMicrotasks);
+//   v8::Local<v8::Object> global = v8_context()->Global();
+//   if (web_frame_) {
+//     ScriptInjectionCallback* wrapper_callback = nullptr;
+//     if (!callback.is_null()) {
+//       // ScriptInjectionCallback manages its own lifetime.
+//       wrapper_callback = new ScriptInjectionCallback(callback);
+//     }
+//     web_frame_->RequestExecuteV8Function(v8_context(), function, global, argc,
+//                                          argv, wrapper_callback);
+//   } else {
+//     v8::MaybeLocal<v8::Value> maybe_result =
+//         function->Call(v8_context(), global, argc, argv);
+//     v8::Local<v8::Value> result;
+//     if (!callback.is_null() && maybe_result.ToLocal(&result)) {
+//       std::vector<v8::Local<v8::Value>> results(1, result);
+//       callback.Run(results);
+//     }
+//   }
+// }
+
+// Feature::Availability ScriptContext::GetAvailability(
+//     const std::string& api_name) {
+//   return GetAvailability(api_name, CheckAliasStatus::ALLOWED);
+// }
+
+// Feature::Availability ScriptContext::GetAvailability(
+//     const std::string& api_name,
+//     CheckAliasStatus check_alias) {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   if (base::StartsWith(api_name, "test", base::CompareCase::SENSITIVE)) {
+//     bool allowed = base::CommandLine::ForCurrentProcess()->
+//                        HasSwitch(::switches::kTestType);
+//     Feature::AvailabilityResult result =
+//         allowed ? Feature::IS_AVAILABLE : Feature::MISSING_COMMAND_LINE_SWITCH;
+//     return Feature::Availability(result,
+//                                  allowed ? "" : "Only allowed in tests");
+//   }
+//   // Hack: Hosted apps should have the availability of messaging APIs based on
+//   // the URL of the page (which might have access depending on some extension
+//   // with externally_connectable), not whether the app has access to messaging
+//   // (which it won't).
+//   const Extension* extension = extension_.get();
+//   if (extension && extension->is_hosted_app() &&
+//       (api_name == "runtime.connect" || api_name == "runtime.sendMessage")) {
+//     extension = NULL;
+//   }
+//   return ExtensionAPI::GetSharedInstance()->IsAvailable(
+//       api_name, extension, context_type_, url(), check_alias);
+// }
+
+// std::string ScriptContext::GetContextTypeDescription() const {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   return GetContextTypeDescriptionString(context_type_);
+// }
+
+// std::string ScriptContext::GetEffectiveContextTypeDescription() const {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   return GetContextTypeDescriptionString(effective_context_type_);
+// }
+
+// const GURL& ScriptContext::service_worker_scope() const {
+//   DCHECK(IsForServiceWorker());
+//   return service_worker_scope_;
+// }
+
+// bool ScriptContext::IsForServiceWorker() const {
+//   return service_worker_version_id_ !=
+//          blink::mojom::kInvalidServiceWorkerVersionId;
+// }
+
+// bool ScriptContext::IsAnyFeatureAvailableToContext(
+//     const Feature& api,
+//     CheckAliasStatus check_alias) {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   // TODO(lazyboy): Decide what we should do for service workers, where
+//   // web_frame() is null.
+//   GURL url = web_frame() ? GetDocumentLoaderURLForFrame(web_frame()) : url_;
+//   return ExtensionAPI::GetSharedInstance()->IsAnyFeatureAvailableToContext(
+//       api, extension(), context_type(), url, check_alias);
+// }
+
+// static
+GURL ScriptContext::GetDocumentLoaderURLForFrame(
+    const blink::WebLocalFrame* frame) {
+  // Normally we would use frame->document().url() to determine the document's
+  // URL, but to decide whether to inject a content script, we use the URL from
+  // the data source. This "quirk" helps prevents content scripts from
+  // inadvertently adding DOM elements to the compose iframe in Gmail because
+  // the compose iframe's dataSource URL is about:blank, but the document URL
+  // changes to match the parent document after Gmail document.writes into
+  // it to create the editor.
+  // http://code.google.com/p/chromium/issues/detail?id=86742
+  blink::WebDocumentLoader* document_loader = CurrentDocumentLoader(frame);
+  return document_loader ? GURL(document_loader->GetUrl()) : GURL();
+}
+
+// // static
+// GURL ScriptContext::GetAccessCheckedFrameURL(
+//     const blink::WebLocalFrame* frame) {
+//   const blink::WebURL& weburl = frame->GetDocument().Url();
+//   if (weburl.IsEmpty()) {
+//     blink::WebDocumentLoader* document_loader = CurrentDocumentLoader(frame);
+//     if (document_loader &&
+//         frame->GetSecurityOrigin().CanAccess(
+//             blink::WebSecurityOrigin::Create(document_loader->GetUrl()))) {
+//       return GURL(document_loader->GetUrl());
+//     }
+//   }
+//   return GURL(weburl);
+// }
+
+// // static
+// GURL ScriptContext::GetEffectiveDocumentURLForContext(
+//     blink::WebLocalFrame* frame,
+//     const GURL& document_url,
+//     bool match_about_blank) {
+//   // Note: Do not allow matching inaccessible parent frames here; frames like
+//   // sandboxed frames should not inherit the privilege of their parents.
+//   constexpr bool allow_inaccessible_parents = false;
+//   // TODO(devlin): Determine if this could use kAlways instead of
+//   // kMatchForAboutSchemeAndClimbTree.
+//   auto match_origin_as_fallback =
+//       match_about_blank
+//           ? MatchOriginAsFallbackBehavior::kMatchForAboutSchemeAndClimbTree
+//           : MatchOriginAsFallbackBehavior::kNever;
+//   return GetEffectiveDocumentURL(frame, document_url, match_origin_as_fallback,
+//                                  allow_inaccessible_parents);
+// }
+
+// static
+GURL ScriptContext::GetEffectiveDocumentURLForInjection(
+    blink::WebLocalFrame* frame,
+    const GURL& document_url,
+    MatchOriginAsFallbackBehavior match_origin_as_fallback) {
+  // We explicitly allow inaccessible parents here. Extensions should still be
+  // able to inject into a sandboxed iframe if it has access to the embedding
+  // origin.
+  constexpr bool allow_inaccessible_parents = true;
+  return GetEffectiveDocumentURL(frame, document_url, match_origin_as_fallback,
+                                 allow_inaccessible_parents);
+}
+
+// // Grants a set of content capabilities to this context.
+
+// bool ScriptContext::HasAPIPermission(APIPermission::ID permission) const {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   if (effective_extension_.get()) {
+//     return effective_extension_->permissions_data()->HasAPIPermission(
+//         permission);
+//   }
+//   if (context_type() == Feature::WEB_PAGE_CONTEXT) {
+//     // Only web page contexts may be granted content capabilities. Other
+//     // contexts are either privileged WebUI or extensions with their own set of
+//     // permissions.
+//     if (content_capabilities_.find(permission) != content_capabilities_.end())
+//       return true;
+//   }
+//   return false;
+// }
+
+// bool ScriptContext::HasAccessOrThrowError(const std::string& name) {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   // Theoretically[1] we could end up with bindings being injected into
+//   // sandboxed frames, for example content scripts. Don't let them execute API
+//   // functions.
+//   //
+//   // In any case, this check is silly. The frame's document's security origin
+//   // already tells us if it's sandboxed. The only problem is that until
+//   // crbug.com/466373 is fixed, we don't know the security origin up-front and
+//   // may not know it here, either.
+//   //
+//   // [1] citation needed. This ScriptContext should already be in a state that
+//   // doesn't allow this, from ScriptContextSet::ClassifyJavaScriptContext.
+//   if (extension() &&
+//       SandboxedPageInfo::IsSandboxedPage(extension(), url_.path())) {
+//     static const char kMessage[] =
+//         "%s cannot be used within a sandboxed frame.";
+//     std::string error_msg = base::StringPrintf(kMessage, name.c_str());
+//     isolate()->ThrowException(v8::Exception::Error(
+//         v8::String::NewFromUtf8(isolate(), error_msg.c_str(),
+//                                 v8::NewStringType::kNormal)
+//             .ToLocalChecked()));
+//     return false;
+//   }
+
+//   Feature::Availability availability = GetAvailability(name);
+//   if (!availability.is_available()) {
+//     isolate()->ThrowException(v8::Exception::Error(
+//         v8::String::NewFromUtf8(isolate(), availability.message().c_str(),
+//                                 v8::NewStringType::kNormal)
+//             .ToLocalChecked()));
+//     return false;
+//   }
+
+//   return true;
+// }
+
+// std::string ScriptContext::GetDebugString() const {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   return base::StringPrintf(
+//       "  extension id:           %s\n"
+//       "  frame:                  %p\n"
+//       "  URL:                    %s\n"
+//       "  context_type:           %s\n"
+//       "  effective extension id: %s\n"
+//       "  effective context type: %s",
+//       extension_.get() ? extension_->id().c_str() : "(none)", web_frame_,
+//       url_.spec().c_str(), GetContextTypeDescription().c_str(),
+//       effective_extension_.get() ? effective_extension_->id().c_str()
+//                                  : "(none)",
+//       GetEffectiveContextTypeDescription().c_str());
+// }
+
+// std::string ScriptContext::GetStackTraceAsString() const {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   v8::Local<v8::StackTrace> stack_trace =
+//       v8::StackTrace::CurrentStackTrace(isolate(), 10);
+//   if (stack_trace.IsEmpty() || stack_trace->GetFrameCount() <= 0) {
+//     return "    <no stack trace>";
+//   }
+//   std::string result;
+//   for (int i = 0; i < stack_trace->GetFrameCount(); ++i) {
+//     v8::Local<v8::StackFrame> frame = stack_trace->GetFrame(isolate(), i);
+//     CHECK(!frame.IsEmpty());
+//     result += base::StringPrintf(
+//         "\n    at %s (%s:%d:%d)",
+//         ToStringOrDefault(isolate(), frame->GetFunctionName(), "<anonymous>")
+//             .c_str(),
+//         ToStringOrDefault(isolate(), frame->GetScriptName(), "<anonymous>")
+//             .c_str(),
+//         frame->GetLineNumber(), frame->GetColumn());
+//   }
+//   return result;
+// }
+
+// v8::Local<v8::Value> ScriptContext::RunScript(
+//     v8::Local<v8::String> name,
+//     v8::Local<v8::String> code,
+//     const RunScriptExceptionHandler& exception_handler,
+//     v8::ScriptCompiler::NoCacheReason no_cache_reason) {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   v8::EscapableHandleScope handle_scope(isolate());
+//   v8::Context::Scope context_scope(v8_context());
+
+//   // Prepend extensions:: to |name| so that internal code can be differentiated
+//   // from external code in stack traces. This has no effect on behaviour.
+//   std::string internal_name = base::StringPrintf(
+//       "extensions::%s", *v8::String::Utf8Value(isolate(), name));
+
+//   if (internal_name.size() >= v8::String::kMaxLength) {
+//     NOTREACHED() << "internal_name is too long.";
+//     return v8::Undefined(isolate());
+//   }
+
+//   v8::MicrotasksScope microtasks(
+//       isolate(), v8::MicrotasksScope::kDoNotRunMicrotasks);
+//   v8::TryCatch try_catch(isolate());
+//   try_catch.SetCaptureMessage(true);
+//   v8::ScriptOrigin origin(
+//       v8_helpers::ToV8StringUnsafe(isolate(), internal_name.c_str()));
+//   v8::ScriptCompiler::Source script_source(code, origin);
+//   v8::Local<v8::Script> script;
+//   if (!v8::ScriptCompiler::Compile(v8_context(), &script_source,
+//                                    v8::ScriptCompiler::kNoCompileOptions,
+//                                    no_cache_reason)
+//            .ToLocal(&script)) {
+//     exception_handler.Run(try_catch);
+//     return v8::Undefined(isolate());
+//   }
+
+//   v8::Local<v8::Value> result;
+//   if (!script->Run(v8_context()).ToLocal(&result)) {
+//     exception_handler.Run(try_catch);
+//     return v8::Undefined(isolate());
+//   }
+
+//   return handle_scope.Escape(result);
+// }
+
+// v8::Local<v8::Value> ScriptContext::CallFunction(
+//     const v8::Local<v8::Function>& function,
+//     int argc,
+//     v8::Local<v8::Value> argv[]) const {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   v8::EscapableHandleScope handle_scope(isolate());
+//   v8::Context::Scope scope(v8_context());
+
+//   v8::MicrotasksScope microtasks(isolate(),
+//                                  v8::MicrotasksScope::kDoNotRunMicrotasks);
+//   if (!is_valid_) {
+//     return handle_scope.Escape(
+//         v8::Local<v8::Primitive>(v8::Undefined(isolate())));
+//   }
+
+//   v8::Local<v8::Object> global = v8_context()->Global();
+//   if (!web_frame_) {
+//     v8::MaybeLocal<v8::Value> maybe_result =
+//         function->Call(v8_context(), global, argc, argv);
+//     v8::Local<v8::Value> result;
+//     if (!maybe_result.ToLocal(&result)) {
+//       return handle_scope.Escape(
+//           v8::Local<v8::Primitive>(v8::Undefined(isolate())));
+//     }
+//     return handle_scope.Escape(result);
+//   }
+
+//   v8::MaybeLocal<v8::Value> result =
+//       web_frame_->CallFunctionEvenIfScriptDisabled(function, global, argc,
+//                                                    argv);
+
+//   // TODO(devlin): Stop coercing this to a v8::Local.
+//   v8::Local<v8::Value> coerced_result;
+//   ignore_result(result.ToLocal(&coerced_result));
+//   return handle_scope.Escape(coerced_result);
+// }
+
+}  // namespace extensions
diff --git a/components/user_scripts/renderer/script_context.h b/components/user_scripts/renderer/script_context.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/script_context.h
@@ -0,0 +1,332 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_SCRIPT_CONTEXT_H_
+#define EXTENSIONS_RENDERER_SCRIPT_CONTEXT_H_
+
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/callback.h"
+#include "base/compiler_specific.h"
+#include "base/macros.h"
+#include "base/threading/thread_checker.h"
+#include "base/unguessable_token.h"
+//#include "extensions/common/features/feature.h"
+//#include "extensions/common/permissions/api_permission_set.h"
+#include "../common/script_constants.h"
+//#include "extensions/renderer/module_system.h"
+//#include "extensions/renderer/safe_builtins.h"
+#include "script_injection_callback.h"
+#include "url/gurl.h"
+#include "v8/include/v8.h"
+
+namespace blink {
+class WebDocumentLoader;
+class WebLocalFrame;
+}
+
+namespace content {
+class RenderFrame;
+}
+
+namespace user_scripts {
+// enum class CheckAliasStatus;
+// class Extension;
+
+// Extensions wrapper for a v8::Context.
+//
+// v8::Contexts can be constructed on any thread, and must only be accessed or
+// destroyed that thread.
+//
+// Note that ScriptContexts bound to worker threads will not have the full
+// functionality as those bound to the main RenderThread.
+class ScriptContext {
+ public:
+  // using RunScriptExceptionHandler = base::Callback<void(const v8::TryCatch&)>;
+
+  // ScriptContext(const v8::Local<v8::Context>& context,
+  //               blink::WebLocalFrame* frame,
+  //               const Extension* extension,
+  //               Feature::Context context_type,
+  //               const Extension* effective_extension,
+  //               Feature::Context effective_context_type);
+  // ~ScriptContext();
+
+  // // Returns whether |url| from any Extension in |extension_set| is sandboxed,
+  // // as declared in each Extension's manifest.
+  // // TODO(kalman): Delete this when crbug.com/466373 is fixed.
+  // // See comment in HasAccessOrThrowError.
+  // static bool IsSandboxedPage(const GURL& url);
+
+  // // Initializes |module_system| and associates it with this context.
+  // void SetModuleSystem(std::unique_ptr<ModuleSystem> module_system);
+
+  // // Clears the WebLocalFrame for this contexts and invalidates the associated
+  // // ModuleSystem.
+  // void Invalidate();
+
+  // // Registers |observer| to be run when this context is invalidated. Closures
+  // // are run immediately when Invalidate() is called, not in a message loop.
+  // void AddInvalidationObserver(base::OnceClosure observer);
+
+  // // Returns true if this context is still valid, false if it isn't.
+  // // A context becomes invalid via Invalidate().
+  // bool is_valid() const { return is_valid_; }
+
+  // v8::Local<v8::Context> v8_context() const {
+  //   return v8::Local<v8::Context>::New(isolate_, v8_context_);
+  // }
+
+  // const Extension* extension() const { return extension_.get(); }
+
+  // const Extension* effective_extension() const {
+  //   return effective_extension_.get();
+  // }
+
+  // blink::WebLocalFrame* web_frame() const { return web_frame_; }
+
+  // Feature::Context context_type() const { return context_type_; }
+
+  // Feature::Context effective_context_type() const {
+  //   return effective_context_type_;
+  // }
+
+  // const base::UnguessableToken& context_id() const { return context_id_; }
+
+  // ModuleSystem* module_system() { return module_system_.get(); }
+
+  // SafeBuiltins* safe_builtins() { return &safe_builtins_; }
+
+  // const SafeBuiltins* safe_builtins() const { return &safe_builtins_; }
+
+  // // Returns the ID of the extension associated with this context, or empty
+  // // string if there is no such extension.
+  // const std::string& GetExtensionID() const;
+
+  // // Returns the RenderFrame associated with this context. Can return NULL if
+  // // the context is in the process of being destroyed.
+  // content::RenderFrame* GetRenderFrame() const;
+
+  // // Safely calls the v8::Function, respecting the page load deferrer and
+  // // possibly executing asynchronously.
+  // // Doesn't catch exceptions; callers must do that if they want.
+  // // USE THESE METHODS RATHER THAN v8::Function::Call WHEREVER POSSIBLE.
+  // void SafeCallFunction(const v8::Local<v8::Function>& function,
+  //                       int argc,
+  //                       v8::Local<v8::Value> argv[]);
+  // void SafeCallFunction(
+  //     const v8::Local<v8::Function>& function,
+  //     int argc,
+  //     v8::Local<v8::Value> argv[],
+  //     const ScriptInjectionCallback::CompleteCallback& callback);
+
+  // // Returns the availability of the API |api_name|.
+  // Feature::Availability GetAvailability(const std::string& api_name);
+  // // Returns the availability of the API |api_name|.
+  // // |check_alias| Whether API that has an alias that is available should be
+  // // considered available (even if the API itself is not available).
+  // Feature::Availability GetAvailability(const std::string& api_name,
+  //                                       CheckAliasStatus check_alias);
+
+  // // Returns a string description of the type of context this is.
+  // std::string GetContextTypeDescription() const;
+
+  // // Returns a string description of the effective type of context this is.
+  // std::string GetEffectiveContextTypeDescription() const;
+
+  // v8::Isolate* isolate() const { return isolate_; }
+
+  // // Get the URL of this context's web frame.
+  // //
+  // // TODO(kalman): Remove this and replace with a GetOrigin() call which reads
+  // // of WebDocument::getSecurityOrigin():
+  // //  - The URL can change (e.g. pushState) but the origin cannot. Luckily it
+  // //    appears as though callers don't make security decisions based on the
+  // //    result of url() so it's not a problem... yet.
+  // //  - Origin is the correct check to be making.
+  // //  - It might let us remove the about:blank resolving?
+  // const GURL& url() const { return url_; }
+
+  // const GURL& service_worker_scope() const;
+
+  // int64_t service_worker_version_id() const {
+  //   return service_worker_version_id_;
+  // }
+
+  // bool IsForServiceWorker() const;
+
+  // // Sets the URL of this ScriptContext. Usually this will automatically be set
+  // // on construction, unless this isn't constructed with enough information to
+  // // determine the URL (e.g. frame was null).
+  // // TODO(kalman): Make this a constructor parameter (as an origin).
+  // void set_url(const GURL& url) { url_ = url; }
+  // void set_service_worker_scope(const GURL& scope) {
+  //   service_worker_scope_ = scope;
+  // }
+  // void set_service_worker_version_id(int64_t service_worker_version_id) {
+  //   service_worker_version_id_ = service_worker_version_id;
+  // }
+
+  // // Returns whether the API |api| or any part of the API could be available in
+  // // this context without taking into account the context's extension.
+  // // |check_alias| Whether the API should be considered available if it has an
+  // // alias that is available.
+  // bool IsAnyFeatureAvailableToContext(const extensions::Feature& api,
+  //                                     CheckAliasStatus check_alias);
+
+  // // Scope which maps a frame to a document loader. This is used by various
+  // // static methods below, which need to account for "just about to load"
+  // // document when retrieving URL.
+  // class ScopedFrameDocumentLoader {
+  //  public:
+  //   ScopedFrameDocumentLoader(blink::WebLocalFrame* frame,
+  //                             blink::WebDocumentLoader* document_loader);
+  //   ~ScopedFrameDocumentLoader();
+
+  //  private:
+  //   blink::WebLocalFrame* frame_;
+  //   blink::WebDocumentLoader* document_loader_;
+  //   DISALLOW_COPY_AND_ASSIGN(ScopedFrameDocumentLoader);
+  // };
+
+  // TODO(devlin): Move all these Get*URL*() methods out of here? While they are
+  // vaguely ScriptContext related, there's enough here that they probably
+  // warrant another class or utility file.
+
+  // Utility to get the URL we will match against for a frame. If the frame has
+  // committed, this is the commited URL. Otherwise it is the provisional URL.
+  // The returned URL may be invalid.
+  static GURL GetDocumentLoaderURLForFrame(const blink::WebLocalFrame* frame);
+
+//   // Similar to GetDocumentLoaderURLForFrame, but only returns the data source
+//   // URL if the frame's document url is empty and the frame has a security
+//   // origin that allows access to the data source url.
+//   // TODO(asargent/devlin) - there may be places that should switch to using
+//   // this instead of GetDocumentLoaderURLForFrame.
+//   static GURL GetAccessCheckedFrameURL(const blink::WebLocalFrame* frame);
+
+//   // Used to determine the "effective" URL in context classification, such as to
+//   // associate an about:blank frame in an extension context with its extension.
+//   // If |document_url| is an about: or data: URL, returns the URL of the first
+//   // frame without an about: or data: URL that matches the initiator origin.
+//   // This may not be the immediate parent. Returns |document_url| if it is not
+//   // an about: URL, if |match_about_blank| is false, or if a suitable parent
+//   // cannot be found.
+//   // Will not check parent contexts that cannot be accessed (as is the case
+//   // for sandboxed frames).
+//   static GURL GetEffectiveDocumentURLForContext(blink::WebLocalFrame* frame,
+//                                                 const GURL& document_url,
+//                                                 bool match_about_blank);
+
+  // Used to determine the "effective" URL for extension script injection.
+  // If |document_url| is an about: or data: URL, returns the URL of the first
+  // frame without an about: or data: URL that matches the initiator origin.
+  // This may not be the immediate parent. Returns |document_url| if it is not
+  // an about: or data: URL, if |match_origin_as_fallback| is set to not match,
+  // or if a suitable parent cannot be found.
+  // Considers parent contexts that cannot be accessed (as is the case for
+  // sandboxed frames).
+  static GURL GetEffectiveDocumentURLForInjection(
+      blink::WebLocalFrame* frame,
+      const GURL& document_url,
+      MatchOriginAsFallbackBehavior match_origin_as_fallback);
+
+//   // Grants a set of content capabilities to this context.
+//   void set_content_capabilities(APIPermissionSet capabilities) {
+//     content_capabilities_ = std::move(capabilities);
+//   }
+
+//   // Indicates if this context has an effective API permission either by being
+//   // a context for an extension which has that permission, or by being a web
+//   // context which has been granted the corresponding capability by an
+//   // extension.
+//   bool HasAPIPermission(APIPermission::ID permission) const;
+
+//   // Throws an Error in this context's JavaScript context, if this context does
+//   // not have access to |name|. Returns true if this context has access (i.e.
+//   // no exception thrown), false if it does not (i.e. an exception was thrown).
+//   bool HasAccessOrThrowError(const std::string& name);
+
+//   // Returns a string representation of this ScriptContext, for debugging.
+//   std::string GetDebugString() const;
+
+//   // Gets the current stack trace as a multi-line string to be logged.
+//   std::string GetStackTraceAsString() const;
+
+//   // Runs |code|, labelling the script that gets created as |name| (the name is
+//   // used in the devtools and stack traces). |exception_handler| will be called
+//   // re-entrantly if an exception is thrown during the script's execution.
+//   v8::Local<v8::Value> RunScript(
+//       v8::Local<v8::String> name,
+//       v8::Local<v8::String> code,
+//       const RunScriptExceptionHandler& exception_handler,
+//       v8::ScriptCompiler::NoCacheReason no_cache_reason =
+//           v8::ScriptCompiler::NoCacheReason::kNoCacheNoReason);
+
+//  private:
+//   // DEPRECATED.
+//   v8::Local<v8::Value> CallFunction(const v8::Local<v8::Function>& function,
+//                                     int argc,
+//                                     v8::Local<v8::Value> argv[]) const;
+
+//   // Whether this context is valid.
+//   bool is_valid_;
+
+//   // The v8 context the bindings are accessible to.
+//   v8::Global<v8::Context> v8_context_;
+
+//   // The WebLocalFrame associated with this context. This can be NULL because
+//   // this object can outlive is destroyed asynchronously.
+//   blink::WebLocalFrame* web_frame_;
+
+//   // The extension associated with this context, or NULL if there is none. This
+//   // might be a hosted app in the case that this context is hosting a web URL.
+//   scoped_refptr<const Extension> extension_;
+
+//   // The type of context.
+//   Feature::Context context_type_;
+
+//   // The effective extension associated with this context, or NULL if there is
+//   // none. This is different from the above extension if this context is in an
+//   // about:blank iframe for example.
+//   scoped_refptr<const Extension> effective_extension_;
+
+//   // The type of context.
+//   Feature::Context effective_context_type_;
+
+//   // A globally-unique ID for the script context.
+//   base::UnguessableToken context_id_;
+
+//   // Owns and structures the JS that is injected to set up extension bindings.
+//   std::unique_ptr<ModuleSystem> module_system_;
+
+//   // Contains safe copies of builtin objects like Function.prototype.
+//   SafeBuiltins safe_builtins_;
+
+//   // The set of capabilities granted to this context by extensions.
+//   APIPermissionSet content_capabilities_;
+
+//   // A list of base::OnceClosure instances as an observer interface for
+//   // invalidation.
+//   std::vector<base::OnceClosure> invalidate_observers_;
+
+//   v8::Isolate* isolate_;
+
+//   GURL url_;
+
+//   GURL service_worker_scope_;
+
+//   int64_t service_worker_version_id_;
+
+//   base::ThreadChecker thread_checker_;
+
+//   DISALLOW_COPY_AND_ASSIGN(ScriptContext);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_SCRIPT_CONTEXT_H_
diff --git a/components/user_scripts/renderer/script_injection.cc b/components/user_scripts/renderer/script_injection.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/script_injection.cc
@@ -0,0 +1,412 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "script_injection.h"
+
+#include <map>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/feature_list.h"
+#include "base/lazy_instance.h"
+#include "base/macros.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/timer/elapsed_timer.h"
+#include "base/values.h"
+#include "base/logging.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/renderer/render_frame_observer.h"
+#include "content/public/renderer/v8_value_converter.h"
+//#include "extensions/common/extension_features.h"
+//#include "extensions/common/extension_messages.h"
+#include "../common/host_id.h"
+//#include "extensions/common/identifiability_metrics.h"
+//#include "extensions/renderer/dom_activity_logger.h"
+//#include "extensions/renderer/extension_frame_helper.h"
+//#include "extensions/renderer/extensions_renderer_client.h"
+#include "script_injection_callback.h"
+#include "scripts_run_info.h"
+#include "third_party/blink/public/platform/web_isolated_world_info.h"
+#include "third_party/blink/public/platform/web_security_origin.h"
+#include "third_party/blink/public/platform/web_string.h"
+#include "third_party/blink/public/web/web_document.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "third_party/blink/public/web/web_script_source.h"
+#include "url/gurl.h"
+
+namespace user_scripts {
+
+namespace {
+
+using IsolatedWorldMap = std::map<std::string, int>;
+base::LazyInstance<IsolatedWorldMap>::DestructorAtExit g_isolated_worlds =
+    LAZY_INSTANCE_INITIALIZER;
+
+const int64_t kInvalidRequestId = -1;
+
+// The id of the next pending injection.
+//int64_t g_next_pending_id = 0;
+
+// Gets the isolated world ID to use for the given |injection_host|. If no
+// isolated world has been created for that |injection_host| one will be created
+// and initialized.
+int GetIsolatedWorldIdForInstance(const InjectionHost* injection_host) {
+  static int g_next_isolated_world_id = 1; // Embedder isolated worlds can use IDs in [1, 1<<29).
+      //ExtensionsRendererClient::Get()->GetLowestIsolatedWorldId(); aka ChromeIsolatedWorldIDs.ISOLATED_WORLD_ID_EXTENSIONS
+
+  IsolatedWorldMap& isolated_worlds = g_isolated_worlds.Get();
+
+  int id = 0;
+  const std::string& key = injection_host->id().id();
+  auto iter = isolated_worlds.find(key);
+  if (iter != isolated_worlds.end()) {
+    id = iter->second;
+  } else {
+    id = g_next_isolated_world_id++;
+    // This map will tend to pile up over time, but realistically, you're never
+    // going to have enough injection hosts for it to matter.
+    isolated_worlds[key] = id;
+  }
+
+  blink::WebIsolatedWorldInfo info;
+  info.security_origin =
+      blink::WebSecurityOrigin::Create(injection_host->url());
+  info.human_readable_name = blink::WebString::FromUTF8(injection_host->name());
+  info.stable_id = blink::WebString::FromUTF8(key);
+
+  const std::string* csp = injection_host->GetContentSecurityPolicy();
+  if (csp)
+    info.content_security_policy = blink::WebString::FromUTF8(*csp);
+
+  // Even though there may be an existing world for this |injection_host|'s key,
+  // the properties may have changed (e.g. due to an extension update).
+  // Overwrite any existing entries.
+  blink::SetIsolatedWorldInfo(id, info);
+
+  return id;
+}
+
+// This class manages its own lifetime.
+class TimedScriptInjectionCallback : public ScriptInjectionCallback {
+ public:
+  TimedScriptInjectionCallback(base::WeakPtr<ScriptInjection> injection)
+      : ScriptInjectionCallback(
+            base::Bind(&TimedScriptInjectionCallback::OnCompleted,
+                       base::Unretained(this))),
+        injection_(injection) {}
+  ~TimedScriptInjectionCallback() override {}
+
+  void OnCompleted(const std::vector<v8::Local<v8::Value>>& result) {
+    if (injection_) {
+      base::TimeTicks timestamp(base::TimeTicks::Now());
+      base::Optional<base::TimeDelta> elapsed;
+      // If the script will never execute (such as if the context is destroyed),
+      // willExecute() will not be called, but OnCompleted() will. Only log a
+      // time for execution if the script, in fact, executed.
+      if (!start_time_.is_null())
+        elapsed = timestamp - start_time_;
+      injection_->OnJsInjectionCompleted(result, elapsed);
+    }
+  }
+
+  void WillExecute() override {
+    start_time_ = base::TimeTicks::Now();
+  }
+
+ private:
+  base::WeakPtr<ScriptInjection> injection_;
+  base::TimeTicks start_time_;
+};
+
+}  // namespace
+
+// Watches for the deletion of a RenderFrame, after which is_valid will return
+// false.
+class ScriptInjection::FrameWatcher : public content::RenderFrameObserver {
+ public:
+  FrameWatcher(content::RenderFrame* render_frame,
+               ScriptInjection* injection)
+      : content::RenderFrameObserver(render_frame),
+        injection_(injection) {}
+  ~FrameWatcher() override {}
+
+ private:
+  void WillDetach() override { injection_->invalidate_render_frame(); }
+  void OnDestruct() override { injection_->invalidate_render_frame(); }
+
+  ScriptInjection* injection_;
+
+  DISALLOW_COPY_AND_ASSIGN(FrameWatcher);
+};
+
+// static
+std::string ScriptInjection::GetHostIdForIsolatedWorld(int isolated_world_id) {
+  const IsolatedWorldMap& isolated_worlds = g_isolated_worlds.Get();
+
+  for (const auto& iter : isolated_worlds) {
+    if (iter.second == isolated_world_id)
+      return iter.first;
+  }
+  return std::string();
+}
+
+// static
+void ScriptInjection::RemoveIsolatedWorld(const std::string& host_id) {
+  g_isolated_worlds.Get().erase(host_id);
+}
+
+ScriptInjection::ScriptInjection(
+    std::unique_ptr<ScriptInjector> injector,
+    content::RenderFrame* render_frame,
+    std::unique_ptr<const InjectionHost> injection_host,
+    UserScript::RunLocation run_location,
+    bool log_activity)
+    : injector_(std::move(injector)),
+      render_frame_(render_frame),
+      injection_host_(std::move(injection_host)),
+      run_location_(run_location),
+      request_id_(kInvalidRequestId),
+      ukm_source_id_(base::UkmSourceId::FromInt64(
+          render_frame_->GetWebFrame()->GetDocument().GetUkmSourceId())),
+      complete_(false),
+      did_inject_js_(false),
+      log_activity_(log_activity),
+      frame_watcher_(new FrameWatcher(render_frame, this)) {
+  CHECK(injection_host_.get());
+}
+
+ScriptInjection::~ScriptInjection() {
+  if (!complete_)
+    NotifyWillNotInject(ScriptInjector::WONT_INJECT);
+}
+
+ScriptInjection::InjectionResult ScriptInjection::TryToInject(
+    UserScript::RunLocation current_location,
+    ScriptsRunInfo* scripts_run_info,
+    const CompletionCallback& async_completion_callback) {
+  if (current_location < run_location_)
+    return INJECTION_WAITING;  // Wait for the right location.
+
+  if (request_id_ != kInvalidRequestId) {
+    // We're waiting for permission right now, try again later.
+    return INJECTION_WAITING;
+  }
+
+  if (!injection_host_) {
+    NotifyWillNotInject(ScriptInjector::EXTENSION_REMOVED);
+    return INJECTION_FINISHED;  // We're done.
+  }
+
+  //blink::WebLocalFrame* web_frame = render_frame_->GetWebFrame();
+  // switch (injector_->CanExecuteOnFrame(
+  //     injection_host_.get(), web_frame,
+  //     ExtensionFrameHelper::Get(render_frame_)->tab_id())) {
+  //   case PermissionsData::PageAccess::kDenied:
+  //     NotifyWillNotInject(ScriptInjector::NOT_ALLOWED);
+  //     return INJECTION_FINISHED;  // We're done.
+  //   case PermissionsData::PageAccess::kWithheld:
+  //     RequestPermissionFromBrowser();
+  //     return INJECTION_WAITING;  // Wait around for permission.
+  //   case PermissionsData::PageAccess::kAllowed:
+      InjectionResult result = Inject(scripts_run_info);
+      // If the injection is blocked, we need to set the manager so we can
+      // notify it upon completion.
+      if (result == INJECTION_BLOCKED)
+        async_completion_callback_ = async_completion_callback;
+      return result;
+  //}
+
+  //NOTREACHED();
+  //return INJECTION_FINISHED;
+}
+
+ScriptInjection::InjectionResult ScriptInjection::OnPermissionGranted(
+    ScriptsRunInfo* scripts_run_info) {
+  if (!injection_host_) {
+    NotifyWillNotInject(ScriptInjector::EXTENSION_REMOVED);
+    return INJECTION_FINISHED;
+  }
+
+  return Inject(scripts_run_info);
+}
+
+void ScriptInjection::OnHostRemoved() {
+  injection_host_.reset(nullptr);
+}
+
+// void ScriptInjection::RequestPermissionFromBrowser() {
+//   // If we are just notifying the browser of the injection, then send an
+//   // invalid request (which is treated like a notification).
+//   request_id_ = g_next_pending_id++;
+//   render_frame_->Send(new ExtensionHostMsg_RequestScriptInjectionPermission(
+//       render_frame_->GetRoutingID(), host_id().id(), injector_->script_type(),
+//       run_location_, request_id_));
+// }
+
+void ScriptInjection::NotifyWillNotInject(
+    ScriptInjector::InjectFailureReason reason) {
+  complete_ = true;
+  injector_->OnWillNotInject(reason, render_frame_);
+}
+
+ScriptInjection::InjectionResult ScriptInjection::Inject(
+    ScriptsRunInfo* scripts_run_info) {
+  DCHECK(injection_host_);
+  //DCHECK(scripts_run_info);
+  DCHECK(!complete_);
+  bool should_inject_js = injector_->ShouldInjectJs(
+      run_location_, scripts_run_info->executing_scripts[host_id().id()]);
+  bool should_inject_css = injector_->ShouldInjectCss(
+      run_location_, scripts_run_info->injected_stylesheets[host_id().id()]);
+
+  // This can happen if the extension specified a script to
+  // be run in multiple rules, and the script has already run.
+  // See crbug.com/631247.
+  if (!should_inject_js && !should_inject_css) {
+    return INJECTION_FINISHED;
+  }
+
+  if (should_inject_js)
+    InjectJs(&(scripts_run_info->executing_scripts[host_id().id()]),
+             &(scripts_run_info->num_js));
+  if (should_inject_css)
+    InjectCss(&(scripts_run_info->injected_stylesheets[host_id().id()]),
+              &(scripts_run_info->num_css));
+
+  complete_ = did_inject_js_ || !should_inject_js;
+
+  if (complete_) {
+    LOG(INFO) << "---ScriptInjection::Inject complete";
+//    if (host_id().type() == HostID::EXTENSIONS)
+//      RecordContentScriptInjection(ukm_source_id_, host_id().id());
+    injector_->OnInjectionComplete(std::move(execution_result_), run_location_,
+                                   render_frame_);
+  } else {
+    LOG(INFO) << "---ScriptInjection::Inject INcomplete";
+    ++scripts_run_info->num_blocking_js;
+  }
+
+  return complete_ ? INJECTION_FINISHED : INJECTION_BLOCKED;
+}
+
+void ScriptInjection::InjectJs(std::set<std::string>* executing_scripts,
+                               size_t* num_injected_js_scripts) {
+  LOG(INFO) << "---ScriptInjection::InjectJs";
+  DCHECK(!did_inject_js_);
+  std::vector<blink::WebScriptSource> sources = injector_->GetJsSources(
+      run_location_, executing_scripts, num_injected_js_scripts);
+  DCHECK(!sources.empty());
+  int world_id = GetIsolatedWorldIdForInstance(injection_host_.get());
+  bool is_user_gesture = injector_->IsUserGesture();
+
+  std::unique_ptr<blink::WebScriptExecutionCallback> callback(
+      new TimedScriptInjectionCallback(weak_ptr_factory_.GetWeakPtr()));
+
+  base::ElapsedTimer exec_timer;
+//  if (injection_host_->id().type() == HostID::EXTENSIONS && log_activity_)
+//    DOMActivityLogger::AttachToWorld(world_id, injection_host_->id().id());
+
+  // For content scripts executing during page load, we run them asynchronously
+  // in order to reduce UI jank experienced by the user. (We don't do this for
+  // DOCUMENT_START scripts, because there's no UI to jank until after those
+  // run, so we run them as soon as we can.)
+  // Note: We could potentially also run deferred and browser-driven scripts
+  // asynchronously; however, these are rare enough that there probably isn't
+  // UI jank. If this changes, we can update this.
+  bool should_execute_asynchronously =
+      injector_->script_type() == UserScript::CONTENT_SCRIPT &&
+      (run_location_ == UserScript::DOCUMENT_END ||
+       run_location_ == UserScript::DOCUMENT_IDLE);
+  blink::WebLocalFrame::ScriptExecutionType execution_option =
+      should_execute_asynchronously
+          ? blink::WebLocalFrame::kAsynchronousBlockingOnload
+          : blink::WebLocalFrame::kSynchronous;
+
+  // render_frame_->GetWebFrame()->RequestExecuteScriptAndReturnValue(
+  //      sources.front(), is_user_gesture, callback.release());
+  render_frame_->GetWebFrame()->RequestExecuteScriptInIsolatedWorld(
+      world_id, &sources.front(), sources.size(), is_user_gesture,
+      execution_option, callback.release());
+  LOG(INFO) << "---ScriptInjection::InjectJs end " << world_id;
+}
+
+void ScriptInjection::OnJsInjectionCompleted(
+    const std::vector<v8::Local<v8::Value>>& results,
+    base::Optional<base::TimeDelta> elapsed) {
+  LOG(INFO) << "---ScriptInjection::OnJsInjectionCompleted end";
+  DCHECK(!did_inject_js_);
+
+  // if (injection_host_->id().type() == HostID::EXTENSIONS && elapsed) {
+  //   UMA_HISTOGRAM_TIMES("Extensions.InjectedScriptExecutionTime", *elapsed);
+  //   switch (run_location_) {
+  //     case UserScript::DOCUMENT_START:
+  //       UMA_HISTOGRAM_TIMES(
+  //           "Extensions.InjectedScriptExecutionTime.DocumentStart", *elapsed);
+  //       break;
+  //     case UserScript::DOCUMENT_END:
+  //       UMA_HISTOGRAM_TIMES(
+  //           "Extensions.InjectedScriptExecutionTime.DocumentEnd", *elapsed);
+  //       break;
+  //     case UserScript::DOCUMENT_IDLE:
+  //       UMA_HISTOGRAM_TIMES(
+  //           "Extensions.InjectedScriptExecutionTime.DocumentIdle", *elapsed);
+  //       break;
+  //     default:
+  //       break;
+  //   }
+  // }
+
+  bool expects_results = injector_->ExpectsResults();
+  if (expects_results) {
+    if (!results.empty() && !results[0].IsEmpty()) {
+      // Right now, we only support returning single results (per frame).
+      // It's safe to always use the main world context when converting
+      // here. V8ValueConverterImpl shouldn't actually care about the
+      // context scope, and it switches to v8::Object's creation context
+      // when encountered.
+      v8::Local<v8::Context> context =
+          render_frame_->GetWebFrame()->MainWorldScriptContext();
+      execution_result_ =
+          content::V8ValueConverter::Create()->FromV8Value(results[0], context);
+    }
+    if (!execution_result_.get())
+      execution_result_ = std::make_unique<base::Value>();
+  }
+  did_inject_js_ = true;
+//  if (host_id().type() == HostID::EXTENSIONS)
+//    RecordContentScriptInjection(ukm_source_id_, host_id().id());
+
+  // If |async_completion_callback_| is set, it means the script finished
+  // asynchronously, and we should run it.
+  if (!async_completion_callback_.is_null()) {
+    complete_ = true;
+    injector_->OnInjectionComplete(std::move(execution_result_), run_location_,
+                                   render_frame_);
+    // Warning: this object can be destroyed after this line!
+    async_completion_callback_.Run(this);
+  }
+  LOG(INFO) << "---ScriptInjection::OnJsInjectionCompleted end "<< execution_result_;
+}
+
+void ScriptInjection::InjectCss(std::set<std::string>* injected_stylesheets,
+                                size_t* num_injected_stylesheets) {
+  std::vector<blink::WebString> css_sources = injector_->GetCssSources(
+      run_location_, injected_stylesheets, num_injected_stylesheets);
+  blink::WebLocalFrame* web_frame = render_frame_->GetWebFrame();
+  // Default CSS origin is "author", but can be overridden to "user" by scripts.
+  base::Optional<CSSOrigin> css_origin = injector_->GetCssOrigin();
+  blink::WebDocument::CSSOrigin blink_css_origin =
+      css_origin && *css_origin == CSS_ORIGIN_USER
+          ? blink::WebDocument::kUserOrigin
+          : blink::WebDocument::kAuthorOrigin;
+  blink::WebStyleSheetKey style_sheet_key;
+  if (const base::Optional<std::string>& injection_key =
+          injector_->GetInjectionKey())
+    style_sheet_key = blink::WebString::FromASCII(*injection_key);
+  for (const blink::WebString& css : css_sources)
+    web_frame->GetDocument().InsertStyleSheet(css, &style_sheet_key,
+                                              blink_css_origin);
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/renderer/script_injection.h b/components/user_scripts/renderer/script_injection.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/script_injection.h
@@ -0,0 +1,160 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_SCRIPT_INJECTION_H_
+#define EXTENSIONS_RENDERER_SCRIPT_INJECTION_H_
+
+#include <stdint.h>
+
+#include <memory>
+#include <vector>
+
+#include "base/callback.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/metrics/ukm_source_id.h"
+#include "base/optional.h"
+#include "../common/user_script.h"
+#include "injection_host.h"
+#include "script_injector.h"
+
+struct HostID;
+
+namespace content {
+class RenderFrame;
+}
+
+namespace v8 {
+class Value;
+template <class T> class Local;
+}
+
+namespace user_scripts {
+struct ScriptsRunInfo;
+
+// A script wrapper which is aware of whether or not it is allowed to execute,
+// and contains the implementation to do so.
+class ScriptInjection {
+ public:
+  enum InjectionResult {
+    INJECTION_FINISHED,
+    INJECTION_BLOCKED,
+    INJECTION_WAITING
+  };
+
+  using CompletionCallback = base::Callback<void(ScriptInjection*)>;
+
+  // Return the id of the injection host associated with the given world.
+  static std::string GetHostIdForIsolatedWorld(int world_id);
+
+  // Remove the isolated world associated with the given injection host.
+  static void RemoveIsolatedWorld(const std::string& host_id);
+
+  ScriptInjection(std::unique_ptr<ScriptInjector> injector,
+                  content::RenderFrame* render_frame,
+                  std::unique_ptr<const InjectionHost> injection_host,
+                  UserScript::RunLocation run_location,
+                  bool log_activity);
+  ~ScriptInjection();
+
+  // Try to inject the script at the |current_location|. This returns
+  // INJECTION_FINISHED if injection has injected or will never inject, returns
+  // INJECTION_BLOCKED if injection is running asynchronously and has not
+  // finished yet, returns INJECTION_WAITING if injections is delayed (either
+  // for permission purposes or because |current_location| is not the designated
+  // |run_location_|).
+  // If INJECTION_BLOCKED is returned, |async_completion_callback| will be
+  // called upon completion.
+  InjectionResult TryToInject(
+      UserScript::RunLocation current_location,
+      ScriptsRunInfo* scripts_run_info,
+      const CompletionCallback& async_completion_callback);
+
+  // Called when permission for the given injection has been granted.
+  // Returns INJECTION_FINISHED if injection has injected or will never inject,
+  // returns INJECTION_BLOCKED if injection is ran asynchronously.
+  InjectionResult OnPermissionGranted(ScriptsRunInfo* scripts_run_info);
+
+  // Resets the pointer of the injection host when the host is gone.
+  void OnHostRemoved();
+
+  void invalidate_render_frame() { render_frame_ = nullptr; }
+
+  // Accessors.
+  content::RenderFrame* render_frame() const { return render_frame_; }
+  const HostID& host_id() const { return injection_host_->id(); }
+  int64_t request_id() const { return request_id_; }
+
+  // Called when JS injection for the given frame has been completed or
+  // cancelled.
+  void OnJsInjectionCompleted(const std::vector<v8::Local<v8::Value>>& results,
+                              base::Optional<base::TimeDelta> elapsed);
+
+ private:
+  class FrameWatcher;
+
+  // Sends a message to the browser to request permission to inject.
+  void RequestPermissionFromBrowser();
+
+  // Injects the script. Returns INJECTION_FINISHED if injection has finished,
+  // otherwise INJECTION_BLOCKED.
+  InjectionResult Inject(ScriptsRunInfo* scripts_run_info);
+
+  // Inject any JS scripts into the frame for the injection.
+  void InjectJs(std::set<std::string>* executing_scripts,
+                size_t* num_injected_js_scripts);
+
+  // Inject any CSS source into the frame for the injection.
+  void InjectCss(std::set<std::string>* injected_stylesheets,
+                 size_t* num_injected_stylesheets);
+
+  // Notify that we will not inject, and mark it as acknowledged.
+  void NotifyWillNotInject(ScriptInjector::InjectFailureReason reason);
+
+  // The injector for this injection.
+  std::unique_ptr<ScriptInjector> injector_;
+
+  // The RenderFrame into which this should inject the script.
+  content::RenderFrame* render_frame_;
+
+  // The associated injection host.
+  std::unique_ptr<const InjectionHost> injection_host_;
+
+  // The location in the document load at which we inject the script.
+  UserScript::RunLocation run_location_;
+
+  // This injection's request id. This will be -1 unless the injection is
+  // currently waiting on permission.
+  int64_t request_id_;
+
+  // Identifies the frame we're injecting into.
+  base::UkmSourceId ukm_source_id_;
+
+  // Whether or not the injection is complete, either via injecting the script
+  // or because it will never complete.
+  bool complete_;
+
+  // Whether or not the injection successfully injected JS.
+  bool did_inject_js_;
+
+  // Whether or not we should log dom activity for this injection.
+  bool log_activity_;
+
+  // Results storage.
+  std::unique_ptr<base::Value> execution_result_;
+
+  // The callback to run upon completing asynchronously.
+  CompletionCallback async_completion_callback_;
+
+  // A helper class to hold the render frame and watch for its deletion.
+  std::unique_ptr<FrameWatcher> frame_watcher_;
+
+  base::WeakPtrFactory<ScriptInjection> weak_ptr_factory_{this};
+
+  DISALLOW_COPY_AND_ASSIGN(ScriptInjection);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_SCRIPT_INJECTION_H_
diff --git a/components/user_scripts/renderer/script_injection_callback.cc b/components/user_scripts/renderer/script_injection_callback.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/script_injection_callback.cc
@@ -0,0 +1,26 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "script_injection_callback.h"
+
+#include "third_party/blink/public/platform/web_vector.h"
+
+namespace user_scripts {
+
+ScriptInjectionCallback::ScriptInjectionCallback(
+    const CompleteCallback& injection_completed_callback)
+    : injection_completed_callback_(injection_completed_callback) {
+}
+
+ScriptInjectionCallback::~ScriptInjectionCallback() {
+}
+
+void ScriptInjectionCallback::Completed(
+    const blink::WebVector<v8::Local<v8::Value>>& result) {
+  std::vector<v8::Local<v8::Value>> stl_result(result.begin(), result.end());
+  injection_completed_callback_.Run(stl_result);
+  delete this;
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/renderer/script_injection_callback.h b/components/user_scripts/renderer/script_injection_callback.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/script_injection_callback.h
@@ -0,0 +1,38 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_SCRIPT_INJECTION_CALLBACK_H_
+#define EXTENSIONS_RENDERER_SCRIPT_INJECTION_CALLBACK_H_
+
+#include <vector>
+
+#include "base/callback.h"
+#include "base/macros.h"
+#include "third_party/blink/public/web/web_script_execution_callback.h"
+#include "v8/include/v8.h"
+
+namespace user_scripts {
+
+// A wrapper around a callback to notify a script injection when injection
+// completes.
+// This class manages its own lifetime.
+class ScriptInjectionCallback : public blink::WebScriptExecutionCallback {
+ public:
+  using CompleteCallback =
+      base::Callback<void(const std::vector<v8::Local<v8::Value>>& result)>;
+
+  ScriptInjectionCallback(const CompleteCallback& injection_completed_callback);
+  ~ScriptInjectionCallback() override;
+
+  void Completed(const blink::WebVector<v8::Local<v8::Value>>& result) override;
+
+ private:
+  CompleteCallback injection_completed_callback_;
+
+  DISALLOW_COPY_AND_ASSIGN(ScriptInjectionCallback);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_SCRIPT_INJECTION_CALLBACK_H_
diff --git a/components/user_scripts/renderer/script_injection_manager.cc b/components/user_scripts/renderer/script_injection_manager.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/script_injection_manager.cc
@@ -0,0 +1,550 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "script_injection_manager.h"
+
+#include <memory>
+#include <utility>
+
+#include "base/auto_reset.h"
+#include "base/bind.h"
+#include "base/feature_list.h"
+#include "base/memory/weak_ptr.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "base/values.h"
+#include "base/logging.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/renderer/render_frame_observer.h"
+#include "content/public/renderer/render_thread.h"
+//#include "../common/extension.h"
+//#include "../common/extension_features.h"
+//#include "../common/extension_messages.h"
+//#include "../common/extension_set.h"
+#include "extension_frame_helper.h"
+//#include "extension_injection_host.h"
+#include "../common/extension_id.h"
+//#include "programmatic_script_injector.h"
+//#include "renderer_extension_registry.h"
+#include "../common/host_id.h"
+#include "script_injection.h"
+#include "scripts_run_info.h"
+#include "web_ui_injection_host.h"
+#include "ipc/ipc_message_macros.h"
+#include "third_party/blink/public/platform/web_url_error.h"
+#include "third_party/blink/public/web/web_document.h"
+#include "third_party/blink/public/web/web_frame.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "third_party/blink/public/web/web_view.h"
+#include "url/gurl.h"
+
+namespace user_scripts {
+
+namespace {
+
+// The length of time to wait after the DOM is complete to try and run user
+// scripts.
+const int kScriptIdleTimeoutInMs = 200;
+
+// Returns the RunLocation that follows |run_location|.
+UserScript::RunLocation NextRunLocation(UserScript::RunLocation run_location) {
+  switch (run_location) {
+    case UserScript::DOCUMENT_START:
+      return UserScript::DOCUMENT_END;
+    case UserScript::DOCUMENT_END:
+      return UserScript::DOCUMENT_IDLE;
+    case UserScript::DOCUMENT_IDLE:
+      return UserScript::RUN_LOCATION_LAST;
+    case UserScript::UNDEFINED:
+    case UserScript::RUN_DEFERRED:
+    case UserScript::BROWSER_DRIVEN:
+    case UserScript::RUN_LOCATION_LAST:
+      break;
+  }
+  NOTREACHED();
+  return UserScript::RUN_LOCATION_LAST;
+}
+
+}  // namespace
+
+class ScriptInjectionManager::RFOHelper : public content::RenderFrameObserver {
+ public:
+  RFOHelper(content::RenderFrame* render_frame,
+            ScriptInjectionManager* manager);
+  ~RFOHelper() override;
+
+ private:
+  // RenderFrameObserver implementation.
+  //bool OnMessageReceived(const IPC::Message& message) override;
+  void DidCreateNewDocument() override;
+  void DidCreateDocumentElement() override;
+  void DidFailProvisionalLoad() override;
+  void DidFinishDocumentLoad() override;
+  void WillDetach() override;
+  void OnDestruct() override;
+  void OnStop() override;
+
+  //virtual void OnExecuteCode(/*const ExtensionMsg_ExecuteCode_Params& params*/);
+  // virtual void OnExecuteDeclarativeScript(int tab_id,
+  //                                         const ExtensionId& extension_id,
+  //                                         int script_id,
+  //                                         const GURL& url);
+  //virtual void OnPermitScriptInjection(int64_t request_id);
+
+  // Tells the ScriptInjectionManager to run tasks associated with
+  // document_idle.
+  void RunIdle();
+
+  void StartInjectScripts(UserScript::RunLocation run_location);
+
+  // Indicate that the frame is no longer valid because it is starting
+  // a new load or closing.
+  void InvalidateAndResetFrame(bool force_reset);
+
+  // The owning ScriptInjectionManager.
+  ScriptInjectionManager* manager_;
+
+  bool should_run_idle_;
+
+  base::WeakPtrFactory<RFOHelper> weak_factory_{this};
+};
+
+ScriptInjectionManager::RFOHelper::RFOHelper(content::RenderFrame* render_frame,
+                                             ScriptInjectionManager* manager)
+    : content::RenderFrameObserver(render_frame),
+      manager_(manager),
+      should_run_idle_(true) {}
+
+ScriptInjectionManager::RFOHelper::~RFOHelper() {
+}
+
+// bool ScriptInjectionManager::RFOHelper::OnMessageReceived(
+//     const IPC::Message& message) {
+//   bool handled = true;
+//  IPC_BEGIN_MESSAGE_MAP(ScriptInjectionManager::RFOHelper, message)
+//    IPC_MESSAGE_HANDLER(ExtensionMsg_ExecuteCode, OnExecuteCode)
+//    IPC_MESSAGE_HANDLER(ExtensionMsg_PermitScriptInjection,
+//                        OnPermitScriptInjection)
+//    IPC_MESSAGE_HANDLER(ExtensionMsg_ExecuteDeclarativeScript,
+//                        OnExecuteDeclarativeScript)
+//    IPC_MESSAGE_UNHANDLED(handled = false)
+//  IPC_END_MESSAGE_MAP()
+//   return handled;
+// }
+
+void ScriptInjectionManager::RFOHelper::DidCreateNewDocument() {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::DidCreateNewDocument";
+
+  // A new document is going to be shown, so invalidate the old document state.
+  // Don't force-reset the frame, because it is possible that a script injection
+  // was scheduled before the page was loaded, e.g. by navigating to a
+  // javascript: URL before the page has loaded.
+  constexpr bool kForceReset = false;
+  InvalidateAndResetFrame(kForceReset);
+
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::DidCreateNewDocument exit";
+}
+
+void ScriptInjectionManager::RFOHelper::DidCreateDocumentElement() {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::DidCreateDocumentElement";
+
+  ExtensionFrameHelper::Get(render_frame())
+      ->ScheduleAtDocumentStart(
+          base::Bind(&ScriptInjectionManager::RFOHelper::StartInjectScripts,
+                     weak_factory_.GetWeakPtr(), UserScript::DOCUMENT_START));
+
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::DidCreateDocumentElement exit";
+}
+
+void ScriptInjectionManager::RFOHelper::DidFailProvisionalLoad() {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::DidFailProvisionalLoad";
+  auto it = manager_->frame_statuses_.find(render_frame());
+  if (it != manager_->frame_statuses_.end() &&
+      it->second == UserScript::DOCUMENT_START) {
+    // Since the provisional load failed, the frame stays at its previous loaded
+    // state and origin (or the parent's origin for new/about:blank frames).
+    // Reset the frame to DOCUMENT_IDLE in order to reflect that the frame is
+    // done loading, and avoid any deadlock in the system.
+    //
+    // We skip injection of DOCUMENT_END and DOCUMENT_IDLE scripts, because the
+    // injections closely follow the DOMContentLoaded (and onload) events, which
+    // are not triggered after a failed provisional load.
+    // This assumption is verified in the checkDOMContentLoadedEvent subtest of
+    // ExecuteScriptApiTest.FrameWithHttp204 (browser_tests).
+    constexpr bool kForceReset = true;
+    InvalidateAndResetFrame(kForceReset);
+    should_run_idle_ = false;
+    manager_->frame_statuses_[render_frame()] = UserScript::DOCUMENT_IDLE;
+  }
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::DidFailProvisionalLoad exit";
+}
+
+void ScriptInjectionManager::RFOHelper::DidFinishDocumentLoad() {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::DidFinishDocumentLoad";
+  DCHECK(content::RenderThread::Get());
+  ExtensionFrameHelper::Get(render_frame())
+      ->ScheduleAtDocumentEnd(
+          base::Bind(&ScriptInjectionManager::RFOHelper::StartInjectScripts,
+                     weak_factory_.GetWeakPtr(), UserScript::DOCUMENT_END));
+
+  // We try to run idle in two places: a delayed task here and in response to
+  // ContentRendererClient::RunScriptsAtDocumentIdle(). DidFinishDocumentLoad()
+  // corresponds to completing the document's load, whereas
+  // RunScriptsAtDocumentIdle() corresponds to completing the document and all
+  // subresources' load (but before the window.onload event). We don't want to
+  // hold up script injection for a particularly slow subresource, so we set a
+  // delayed task from here - but if we finish everything before that point
+  // (i.e., RunScriptsAtDocumentIdle() is triggered), then there's no reason to
+  // keep waiting.
+  render_frame()
+      ->GetTaskRunner(blink::TaskType::kInternalDefault)
+      ->PostDelayedTask(
+          FROM_HERE,
+          base::BindOnce(&ScriptInjectionManager::RFOHelper::RunIdle,
+                         weak_factory_.GetWeakPtr()),
+          base::TimeDelta::FromMilliseconds(kScriptIdleTimeoutInMs));
+
+  ExtensionFrameHelper::Get(render_frame())
+      ->ScheduleAtDocumentIdle(
+          base::Bind(&ScriptInjectionManager::RFOHelper::RunIdle,
+                     weak_factory_.GetWeakPtr()));
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::DidFinishDocumentLoad exit";
+}
+
+void ScriptInjectionManager::RFOHelper::WillDetach() {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::WillDetach";
+  // The frame is closing - invalidate.
+  constexpr bool kForceReset = true;
+  InvalidateAndResetFrame(kForceReset);
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::WillDetach exit";
+}
+
+void ScriptInjectionManager::RFOHelper::OnDestruct() {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::OnDestruct";
+  manager_->RemoveObserver(this);
+}
+
+void ScriptInjectionManager::RFOHelper::OnStop() {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::OnStop";
+  // If the navigation request fails (e.g. 204/205/downloads), notify the
+  // extension to avoid keeping the frame in a START state indefinitely which
+  // leads to deadlocks.
+  DidFailProvisionalLoad();
+}
+
+//void ScriptInjectionManager::RFOHelper::OnExecuteCode(
+//    /*const ExtensionMsg_ExecuteCode_Params& params*/) {
+//  manager_->HandleExecuteCode(/*params,*/ render_frame());
+//}
+
+// void ScriptInjectionManager::RFOHelper::OnExecuteDeclarativeScript(
+//     int tab_id,
+//     const ExtensionId& extension_id,
+//     int script_id,
+//     const GURL& url) {
+//   // TODO(markdittmer): URL-checking isn't the best security measure.
+//   // Begin script injection workflow only if the current URL is identical to
+//   // the one that matched declarative conditions in the browser.
+//   if (GURL(render_frame()->GetWebFrame()->GetDocument().Url()) == url) {
+//     manager_->HandleExecuteDeclarativeScript(render_frame(),
+//                                              tab_id,
+//                                              extension_id,
+//                                              script_id,
+//                                              url);
+//   }
+// }
+
+// void ScriptInjectionManager::RFOHelper::OnPermitScriptInjection(
+//     int64_t request_id) {
+//   manager_->HandlePermitScriptInjection(request_id);
+// }
+
+void ScriptInjectionManager::RFOHelper::RunIdle() {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::RunIdle";
+  // Only notify the manager if the frame hasn't already had idle run since the
+  // task to RunIdle() was posted.
+  if (should_run_idle_) {
+    should_run_idle_ = false;
+    manager_->StartInjectScripts(render_frame(), UserScript::DOCUMENT_IDLE);
+  }
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::RunIdle exit";
+}
+
+void ScriptInjectionManager::RFOHelper::StartInjectScripts(
+    UserScript::RunLocation run_location) {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::StartInjectScripts";
+  manager_->StartInjectScripts(render_frame(), run_location);
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::StartInjectScripts exit";
+}
+
+void ScriptInjectionManager::RFOHelper::InvalidateAndResetFrame(
+    bool force_reset) {
+  // Invalidate any pending idle injections, and reset the frame inject on idle.
+  weak_factory_.InvalidateWeakPtrs();
+  // We reset to inject on idle, because the frame can be reused (in the case of
+  // navigation).
+  should_run_idle_ = true;
+
+  // Reset the frame if either |force_reset| is true, or if the manager is
+  // keeping track of the state of the frame (in which case we need to clean it
+  // up).
+  if (force_reset || manager_->frame_statuses_.count(render_frame()) != 0)
+    manager_->InvalidateForFrame(render_frame());
+}
+
+ScriptInjectionManager::ScriptInjectionManager(
+    UserScriptSetManager* user_script_set_manager)
+    : user_script_set_manager_(user_script_set_manager),
+      user_script_set_manager_observer_(this) {
+  user_script_set_manager_observer_.Add(user_script_set_manager_);
+  LOG(INFO) << "---ScriptInjectionManager::ScriptInjectionManager";
+}
+
+ScriptInjectionManager::~ScriptInjectionManager() {
+  for (const auto& injection : pending_injections_)
+    injection->invalidate_render_frame();
+  for (const auto& injection : running_injections_)
+    injection->invalidate_render_frame();
+}
+
+void ScriptInjectionManager::OnRenderFrameCreated(
+    content::RenderFrame* render_frame) {
+  rfo_helpers_.push_back(std::make_unique<RFOHelper>(render_frame, this));
+  LOG(INFO) << "---ScriptInjectionManager::OnRenderFrameCreated";
+}
+
+// void ScriptInjectionManager::OnExtensionUnloaded(
+//     const std::string& extension_id) {
+//   for (auto iter = pending_injections_.begin();
+//       iter != pending_injections_.end();) {
+//     if ((*iter)->host_id().id() == extension_id) {
+//       (*iter)->OnHostRemoved();
+//       iter = pending_injections_.erase(iter);
+//     } else {
+//       ++iter;
+//     }
+//   }
+// }
+
+void ScriptInjectionManager::OnInjectionFinished(
+    ScriptInjection* injection) {
+  auto iter =
+      std::find_if(running_injections_.begin(), running_injections_.end(),
+                   [injection](const std::unique_ptr<ScriptInjection>& mode) {
+                     return injection == mode.get();
+                   });
+  if (iter != running_injections_.end())
+    running_injections_.erase(iter);
+}
+
+void ScriptInjectionManager::OnUserScriptsUpdated(
+    const std::set<HostID>& changed_hosts) {
+  for (auto iter = pending_injections_.begin();
+       iter != pending_injections_.end();) {
+    if (changed_hosts.count((*iter)->host_id()) > 0)
+      iter = pending_injections_.erase(iter);
+    else
+      ++iter;
+  }
+}
+
+void ScriptInjectionManager::RemoveObserver(RFOHelper* helper) {
+  for (auto iter = rfo_helpers_.begin(); iter != rfo_helpers_.end(); ++iter) {
+    if (iter->get() == helper) {
+      rfo_helpers_.erase(iter);
+      break;
+    }
+  }
+}
+
+void ScriptInjectionManager::InvalidateForFrame(content::RenderFrame* frame) {
+  // If the frame invalidated is the frame being injected into, we need to
+  // note it.
+  active_injection_frames_.erase(frame);
+
+  for (auto iter = pending_injections_.begin();
+       iter != pending_injections_.end();) {
+    if ((*iter)->render_frame() == frame)
+      iter = pending_injections_.erase(iter);
+    else
+      ++iter;
+  }
+
+  frame_statuses_.erase(frame);
+}
+
+void ScriptInjectionManager::StartInjectScripts(
+    content::RenderFrame* frame,
+    UserScript::RunLocation run_location) {
+  auto iter = frame_statuses_.find(frame);
+  // We also don't execute if we detect that the run location is somehow out of
+  // order. This can happen if:
+  // - The first run location reported for the frame isn't DOCUMENT_START, or
+  // - The run location reported doesn't immediately follow the previous
+  //   reported run location.
+  // We don't want to run because extensions may have requirements that scripts
+  // running in an earlier run location have run by the time a later script
+  // runs. Better to just not run.
+  // Note that we check run_location > NextRunLocation() in the second clause
+  // (as opposed to !=) because earlier signals (like DidCreateDocumentElement)
+  // can happen multiple times, so we can receive earlier/equal run locations.
+  if ((iter == frame_statuses_.end() &&
+           run_location != UserScript::DOCUMENT_START) ||
+      (iter != frame_statuses_.end() &&
+           run_location > NextRunLocation(iter->second))) {
+    // We also invalidate the frame, because the run order of pending injections
+    // may also be bad.
+    InvalidateForFrame(frame);
+    return;
+  } else if (iter != frame_statuses_.end() && iter->second >= run_location) {
+    // Certain run location signals (like DidCreateDocumentElement) can happen
+    // multiple times. Ignore the subsequent signals.
+    return;
+  }
+
+  // Otherwise, all is right in the world, and we can get on with the
+  // injections!
+  frame_statuses_[frame] = run_location;
+  InjectScripts(frame, run_location);
+}
+
+void ScriptInjectionManager::InjectScripts(
+    content::RenderFrame* frame,
+    UserScript::RunLocation run_location) {
+  LOG(INFO) << "---ScriptInjectionManager::InjectScripts";
+
+  // Find any injections that want to run on the given frame.
+  ScriptInjectionVector frame_injections;
+  for (auto iter = pending_injections_.begin();
+       iter != pending_injections_.end();) {
+    if ((*iter)->render_frame() == frame) {
+      frame_injections.push_back(std::move(*iter));
+      iter = pending_injections_.erase(iter);
+    } else {
+      ++iter;
+    }
+  }
+
+  // Add any injections for user scripts.
+  int tab_id = ExtensionFrameHelper::Get(frame)->tab_id();
+  user_script_set_manager_->GetAllInjections(&frame_injections, frame, tab_id,
+                                             run_location);
+
+  // Note that we are running in |frame|.
+  active_injection_frames_.insert(frame);
+
+  ScriptsRunInfo scripts_run_info(frame, run_location);
+
+  for (auto iter = frame_injections.begin(); iter != frame_injections.end();) {
+    // It's possible for thScriptsRunInfoe frame to be invalidated in the course of injection
+    // (if a script removes its own frame, for example). If this happens, abort.
+    if (!active_injection_frames_.count(frame))
+      break;
+    std::unique_ptr<ScriptInjection> injection(std::move(*iter));
+    iter = frame_injections.erase(iter);
+    TryToInject(std::move(injection), run_location, &scripts_run_info);
+  }
+
+  // We are done running in the frame.
+  active_injection_frames_.erase(frame);
+
+  scripts_run_info.LogRun(activity_logging_enabled_);
+}
+
+void ScriptInjectionManager::TryToInject(
+    std::unique_ptr<ScriptInjection> injection,
+    UserScript::RunLocation run_location,
+    ScriptsRunInfo* scripts_run_info) {
+  // Try to inject the script. If the injection is waiting (i.e., for
+  // permission), add it to the list of pending injections. If the injection
+  // has blocked, add it to the list of running injections.
+  // The Unretained below is safe because this object owns all the
+  // ScriptInjections, so is guaranteed to outlive them.
+  switch (injection->TryToInject(
+      run_location, scripts_run_info,
+      base::Bind(&ScriptInjectionManager::OnInjectionFinished,
+                 base::Unretained(this)))) {
+    case ScriptInjection::INJECTION_WAITING:
+      pending_injections_.push_back(std::move(injection));
+      break;
+    case ScriptInjection::INJECTION_BLOCKED:
+      running_injections_.push_back(std::move(injection));
+      break;
+    case ScriptInjection::INJECTION_FINISHED:
+      break;
+  }
+}
+
+//void ScriptInjectionManager::HandleExecuteCode(
+//    //const ExtensionMsg_ExecuteCode_Params& params,
+//    content::RenderFrame* render_frame) {
+//  std::unique_ptr<const InjectionHost> injection_host;
+  //if (params.host_id.type() == HostID::EXTENSIONS) {
+  //  injection_host = ExtensionInjectionHost::Create(params.host_id.id());
+  //  if (!injection_host)
+  //    return;
+  //} else if (params.host_id.type() == HostID::WEBUI) {
+//    injection_host.reset(
+//        new WebUIInjectionHost(params.host_id));
+  //}
+
+//  std::unique_ptr<ScriptInjection> injection(new ScriptInjection(
+//      std::unique_ptr<ScriptInjector>(new ProgrammaticScriptInjector(params)),
+//      render_frame, std::move(injection_host), params.run_at,
+//      activity_logging_enabled_));
+
+//  FrameStatusMap::const_iterator iter = frame_statuses_.find(render_frame);
+//  UserScript::RunLocation run_location =
+//      iter == frame_statuses_.end() ? UserScript::UNDEFINED : iter->second;
+
+//  ScriptsRunInfo scripts_run_info(render_frame, run_location);
+//  TryToInject(std::move(injection), run_location, &scripts_run_info);
+//}
+
+// void ScriptInjectionManager::HandleExecuteDeclarativeScript(
+//     content::RenderFrame* render_frame,
+//     int tab_id,
+//     const ExtensionId& extension_id,
+//     int script_id,
+//     const GURL& url) {
+//   std::unique_ptr<ScriptInjection> injection =
+//       user_script_set_manager_->GetInjectionForDeclarativeScript(
+//           script_id, render_frame, tab_id, url, extension_id);
+//   if (injection.get()) {
+//     ScriptsRunInfo scripts_run_info(render_frame, UserScript::BROWSER_DRIVEN);
+//     // TODO(markdittmer): Use return value of TryToInject for error handling.
+//     TryToInject(std::move(injection), UserScript::BROWSER_DRIVEN,
+//                 &scripts_run_info);
+
+//     scripts_run_info.LogRun(activity_logging_enabled_);
+//   }
+// }
+
+// void ScriptInjectionManager::HandlePermitScriptInjection(int64_t request_id) {
+//   auto iter = pending_injections_.begin();
+//   for (; iter != pending_injections_.end(); ++iter) {
+//     if ((*iter)->request_id() == request_id) {
+//       DCHECK((*iter)->host_id().type() == HostID::EXTENSIONS);
+//       break;
+//     }
+//   }
+//   if (iter == pending_injections_.end())
+//     return;
+
+//   // At this point, because the request is present in pending_injections_, we
+//   // know that this is the same page that issued the request (otherwise,
+//   // RFOHelper::InvalidateAndResetFrame would have caused it to be cleared out).
+
+//   std::unique_ptr<ScriptInjection> injection(std::move(*iter));
+//   pending_injections_.erase(iter);
+
+//   ScriptsRunInfo scripts_run_info(injection->render_frame(),
+//                                   UserScript::RUN_DEFERRED);
+//   ScriptInjection::InjectionResult res = injection->OnPermissionGranted(
+//       &scripts_run_info);
+//   if (res == ScriptInjection::INJECTION_BLOCKED)
+//     running_injections_.push_back(std::move(injection));
+//   scripts_run_info.LogRun(activity_logging_enabled_);
+// }
+
+}  // namespace extensions
diff --git a/components/user_scripts/renderer/script_injection_manager.h b/components/user_scripts/renderer/script_injection_manager.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/script_injection_manager.h
@@ -0,0 +1,119 @@
+#include <stdint.h>
+
+#include <map>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/callback.h"
+#include "base/macros.h"
+#include "base/scoped_observer.h"
+#include "../common/user_script.h"
+#include "../common/extension_id.h"
+#include "script_injection.h"
+#include "user_script_set_manager.h"
+
+//struct ExtensionMsg_ExecuteCode_Params;
+
+namespace user_scripts {
+
+// The ScriptInjectionManager manages extensions injecting scripts into frames
+// via both content/user scripts and tabs.executeScript(). It is responsible for
+// maintaining any pending injections awaiting permission or the appropriate
+// load point, and injecting them when ready.
+class ScriptInjectionManager : public UserScriptSetManager::Observer {
+ public:
+  explicit ScriptInjectionManager(
+      UserScriptSetManager* user_script_set_manager);
+  virtual ~ScriptInjectionManager();
+
+  // Notifies that a new render view has been created.
+  void OnRenderFrameCreated(content::RenderFrame* render_frame);
+
+  // Removes pending injections of the unloaded extension.
+  //void OnExtensionUnloaded(const std::string& extension_id);
+
+  void set_activity_logging_enabled(bool enabled) {
+    activity_logging_enabled_ = enabled;
+  }
+
+ private:
+  // A RenderFrameObserver implementation which watches the various render
+  // frames in order to notify the ScriptInjectionManager of different
+  // document load states and IPCs.
+  class RFOHelper;
+
+  using FrameStatusMap =
+      std::map<content::RenderFrame*, UserScript::RunLocation>;
+
+  using ScriptInjectionVector = std::vector<std::unique_ptr<ScriptInjection>>;
+
+  // Notifies that an injection has been finished.
+  void OnInjectionFinished(ScriptInjection* injection);
+
+  // UserScriptSetManager::Observer implementation.
+  void OnUserScriptsUpdated(const std::set<HostID>& changed_hosts) override;
+
+  // Notifies that an RFOHelper should be removed.
+  void RemoveObserver(RFOHelper* helper);
+
+  // Invalidate any pending tasks associated with |frame|.
+  void InvalidateForFrame(content::RenderFrame* frame);
+
+  // Starts the process to inject appropriate scripts into |frame|.
+  void StartInjectScripts(content::RenderFrame* frame,
+                          UserScript::RunLocation run_location);
+
+  // Actually injects the scripts into |frame|.
+  void InjectScripts(content::RenderFrame* frame,
+                     UserScript::RunLocation run_location);
+
+  // Try to inject and store injection if it has not finished.
+  void TryToInject(std::unique_ptr<ScriptInjection> injection,
+                   UserScript::RunLocation run_location,
+                   ScriptsRunInfo* scripts_run_info);
+
+  // Handle the ExecuteCode extension message.
+  //void HandleExecuteCode(/*const ExtensionMsg_ExecuteCode_Params& params,*/
+  //                       content::RenderFrame* render_frame);
+
+  // Handle the ExecuteDeclarativeScript extension message.
+  // void HandleExecuteDeclarativeScript(content::RenderFrame* web_frame,
+  //                                     int tab_id,
+  //                                     const ExtensionId& extension_id,
+  //                                     int script_id,
+  //                                     const GURL& url);
+
+  // Handle the GrantInjectionPermission extension message.
+  //void HandlePermitScriptInjection(int64_t request_id);
+
+  // The map of active web frames to their corresponding statuses. The
+  // RunLocation of the frame corresponds to the last location that has ran.
+  FrameStatusMap frame_statuses_;
+
+  // The frames currently being injected into, so long as that frame is valid.
+  std::set<content::RenderFrame*> active_injection_frames_;
+
+  // The collection of RFOHelpers.
+  std::vector<std::unique_ptr<RFOHelper>> rfo_helpers_;
+
+  // The set of UserScripts associated with extensions. Owned by the Dispatcher.
+  UserScriptSetManager* user_script_set_manager_;
+
+  // Pending injections which are waiting for either the proper run location or
+  // user consent.
+  ScriptInjectionVector pending_injections_;
+
+  // Running injections which are waiting for async callbacks from blink.
+  ScriptInjectionVector running_injections_;
+
+  // Whether or not dom activity should be logged for scripts injected.
+  bool activity_logging_enabled_ = false;
+
+  ScopedObserver<UserScriptSetManager, UserScriptSetManager::Observer>
+      user_script_set_manager_observer_;
+
+  DISALLOW_COPY_AND_ASSIGN(ScriptInjectionManager);
+};
+
+}
diff --git a/components/user_scripts/renderer/script_injector.h b/components/user_scripts/renderer/script_injector.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/script_injector.h
@@ -0,0 +1,103 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_SCRIPT_INJECTOR_H_
+#define EXTENSIONS_RENDERER_SCRIPT_INJECTOR_H_
+
+#include <memory>
+#include <vector>
+
+#include "../common/constants.h"
+//#include "../common/permissions/permissions_data.h"
+#include "../common/user_script.h"
+#include "third_party/blink/public/web/web_script_source.h"
+
+class InjectionHost;
+
+namespace blink {
+class WebLocalFrame;
+}
+
+namespace user_scripts {
+
+// The pseudo-delegate class for a ScriptInjection that provides all necessary
+// information about how to inject the script, including what code to inject and
+// when (run location), but without any injection logic.
+class ScriptInjector {
+ public:
+  // The possible reasons for not injecting the script.
+  enum InjectFailureReason {
+    EXTENSION_REMOVED,  // The extension was removed before injection.
+    NOT_ALLOWED,        // The script is not allowed to inject.
+    WONT_INJECT         // The injection won't inject because the user rejected
+                        // (or just did not accept) the injection.
+  };
+
+  virtual ~ScriptInjector() {}
+
+  // Returns the script type of this particular injection.
+  virtual UserScript::InjectionType script_type() const = 0;
+
+  // Returns true if the script is running inside a user gesture.
+  virtual bool IsUserGesture() const = 0;
+
+  // Returns the CSS origin of this injection.
+  virtual base::Optional<CSSOrigin> GetCssOrigin() const = 0;
+
+  // Returns the key for this injection, if it's a CSS injection.
+  virtual const base::Optional<std::string> GetInjectionKey() const = 0;
+
+  // Returns true if the script expects results.
+  virtual bool ExpectsResults() const = 0;
+
+  // Returns true if the script should inject JS source at the given
+  // |run_location|.
+  virtual bool ShouldInjectJs(
+      UserScript::RunLocation run_location,
+      const std::set<std::string>& executing_scripts) const = 0;
+
+  // Returns true if the script should inject CSS at the given |run_location|.
+  virtual bool ShouldInjectCss(
+      UserScript::RunLocation run_location,
+      const std::set<std::string>& injected_stylesheets) const = 0;
+
+  // Returns true if the script should execute on the given |frame|.
+//  virtual PermissionsData::PageAccess CanExecuteOnFrame(
+//      const InjectionHost* injection_host,
+//      blink::WebLocalFrame* web_frame,
+//      int tab_id) = 0;
+
+  // Returns the javascript sources to inject at the given |run_location|.
+  // Only called if ShouldInjectJs() is true.
+  virtual std::vector<blink::WebScriptSource> GetJsSources(
+      UserScript::RunLocation run_location,
+      std::set<std::string>* executing_scripts,
+      size_t* num_injected_js_scripts) const = 0;
+
+  // Returns the css to inject at the given |run_location|.
+  // Only called if ShouldInjectCss() is true.
+  virtual std::vector<blink::WebString> GetCssSources(
+      UserScript::RunLocation run_location,
+      std::set<std::string>* injected_stylesheets,
+      size_t* num_injected_stylesheets) const = 0;
+
+  // Notifies the script that injection has completed, with a possibly-populated
+  // list of results (depending on whether or not ExpectsResults() was true).
+  // |render_frame| contains the render frame, or null if the frame was
+  // invalidated.
+  virtual void OnInjectionComplete(
+      std::unique_ptr<base::Value> execution_result,
+      UserScript::RunLocation run_location,
+      content::RenderFrame* render_frame) = 0;
+
+  // Notifies the script that injection will never occur.
+  // |render_frame| contains the render frame, or null if the frame was
+  // invalidated.
+  virtual void OnWillNotInject(InjectFailureReason reason,
+                               content::RenderFrame* render_frame) = 0;
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_SCRIPT_INJECTOR_H_
diff --git a/components/user_scripts/renderer/scripts_run_info.cc b/components/user_scripts/renderer/scripts_run_info.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/scripts_run_info.cc
@@ -0,0 +1,78 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "scripts_run_info.h"
+
+#include "base/metrics/histogram_macros.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/renderer/render_thread.h"
+//#include "extensions/common/extension_messages.h"
+#include "script_context.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+
+namespace user_scripts {
+
+ScriptsRunInfo::ScriptsRunInfo(content::RenderFrame* render_frame,
+                               UserScript::RunLocation location)
+    : num_css(0u),
+      num_js(0u),
+      num_blocking_js(0u),
+      routing_id_(render_frame->GetRoutingID()),
+      run_location_(location),
+      frame_url_(ScriptContext::GetDocumentLoaderURLForFrame(
+          render_frame->GetWebFrame())) {}
+
+ScriptsRunInfo::~ScriptsRunInfo() {
+}
+
+void ScriptsRunInfo::LogRun(bool send_script_activity) {
+  // // Notify the browser if any extensions are now executing scripts.
+  // if (!executing_scripts.empty() && send_script_activity) {
+  //   content::RenderThread::Get()->Send(
+  //       new ExtensionHostMsg_ContentScriptsExecuting(
+  //           routing_id_, executing_scripts, frame_url_));
+  // }
+
+  // base::TimeDelta elapsed = timer.Elapsed();
+
+  // switch (run_location_) {
+  //   case UserScript::DOCUMENT_START:
+  //     UMA_HISTOGRAM_COUNTS_100("Extensions.InjectStart_CssCount", num_css);
+  //     UMA_HISTOGRAM_COUNTS_100("Extensions.InjectStart_ScriptCount", num_js);
+  //     if (num_blocking_js) {
+  //       UMA_HISTOGRAM_COUNTS_100("Extensions.InjectStart_BlockingScriptCount",
+  //                                num_blocking_js);
+  //     } else if (num_css || num_js) {
+  //       UMA_HISTOGRAM_TIMES("Extensions.InjectStart_Time", elapsed);
+  //     }
+  //     break;
+  //   case UserScript::DOCUMENT_END:
+  //     UMA_HISTOGRAM_COUNTS_100("Extensions.InjectEnd_ScriptCount", num_js);
+  //     if (num_blocking_js) {
+  //       UMA_HISTOGRAM_COUNTS_100("Extensions.InjectEnd_BlockingScriptCount",
+  //                                num_blocking_js);
+  //     } else if (num_js) {
+  //       UMA_HISTOGRAM_TIMES("Extensions.InjectEnd_Time", elapsed);
+  //     }
+  //     break;
+  //   case UserScript::DOCUMENT_IDLE:
+  //     UMA_HISTOGRAM_COUNTS_100("Extensions.InjectIdle_ScriptCount", num_js);
+  //     if (num_blocking_js) {
+  //       UMA_HISTOGRAM_COUNTS_100("Extensions.InjectIdle_BlockingScriptCount",
+  //                                num_blocking_js);
+  //     } else if (num_js) {
+  //       UMA_HISTOGRAM_TIMES("Extensions.InjectIdle_Time", elapsed);
+  //     }
+  //     break;
+  //   case UserScript::RUN_DEFERRED:
+  //   case UserScript::BROWSER_DRIVEN:
+  //     // TODO(rdevlin.cronin): Add histograms.
+  //     break;
+  //   case UserScript::UNDEFINED:
+  //   case UserScript::RUN_LOCATION_LAST:
+  //     NOTREACHED();
+  // }
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/renderer/scripts_run_info.h b/components/user_scripts/renderer/scripts_run_info.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/scripts_run_info.h
@@ -0,0 +1,70 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_SCRIPTS_RUN_INFO_H_
+#define EXTENSIONS_RENDERER_SCRIPTS_RUN_INFO_H_
+
+#include <stddef.h>
+
+#include <map>
+#include <set>
+#include <string>
+
+#include "base/macros.h"
+#include "base/timer/elapsed_timer.h"
+#include "../common/user_script.h"
+
+namespace content {
+class RenderFrame;
+}
+
+namespace user_scripts {
+
+// A struct containing information about a script run.
+struct ScriptsRunInfo {
+  // Map of extensions IDs to the executing script paths.
+  typedef std::map<std::string, std::set<std::string> > ExecutingScriptsMap;
+
+  ScriptsRunInfo(content::RenderFrame* render_frame,
+                 UserScript::RunLocation location);
+  ~ScriptsRunInfo();
+
+  // The number of CSS scripts injected.
+  size_t num_css;
+  // The number of JS scripts injected.
+  size_t num_js;
+  // The number of blocked JS scripts injected.
+  size_t num_blocking_js;
+  // A map of extension ids to executing script paths.
+  ExecutingScriptsMap executing_scripts;
+  // A map of extension ids to injected stylesheet paths.
+  ExecutingScriptsMap injected_stylesheets;
+  // The elapsed time since the ScriptsRunInfo was constructed.
+  base::ElapsedTimer timer;
+
+  // Log information about a given script run. If |send_script_activity| is
+  // true, this also informs the browser of the script run.
+  void LogRun(bool send_script_activity);
+
+  static void LogLongInjectionTaskTime(UserScript::RunLocation run_location,
+                                       const base::TimeDelta& elapsed);
+
+ private:
+  // The routinig id to use to notify the browser of any injections. Since the
+  // frame may be deleted in injection, we don't hold on to a reference to it
+  // directly.
+  int routing_id_;
+
+  // The run location at which injection is happening.
+  UserScript::RunLocation run_location_;
+
+  // The url of the frame, preserved for the same reason as the routing id.
+  GURL frame_url_;
+
+  DISALLOW_COPY_AND_ASSIGN(ScriptsRunInfo);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_SCRIPTS_RUN_INFO_H_
diff --git a/components/user_scripts/renderer/user_script_injector.cc b/components/user_scripts/renderer/user_script_injector.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/user_script_injector.cc
@@ -0,0 +1,284 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "user_script_injector.h"
+
+#include <tuple>
+#include <vector>
+
+#include "base/logging.h"
+#include "base/lazy_instance.h"
+#include "content/public/common/url_constants.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/renderer/render_thread.h"
+#include "content/public/renderer/render_view.h"
+//#include "extensions/common/extension.h"
+//#include "extensions/common/guest_view/extensions_guest_view_messages.h"
+//#include "extensions/common/permissions/permissions_data.h"
+#include "components/user_scripts/content/renderer/grit/user_scripts_renderer_resources.h"
+#include "injection_host.h"
+#include "script_context.h"
+#include "scripts_run_info.h"
+#include "third_party/blink/public/web/web_document.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "third_party/blink/public/web/web_script_source.h"
+#include "ui/base/resource/resource_bundle.h"
+#include "url/gurl.h"
+
+namespace user_scripts {
+
+namespace {
+
+struct RoutingInfoKey {
+  int routing_id;
+  int script_id;
+
+  RoutingInfoKey(int routing_id, int script_id)
+      : routing_id(routing_id), script_id(script_id) {}
+
+  bool operator<(const RoutingInfoKey& other) const {
+    return std::tie(routing_id, script_id) <
+           std::tie(other.routing_id, other.script_id);
+  }
+};
+
+using RoutingInfoMap = std::map<RoutingInfoKey, bool>;
+
+// A map records whether a given |script_id| from a webview-added user script
+// is allowed to inject on the render of given |routing_id|.
+// Once a script is added, the decision of whether or not allowed to inject
+// won't be changed.
+// After removed by the webview, the user scipt will also be removed
+// from the render. Therefore, there won't be any query from the same
+// |script_id| and |routing_id| pair.
+// base::LazyInstance<RoutingInfoMap>::DestructorAtExit g_routing_info_map =
+//    LAZY_INSTANCE_INITIALIZER;
+
+// Greasemonkey API source that is injected with the scripts.
+struct GreasemonkeyApiJsString {
+  GreasemonkeyApiJsString();
+  blink::WebScriptSource GetSource() const;
+
+ private:
+  blink::WebString source_;
+};
+
+// The below constructor, monstrous as it is, just makes a WebScriptSource from
+// the GreasemonkeyApiJs resource.
+GreasemonkeyApiJsString::GreasemonkeyApiJsString() {
+  std::string greasemonky_api_js(
+      ui::ResourceBundle::GetSharedInstance().LoadDataResourceString(
+          IDR_GREASEMONKEY_API_JS));
+  source_ = blink::WebString::FromUTF8(greasemonky_api_js);
+}
+
+blink::WebScriptSource GreasemonkeyApiJsString::GetSource() const {
+  return blink::WebScriptSource(source_);
+}
+
+base::LazyInstance<GreasemonkeyApiJsString>::Leaky g_greasemonkey_api =
+    LAZY_INSTANCE_INITIALIZER;
+
+bool ShouldInjectScripts(const UserScript::FileList& scripts,
+                         const std::set<std::string>& injected_files) {
+  for (const std::unique_ptr<UserScript::File>& file : scripts) {
+    // Check if the script is already injected.
+    if (injected_files.count(file->url().path()) == 0) {
+      return true;
+    }
+  }
+  return false;
+}
+
+}  // namespace
+
+UserScriptInjector::UserScriptInjector(const UserScript* script,
+                                       UserScriptSet* script_list /*,
+                                       bool is_declarative*/)
+    : script_(script),
+      user_script_set_(script_list),
+      script_id_(script_->id()),
+      //host_id_(script_->host_id()),
+      //is_declarative_(is_declarative),
+      user_script_set_observer_(this) {
+  LOG(INFO) << "---UserScriptInjector::UserScriptInjector";
+  user_script_set_observer_.Add(script_list);
+}
+
+UserScriptInjector::~UserScriptInjector() {
+}
+
+void UserScriptInjector::OnUserScriptsUpdated(
+    const std::set<HostID>& changed_hosts,
+    const UserScriptList& scripts) {
+  // When user scripts are updated, all the old script pointers are invalidated.
+  script_ = nullptr;
+  // If the host causing this injection changed, then this injection
+  // will be removed, and there's no guarantee the backing script still exists.
+  // if (changed_hosts.count(host_id_) > 0)
+  //   return;
+
+  for (const std::unique_ptr<UserScript>& script : scripts) {
+    if (script->id() == script_id_) {
+      script_ = script.get();
+      break;
+    }
+  }
+  // If |host_id_| wasn't in |changed_hosts|, then the script for this injection
+  // should be guaranteed to exist.
+  DCHECK(script_);
+}
+
+UserScript::InjectionType UserScriptInjector::script_type() const {
+  return UserScript::CONTENT_SCRIPT;
+}
+
+bool UserScriptInjector::IsUserGesture() const {
+  return false;
+}
+
+bool UserScriptInjector::ExpectsResults() const {
+  return false;
+}
+
+base::Optional<CSSOrigin> UserScriptInjector::GetCssOrigin() const {
+  return base::nullopt;
+}
+
+const base::Optional<std::string> UserScriptInjector::GetInjectionKey() const {
+  return base::nullopt;
+}
+
+bool UserScriptInjector::ShouldInjectJs(
+    UserScript::RunLocation run_location,
+    const std::set<std::string>& executing_scripts) const {
+  return script_ && script_->run_location() == run_location &&
+         !script_->js_scripts().empty() &&
+         ShouldInjectScripts(script_->js_scripts(), executing_scripts);
+}
+
+bool UserScriptInjector::ShouldInjectCss(
+    UserScript::RunLocation run_location,
+    const std::set<std::string>& injected_stylesheets) const {
+  return script_ && run_location == UserScript::DOCUMENT_START &&
+         !script_->css_scripts().empty() &&
+         ShouldInjectScripts(script_->css_scripts(), injected_stylesheets);
+}
+
+// PermissionsData::PageAccess UserScriptInjector::CanExecuteOnFrame(
+//     const InjectionHost* injection_host,
+//     blink::WebLocalFrame* web_frame,
+//     int tab_id) {
+//   // There is no harm in allowing the injection when the script is gone,
+//   // because there is nothing to inject.
+//   if (!script_)
+//     return PermissionsData::PageAccess::kAllowed;
+
+//   if (script_->consumer_instance_type() ==
+//           UserScript::ConsumerInstanceType::WEBVIEW) {
+//     int routing_id = content::RenderView::FromWebView(web_frame->Top()->View())
+//                          ->GetRoutingID();
+
+//     RoutingInfoKey key(routing_id, script_->id());
+
+//     RoutingInfoMap& map = g_routing_info_map.Get();
+//     auto iter = map.find(key);
+
+//     bool allowed = false;
+//     if (iter != map.end()) {
+//       allowed = iter->second;
+//     } else {
+//       // Send a SYNC IPC message to the browser to check if this is allowed.
+//       // This is not ideal, but is mitigated by the fact that this is only done
+//       // for webviews, and then only once per host.
+//       // TODO(hanxi): Find a more efficient way to do this.
+//       content::RenderThread::Get()->Send(
+//           new ExtensionsGuestViewHostMsg_CanExecuteContentScriptSync(
+//               routing_id, script_->id(), &allowed));
+//       map.insert(std::pair<RoutingInfoKey, bool>(key, allowed));
+//     }
+
+//     return allowed ? PermissionsData::PageAccess::kAllowed
+//                    : PermissionsData::PageAccess::kDenied;
+//   }
+
+//   GURL effective_document_url =
+//       ScriptContext::GetEffectiveDocumentURLForInjection(
+//           web_frame, web_frame->GetDocument().Url(),
+//           script_->match_origin_as_fallback());
+
+//   return injection_host->CanExecuteOnFrame(
+//       effective_document_url,
+//       content::RenderFrame::FromWebFrame(web_frame),
+//       tab_id,
+//       is_declarative_);
+// }
+
+std::vector<blink::WebScriptSource> UserScriptInjector::GetJsSources(
+    UserScript::RunLocation run_location,
+    std::set<std::string>* executing_scripts,
+    size_t* num_injected_js_scripts) const {
+  DCHECK(script_);
+  std::vector<blink::WebScriptSource> sources;
+
+  DCHECK_EQ(script_->run_location(), run_location);
+
+  const UserScript::FileList& js_scripts = script_->js_scripts();
+  sources.reserve(js_scripts.size() +
+                  (script_->emulate_greasemonkey() ? 1 : 0));
+  // Emulate Greasemonkey API for scripts that were converted to extension
+  // user scripts.
+  if (script_->emulate_greasemonkey())
+    sources.push_back(g_greasemonkey_api.Get().GetSource());
+  for (const std::unique_ptr<UserScript::File>& file : js_scripts) {
+    const GURL& script_url = file->url();
+    // Check if the script is already injected.
+    if (executing_scripts->count(script_url.path()) != 0)
+      continue;
+
+    sources.push_back(blink::WebScriptSource(
+        user_script_set_->GetJsSource(*file, script_->emulate_greasemonkey()),
+        script_url));
+
+    (*num_injected_js_scripts) += 1;
+    executing_scripts->insert(script_url.path());
+  }
+
+  return sources;
+}
+
+std::vector<blink::WebString> UserScriptInjector::GetCssSources(
+    UserScript::RunLocation run_location,
+    std::set<std::string>* injected_stylesheets,
+    size_t* num_injected_stylesheets) const {
+  DCHECK(script_);
+  DCHECK_EQ(UserScript::DOCUMENT_START, run_location);
+
+  std::vector<blink::WebString> sources;
+
+  const UserScript::FileList& css_scripts = script_->css_scripts();
+  sources.reserve(css_scripts.size());
+  for (const std::unique_ptr<UserScript::File>& file : script_->css_scripts()) {
+    const std::string& stylesheet_path = file->url().path();
+    // Check if the stylesheet is already injected.
+    if (injected_stylesheets->count(stylesheet_path) != 0)
+      continue;
+
+    sources.push_back(user_script_set_->GetCssSource(*file));
+    (*num_injected_stylesheets) += 1;
+    injected_stylesheets->insert(stylesheet_path);
+  }
+  return sources;
+}
+
+void UserScriptInjector::OnInjectionComplete(
+    std::unique_ptr<base::Value> execution_result,
+    UserScript::RunLocation run_location,
+    content::RenderFrame* render_frame) {}
+
+void UserScriptInjector::OnWillNotInject(InjectFailureReason reason,
+                                         content::RenderFrame* render_frame) {
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/renderer/user_script_injector.h b/components/user_scripts/renderer/user_script_injector.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/user_script_injector.h
@@ -0,0 +1,98 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_USER_SCRIPT_INJECTOR_H_
+#define EXTENSIONS_RENDERER_USER_SCRIPT_INJECTOR_H_
+
+#include <memory>
+#include <string>
+
+#include "base/macros.h"
+#include "base/scoped_observer.h"
+#include "../common/user_script.h"
+#include "script_injection.h"
+#include "user_script_set.h"
+
+class InjectionHost;
+
+namespace blink {
+class WebLocalFrame;
+}
+
+namespace user_scripts {
+
+// A ScriptInjector for UserScripts.
+class UserScriptInjector : public ScriptInjector,
+                           public UserScriptSet::Observer {
+ public:
+  UserScriptInjector(const UserScript* user_script,
+                     UserScriptSet* user_script_set /*,
+                     bool is_declarative*/);
+  ~UserScriptInjector() override;
+
+ private:
+  // UserScriptSet::Observer implementation.
+  void OnUserScriptsUpdated(const std::set<HostID>& changed_hosts,
+                            const UserScriptList& scripts) override;
+
+  // ScriptInjector implementation.
+  UserScript::InjectionType script_type() const override;
+  bool IsUserGesture() const override;
+  base::Optional<CSSOrigin> GetCssOrigin() const override;
+  const base::Optional<std::string> GetInjectionKey() const override;
+  bool ExpectsResults() const override;
+  bool ShouldInjectJs(
+      UserScript::RunLocation run_location,
+      const std::set<std::string>& executing_scripts) const override;
+  bool ShouldInjectCss(
+      UserScript::RunLocation run_location,
+      const std::set<std::string>& injected_stylesheets) const override;
+//   PermissionsData::PageAccess CanExecuteOnFrame(
+//       const InjectionHost* injection_host,
+//       blink::WebLocalFrame* web_frame,
+//       int tab_id) override;
+  std::vector<blink::WebScriptSource> GetJsSources(
+      UserScript::RunLocation run_location,
+      std::set<std::string>* executing_scripts,
+      size_t* num_injected_js_scripts) const override;
+  std::vector<blink::WebString> GetCssSources(
+      UserScript::RunLocation run_location,
+      std::set<std::string>* injected_stylesheets,
+      size_t* num_injected_stylesheets) const override;
+  void OnInjectionComplete(std::unique_ptr<base::Value> execution_result,
+                           UserScript::RunLocation run_location,
+                           content::RenderFrame* render_frame) override;
+  void OnWillNotInject(InjectFailureReason reason,
+                       content::RenderFrame* render_frame) override;
+
+  // The associated user script. Owned by the UserScriptInjector that created
+  // this object.
+  const UserScript* script_;
+
+  // The UserScriptSet that eventually owns the UserScript this
+  // UserScriptInjector points to.
+  // Outlives |this|.
+  UserScriptSet* const user_script_set_;
+
+  // The id of the associated user script. We cache this because when we update
+  // the |script_| associated with this injection, the old referance may be
+  // deleted.
+  int script_id_;
+
+  // The associated host id, preserved for the same reason as |script_id|.
+  //HostID host_id_;
+
+  // Indicates whether or not this script is declarative. This influences which
+  // script permissions are checked before injection.
+  //bool is_declarative_;
+
+  ScopedObserver<UserScriptSet, UserScriptSet::Observer>
+      user_script_set_observer_;
+
+  DISALLOW_COPY_AND_ASSIGN(UserScriptInjector);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_USER_SCRIPT_INJECTOR_H_
diff --git a/components/user_scripts/renderer/user_script_set.cc b/components/user_scripts/renderer/user_script_set.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/user_script_set.cc
@@ -0,0 +1,293 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "user_script_set.h"
+
+#include <stddef.h>
+
+#include <utility>
+
+#include "base/logging.h"
+#include "base/debug/alias.h"
+#include "base/memory/ref_counted.h"
+#include "base/strings/strcat.h"
+#include "content/public/common/url_constants.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/renderer/render_thread.h"
+//#include "extensions/common/extension.h"
+//#include "extensions/common/extensions_client.h"
+//#include "extensions/common/permissions/permissions_data.h"
+//#include "extension_injection_host.h"
+//#include "extensions_renderer_client.h"
+#include "injection_host.h"
+//#include "extensions/renderer/renderer_extension_registry.h"
+#include "script_context.h"
+#include "script_injection.h"
+#include "user_script_injector.h"
+#include "web_ui_injection_host.h"
+#include "third_party/blink/public/web/web_document.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "url/gurl.h"
+
+namespace user_scripts {
+
+namespace {
+
+// These two strings are injected before and after the Greasemonkey API and
+// user script to wrap it in an anonymous scope.
+const char kUserScriptHead[] = "(function (unsafeWindow) {\n";
+const char kUserScriptTail[] = "\n})(window);";
+// Maximum number of total content scripts we allow (across all extensions).
+// The limit exists to diagnose https://crbug.com/723381. The number is
+// arbitrarily chosen.
+// TODO(lazyboy): Remove when the bug is fixed.
+const uint32_t kNumScriptsArbitraryMax = 100000u;
+
+GURL GetDocumentUrlForFrame(blink::WebLocalFrame* frame) {
+  GURL data_source_url = ScriptContext::GetDocumentLoaderURLForFrame(frame);
+  if (!data_source_url.is_empty() && frame->IsViewSourceModeEnabled()) {
+    data_source_url = GURL(content::kViewSourceScheme + std::string(":") +
+                           data_source_url.spec());
+  }
+
+  return data_source_url;
+}
+
+}  // namespace
+
+UserScriptSet::UserScriptSet() {}
+
+UserScriptSet::~UserScriptSet() {
+}
+
+void UserScriptSet::AddObserver(Observer* observer) {
+  observers_.AddObserver(observer);
+}
+
+void UserScriptSet::RemoveObserver(Observer* observer) {
+  observers_.RemoveObserver(observer);
+}
+
+// void UserScriptSet::GetActiveExtensionIds(
+//     std::set<std::string>* ids) const {
+//   for (const std::unique_ptr<UserScript>& script : scripts_) {
+//     if (script->host_id().type() != HostID::EXTENSIONS)
+//       continue;
+//     DCHECK(!script->extension_id().empty());
+//     ids->insert(script->extension_id());
+//   }
+// }
+
+void UserScriptSet::GetInjections(
+    std::vector<std::unique_ptr<ScriptInjection>>* injections,
+    content::RenderFrame* render_frame,
+    int tab_id,
+    UserScript::RunLocation run_location,
+    bool log_activity) {
+  GURL document_url = GetDocumentUrlForFrame(render_frame->GetWebFrame());
+  for (const std::unique_ptr<UserScript>& script : scripts_) {
+    std::unique_ptr<ScriptInjection> injection = GetInjectionForScript(
+        script.get(), render_frame, tab_id, run_location, document_url,
+        /* is_declarative, */ log_activity);
+    if (injection.get())
+      injections->push_back(std::move(injection));
+  }
+}
+
+bool UserScriptSet::UpdateUserScripts(
+    base::ReadOnlySharedMemoryRegion shared_memory,
+    const std::set<HostID>& changed_hosts,
+    bool whitelisted_only) {
+  bool only_inject_incognito = false;
+      //ExtensionsRendererClient::Get()->IsIncognitoProcess();
+
+  // Create the shared memory mapping.
+  shared_memory_mapping_ = shared_memory.Map();
+  if (!shared_memory.IsValid())
+    return false;
+
+  // First get the size of the memory block.
+  const base::Pickle::Header* pickle_header =
+      shared_memory_mapping_.GetMemoryAs<base::Pickle::Header>();
+  if (!pickle_header)
+    return false;
+
+  // Now read in the rest of the block.
+  size_t pickle_size =
+      sizeof(base::Pickle::Header) + pickle_header->payload_size;
+
+  // Unpickle scripts.
+  uint32_t num_scripts = 0;
+  auto memory = shared_memory_mapping_.GetMemoryAsSpan<char>(pickle_size);
+  if (!memory.size())
+    return false;
+
+  base::Pickle pickle(memory.data(), pickle_size);
+  base::PickleIterator iter(pickle);
+  base::debug::Alias(&pickle_size);
+  CHECK(iter.ReadUInt32(&num_scripts));
+
+  // Sometimes the shared memory contents seem to be corrupted
+  // (https://crbug.com/723381). Set an arbitrary max limit to the number of
+  // scripts so that we don't add OOM noise to crash reports.
+  CHECK_LT(num_scripts, kNumScriptsArbitraryMax);
+
+  scripts_.clear();
+  script_sources_.clear();
+  scripts_.reserve(num_scripts);
+  for (uint32_t i = 0; i < num_scripts; ++i) {
+    std::unique_ptr<UserScript> script(new UserScript());
+    script->Unpickle(pickle, &iter);
+
+    // Note that this is a pointer into shared memory. We don't own it. It gets
+    // cleared up when the last renderer or browser process drops their
+    // reference to the shared memory.
+    for (size_t j = 0; j < script->js_scripts().size(); ++j) {
+      const char* body = NULL;
+      int body_length = 0;
+      CHECK(iter.ReadData(&body, &body_length));
+      script->js_scripts()[j]->set_external_content(
+          base::StringPiece(body, body_length));
+    }
+    for (size_t j = 0; j < script->css_scripts().size(); ++j) {
+      const char* body = NULL;
+      int body_length = 0;
+      CHECK(iter.ReadData(&body, &body_length));
+      script->css_scripts()[j]->set_external_content(
+          base::StringPiece(body, body_length));
+    }
+
+    if (only_inject_incognito && !script->is_incognito_enabled())
+      continue;  // This script shouldn't run in an incognito tab.
+
+    // const Extension* extension =
+    //     RendererExtensionRegistry::Get()->GetByID(script->extension_id());
+    // if (whitelisted_only &&
+    //     (!extension || !PermissionsData::CanExecuteScriptEverywhere(
+    //                        extension->id(), extension->location()))) {
+    //   continue;
+    // }
+
+    scripts_.push_back(std::move(script));
+  }
+
+  for (auto& observer : observers_)
+    observer.OnUserScriptsUpdated(changed_hosts, scripts_);
+  return true;
+}
+
+void UserScriptSet::AddScript(std::unique_ptr<UserScript> script) {
+  scripts_.push_back(std::move(script));
+}
+
+// std::unique_ptr<ScriptInjection> UserScriptSet::GetDeclarativeScriptInjection(
+//     int script_id,
+//     content::RenderFrame* render_frame,
+//     int tab_id,
+//     UserScript::RunLocation run_location,
+//     const GURL& document_url,
+//     bool log_activity) {
+//   for (const std::unique_ptr<UserScript>& script : scripts_) {
+//     if (script->id() == script_id) {
+//       return GetInjectionForScript(script.get(), render_frame, tab_id,
+//                                    run_location, document_url,
+//                                    /* is_declarative, */ log_activity);
+//     }
+//   }
+//   return std::unique_ptr<ScriptInjection>();
+// }
+
+std::unique_ptr<ScriptInjection> UserScriptSet::GetInjectionForScript(
+    const UserScript* script,
+    content::RenderFrame* render_frame,
+    int tab_id,
+    UserScript::RunLocation run_location,
+    const GURL& document_url,
+    //bool is_declarative,
+    bool log_activity) {
+  std::unique_ptr<ScriptInjection> injection;
+  std::unique_ptr<const InjectionHost> injection_host;
+  blink::WebLocalFrame* web_frame = render_frame->GetWebFrame();
+
+  const HostID& host_id = script->host_id();
+//  if (host_id.type() == HostID::EXTENSIONS) {
+//    injection_host = ExtensionInjectionHost::Create(host_id.id());
+//    if (!injection_host)
+//      return injection;
+//  } else {
+//    DCHECK_EQ(host_id.type(), HostID::WEBUI);
+    injection_host.reset(new WebUIInjectionHost(host_id));
+//  }
+
+  GURL effective_document_url =
+      ScriptContext::GetEffectiveDocumentURLForInjection(
+          web_frame, document_url, script->match_origin_as_fallback());
+
+  bool is_subframe = web_frame->Parent();
+  if (!script->MatchesDocument(effective_document_url, is_subframe))
+    return injection;
+
+  std::unique_ptr<ScriptInjector> injector(
+      new UserScriptInjector(script, this/*, is_declarative*/));
+
+  // if (injector->CanExecuteOnFrame(injection_host.get(), web_frame, tab_id) ==
+  //     PermissionsData::PageAccess::kDenied) {
+  //   return injection;
+  // }
+
+  bool inject_css = !script->css_scripts().empty() &&
+                    run_location == UserScript::DOCUMENT_START;
+  bool inject_js =
+      !script->js_scripts().empty() && script->run_location() == run_location;
+  if (inject_css || inject_js) {
+    injection.reset(new ScriptInjection(std::move(injector), render_frame,
+                                        std::move(injection_host), run_location,
+                                        log_activity));
+  }
+  return injection;
+}
+
+blink::WebString UserScriptSet::GetJsSource(const UserScript::File& file,
+                                            bool emulate_greasemonkey) {
+  const GURL& url = file.url();
+  auto iter = script_sources_.find(url);
+  if (iter != script_sources_.end()) {
+    LOG(INFO) << "---UserScriptSet::GetJsSource found " << url;
+    return iter->second;
+  }
+
+  base::StringPiece script_content = file.GetContent();
+  blink::WebString source;
+  if (emulate_greasemonkey) {
+    // We add this dumb function wrapper for user scripts to emulate what
+    // Greasemonkey does. |script_content| becomes:
+    // concat(kUserScriptHead, script_content, kUserScriptTail).
+    std::string content =
+        base::StrCat({kUserScriptHead, script_content, kUserScriptTail});
+    source = blink::WebString::FromUTF8(content);
+    LOG(INFO) << "---UserScriptSet::GetJsSource emu " << script_content;
+  } else {
+    source = blink::WebString::FromUTF8(script_content.data(),
+                                        script_content.length());
+    LOG(INFO) << "---UserScriptSet::GetJsSource " << source.Ascii();
+  }
+  script_sources_[url] = source;
+  return source;
+}
+
+blink::WebString UserScriptSet::GetCssSource(const UserScript::File& file) {
+  const GURL& url = file.url();
+  auto iter = script_sources_.find(url);
+  if (iter != script_sources_.end())
+    return iter->second;
+
+  base::StringPiece script_content = file.GetContent();
+  return script_sources_
+      .insert(std::make_pair(
+          url, blink::WebString::FromUTF8(script_content.data(),
+                                          script_content.length())))
+      .first->second;
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/renderer/user_script_set.h b/components/user_scripts/renderer/user_script_set.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/user_script_set.h
@@ -0,0 +1,113 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_USER_SCRIPT_SET_H_
+#define EXTENSIONS_RENDERER_USER_SCRIPT_SET_H_
+
+#include <map>
+#include <memory>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/memory/read_only_shared_memory_region.h"
+#include "base/observer_list.h"
+#include "../common/user_script.h"
+#include "third_party/blink/public/platform/web_string.h"
+
+class GURL;
+
+namespace content {
+class RenderFrame;
+}
+
+namespace user_scripts {
+class ScriptInjection;
+
+// The UserScriptSet is a collection of UserScripts which knows how to update
+// itself from SharedMemory and create ScriptInjections for UserScripts to
+// inject on a page.
+class UserScriptSet {
+ public:
+  class Observer {
+   public:
+    // Called when the set of user scripts is updated. |changed_hosts| contains
+    // the hosts whose scripts have been altered. Note that *all* script objects
+    // are invalidated, even if they aren't in |changed_hosts|.
+    virtual void OnUserScriptsUpdated(const std::set<HostID>& changed_hosts,
+                                      const UserScriptList& scripts) = 0;
+  };
+
+  UserScriptSet();
+  ~UserScriptSet();
+
+  // Adds or removes observers.
+  void AddObserver(Observer* observer);
+  void RemoveObserver(Observer* observer);
+  void AddScript(std::unique_ptr<UserScript> script);
+
+  // Appends the ids of the extensions that have user scripts to |ids|.
+  //void GetActiveExtensionIds(std::set<std::string>* ids) const;
+
+  // Append any ScriptInjections that should run on the given |render_frame| and
+  // |tab_id|, at the given |run_location|, to |injections|.
+  // |extensions| is passed in to verify the corresponding extension is still
+  // valid.
+  void GetInjections(std::vector<std::unique_ptr<ScriptInjection>>* injections,
+                     content::RenderFrame* render_frame,
+                     int tab_id,
+                     UserScript::RunLocation run_location,
+                     bool log_activity);
+
+//   std::unique_ptr<ScriptInjection> GetDeclarativeScriptInjection(
+//       int script_id,
+//       content::RenderFrame* render_frame,
+//       int tab_id,
+//       UserScript::RunLocation run_location,
+//       const GURL& document_url,
+//       bool log_activity);
+
+  // Updates scripts given the shared memory region containing user scripts.
+  // Returns true if the scripts were successfully updated.
+  bool UpdateUserScripts(base::ReadOnlySharedMemoryRegion shared_memory,
+                         const std::set<HostID>& changed_hosts,
+                         bool whitelisted_only);
+
+  // Returns the contents of a script file.
+  // Note that copying is cheap as this uses WebString.
+  blink::WebString GetJsSource(const UserScript::File& file,
+                               bool emulate_greasemonkey);
+  blink::WebString GetCssSource(const UserScript::File& file);
+
+ private:
+  // Returns a new ScriptInjection for the given |script| to execute in the
+  // |render_frame|, or NULL if the script should not execute.
+  std::unique_ptr<ScriptInjection> GetInjectionForScript(
+      const UserScript* script,
+      content::RenderFrame* render_frame,
+      int tab_id,
+      UserScript::RunLocation run_location,
+      const GURL& document_url,
+      //bool is_declarative,
+      bool log_activity);
+
+  // Shared memory mapping containing raw script data.
+  base::ReadOnlySharedMemoryMapping shared_memory_mapping_;
+
+  // The UserScripts this injector manages.
+  UserScriptList scripts_;
+
+  // Map of user script file url -> source.
+  std::map<GURL, blink::WebString> script_sources_;
+
+  // The associated observers.
+  base::ObserverList<Observer>::Unchecked observers_;
+
+  DISALLOW_COPY_AND_ASSIGN(UserScriptSet);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_USER_SCRIPT_SET_H_
diff --git a/components/user_scripts/renderer/user_script_set_manager.cc b/components/user_scripts/renderer/user_script_set_manager.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/user_script_set_manager.cc
@@ -0,0 +1,179 @@
+#include "user_script_set_manager.h"
+
+#include "base/logging.h"
+#include "content/public/renderer/render_thread.h"
+#include "../common/host_id.h"
+#include "../common/extension_messages.h"
+#include "user_script_set.h"
+
+namespace user_scripts {
+
+UserScriptSetManager::UserScriptSetManager() {
+
+  //UserScript script_;
+  std::unique_ptr<UserScript> script_(new UserScript());
+  script_->set_id(UserScript::GenerateUserScriptID());
+  script_->set_host_id(HostID(HostID::HostType::WEBUI, "test"));
+  script_->set_run_location(UserScript::DOCUMENT_START);
+  script_->set_match_all_frames(false);
+  script_->set_match_origin_as_fallback(MatchOriginAsFallbackBehavior::kNever);
+  //script_->add_url_pattern(URLPattern(URLPattern::SCHEME_HTTPS, "*://*/*"));
+  script_->add_url_pattern(URLPattern(URLPattern::SCHEME_HTTPS, "*://*.google.com/*"));
+
+  // for (auto it = script_data.css_file_names.cbegin();
+  //      it != script_data.css_file_names.cend(); ++it) {
+  //   GURL url = extension->GetResourceURL(*it);
+  //   ExtensionResource resource = extension->GetResource(*it);
+  //   script_.css_scripts().push_back(std::make_unique<UserScript::File>(
+  //       resource.extension_root(), resource.relative_path(), url));
+  // }
+  // for (auto it = script_data.js_file_names.cbegin();
+  //      it != script_data.js_file_names.cend(); ++it) {
+  //   GURL url = extension->GetResourceURL(*it);
+  //   ExtensionResource resource = extension->GetResource(*it);
+  //   script_.js_scripts().push_back(std::make_unique<UserScript::File>(
+  //       resource.extension_root(), resource.relative_path(), url));
+  // }
+
+  std::unique_ptr<UserScript::File> file(new UserScript::File());
+  //file->set_content("document.cookie = 'CONSENT=YES+IT.it+V13+BX;domain=.google.com'; document.cookie = '1P_JAR=2020-10-18-08;domain=.google.com'; console.log('aa');");
+  file->set_content("document.cookie = 'CONSENT=YES+IT.it+V13+BX;domain=.google.com'; console.log('aa');");
+  file->set_url(GURL("url"));
+  script_->js_scripts().push_back(std::move(file));
+
+  static_scripts_.AddScript(std::move(script_));
+
+  LOG(INFO) << "---UserScriptSetManager::UserScriptSetManager";
+
+  content::RenderThread::Get()->AddObserver(this);
+}
+
+UserScriptSetManager::~UserScriptSetManager() {
+}
+
+void UserScriptSetManager::AddObserver(Observer* observer) {
+  observers_.AddObserver(observer);
+}
+
+void UserScriptSetManager::RemoveObserver(Observer* observer) {
+  observers_.RemoveObserver(observer);
+}
+
+bool UserScriptSetManager::OnControlMessageReceived(
+    const IPC::Message& message) {
+  bool handled = true;
+  IPC_BEGIN_MESSAGE_MAP(UserScriptSetManager, message)
+    IPC_MESSAGE_HANDLER(ExtensionMsg_UpdateUserScripts, OnUpdateUserScripts)
+    IPC_MESSAGE_UNHANDLED(handled = false)
+  IPC_END_MESSAGE_MAP()
+  return handled;
+}
+
+// std::unique_ptr<ScriptInjection>
+// UserScriptSetManager::GetInjectionForDeclarativeScript(
+//     int script_id,
+//     content::RenderFrame* render_frame,
+//     int tab_id,
+//     const GURL& url,
+//     const std::string& extension_id) {
+// //  UserScriptSet* user_script_set =
+// //      GetProgrammaticScriptsByHostID(HostID(HostID::EXTENSIONS, extension_id));
+// //  if (!user_script_set)
+//     return std::unique_ptr<ScriptInjection>();
+
+// //  return user_script_set->GetDeclarativeScriptInjection(
+// //      script_id, render_frame, tab_id, UserScript::BROWSER_DRIVEN, url,
+// //      activity_logging_enabled_);
+// }
+
+//UserScriptSet* UserScriptSetManager::GetProgrammaticScriptsByHostID(
+//    const HostID& host_id) {
+//  UserScriptSetMap::const_iterator it = programmatic_scripts_.find(host_id);
+//  return it != programmatic_scripts_.end() ? it->second.get() : NULL;
+//}
+
+void UserScriptSetManager::GetAllInjections(
+    std::vector<std::unique_ptr<ScriptInjection>>* injections,
+    content::RenderFrame* render_frame,
+    int tab_id,
+    UserScript::RunLocation run_location) {
+
+  LOG(INFO) << "---UserScriptSetManager::GetAllInjections";
+
+  // static_scripts_ is UserScriptSet
+  static_scripts_.GetInjections(injections, render_frame, tab_id, run_location,
+                                activity_logging_enabled_);
+//  for (auto it = programmatic_scripts_.begin();
+//       it != programmatic_scripts_.end(); ++it) {
+//    it->second->GetInjections(injections, render_frame, tab_id, run_location,
+//                              activity_logging_enabled_);
+//  }
+}
+
+void UserScriptSetManager::OnUpdateUserScripts(
+    base::ReadOnlySharedMemoryRegion shared_memory) {
+    //,const HostID& host_id,
+    //const std::set<HostID>& changed_hosts,
+    //bool whitelisted_only) {
+  if (!shared_memory.IsValid()) {
+    NOTREACHED() << "Bad scripts handle";
+    return;
+  }
+
+  // for (const HostID& host_id : changed_hosts) {
+  //   if (host_id.type() == HostID::EXTENSIONS &&
+  //       !crx_file::id_util::IdIsValid(host_id.id())) {
+  //     NOTREACHED() << "Invalid extension id: " << host_id.id();
+  //     return;
+  //   }
+  // }
+
+  UserScriptSet* scripts = NULL;
+  // if (!host_id.id().empty()) {
+  //   // The expectation when there is a host that "owns" this shared
+  //   // memory region is that the |changed_hosts| is either the empty list
+  //   // or just the owner.
+  //   CHECK(changed_hosts.size() <= 1);
+  //   if (programmatic_scripts_.find(host_id) == programmatic_scripts_.end()) {
+  //     scripts = programmatic_scripts_
+  //                   .insert(std::make_pair(host_id,
+  //                                          std::make_unique<UserScriptSet>()))
+  //                   .first->second.get();
+  //   } else {
+  //     scripts = programmatic_scripts_[host_id].get();
+  //   }
+  // } else {
+    scripts = &static_scripts_;
+  // }
+  DCHECK(scripts);
+
+  // If no hosts are included in the set, that indicates that all
+  // hosts were updated. Add them all to the set so that observers and
+  // individual UserScriptSets don't need to know this detail.
+  //const std::set<HostID>* effective_hosts = &changed_hosts;
+  std::set<HostID> all_hosts;
+  const std::set<HostID>* effective_hosts = &all_hosts;
+  //if (changed_hosts.empty()) {
+    // // The meaning of "all hosts(extensions)" varies, depending on whether some
+    // // host "owns" this shared memory region.
+    // // No owner => all known hosts.
+    // // Owner    => just the owner host.
+    // if (host_id.id().empty()) {
+    //   std::set<std::string> extension_ids =
+    //       RendererExtensionRegistry::Get()->GetIDs();
+    //   for (const std::string& extension_id : extension_ids)
+    //     all_hosts.insert(HostID(HostID::EXTENSIONS, extension_id));
+    // } else {
+    //   all_hosts.insert(host_id);
+    // }
+    //effective_hosts = &all_hosts;
+  //}
+
+  if (scripts->UpdateUserScripts(std::move(shared_memory), *effective_hosts,
+                                 false /*whitelisted_only*/)) {
+    for (auto& observer : observers_)
+      observer.OnUserScriptsUpdated(all_hosts /* *effective_hosts*/);
+  }
+}
+
+}
\ No newline at end of file
diff --git a/components/user_scripts/renderer/user_script_set_manager.h b/components/user_scripts/renderer/user_script_set_manager.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/user_script_set_manager.h
@@ -0,0 +1,76 @@
+#ifndef COMPONENTS_USER_SCRIPTS_RENDER_SET_MANAGER_H_
+#define COMPONENTS_USER_SCRIPTS_RENDER_SET_MANAGER_H_
+
+#include <map>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/memory/read_only_shared_memory_region.h"
+#include "base/observer_list.h"
+#include "content/public/renderer/render_thread_observer.h"
+#include "../common/host_id.h"
+#include "user_script_set.h"
+#include "script_injection.h"
+
+namespace user_scripts {
+
+class UserScriptSetManager : public content::RenderThreadObserver {
+ public:
+  class Observer {
+   public:
+    virtual void OnUserScriptsUpdated(const std::set<HostID>& changed_hosts) = 0;
+  };
+
+  UserScriptSetManager();
+
+  ~UserScriptSetManager() override;
+
+  void AddObserver(Observer* observer);
+  void RemoveObserver(Observer* observer);
+
+  // // Looks up the script injection associated with |script_id| and
+  // // |extension_id| in the context of the given |web_frame|, |tab_id|,
+  // // and |url|.
+  // std::unique_ptr<ScriptInjection> GetInjectionForDeclarativeScript(
+  //     int script_id,
+  //     content::RenderFrame* render_frame,
+  //     int tab_id,
+  //     const GURL& url,
+  //     const std::string& extension_id);
+
+  // Append all injections from |static_scripts| and each of
+  // |programmatic_scripts_| to |injections|.
+  void GetAllInjections(
+      std::vector<std::unique_ptr<ScriptInjection>>* injections,
+      content::RenderFrame* render_frame,
+      int tab_id,
+      UserScript::RunLocation run_location);
+
+private:
+  // content::RenderThreadObserver implementation.
+  bool OnControlMessageReceived(const IPC::Message& message) override;
+
+  base::ObserverList<Observer>::Unchecked observers_;
+
+  // Scripts programmatically-defined through API calls (initialized and stored
+  // per-extension).
+  //UserScriptSetMap programmatic_scripts_;
+
+  // Handle the UpdateUserScripts extension message.
+  void OnUpdateUserScripts(base::ReadOnlySharedMemoryRegion shared_memory);
+                           //, const HostID& host_id,
+                           //const std::set<HostID>& changed_hosts,
+                           //bool whitelisted_only);
+
+  // Scripts statically defined in extension manifests.
+  UserScriptSet static_scripts_;
+
+  // Whether or not dom activity should be logged for scripts injected.
+  bool activity_logging_enabled_ = false;
+};
+
+}
+
+#endif
\ No newline at end of file
diff --git a/components/user_scripts/renderer/user_scripts_dispatcher.cc b/components/user_scripts/renderer/user_scripts_dispatcher.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/user_scripts_dispatcher.cc
@@ -0,0 +1,61 @@
+#include "user_scripts_dispatcher.h"
+
+#include <stddef.h>
+
+#include <algorithm>
+#include <memory>
+#include <utility>
+
+#include "content/public/renderer/render_thread.h"
+#include "extension_frame_helper.h"
+
+namespace user_scripts {
+
+// ex ChromeExtensionsDispatcherDelegate
+UserScriptsDispatcher::UserScriptsDispatcher()
+    : user_script_set_manager_observer_(this) {
+    //: delegate_(std::move(delegate))
+    //,
+    //  content_watcher_(new ContentWatcher()),
+    //  source_map_(&ui::ResourceBundle::GetSharedInstance()),
+    //  v8_schema_registry_(new V8SchemaRegistry),
+    //activity_logging_enabled_(false)
+      user_script_set_manager_.reset(new UserScriptSetManager());
+      script_injection_manager_.reset(
+          new ScriptInjectionManager(user_script_set_manager_.get()));
+      user_script_set_manager_observer_.Add(user_script_set_manager_.get());
+}
+
+UserScriptsDispatcher::~UserScriptsDispatcher() {
+}
+
+void UserScriptsDispatcher::OnRenderThreadStarted(content::RenderThread* thread) {
+  //thread->RegisterExtension(extensions::SafeBuiltins::CreateV8Extension());
+}
+
+void UserScriptsDispatcher::OnUserScriptsUpdated(const std::set<HostID>& changed_hosts) {
+  //UpdateActiveExtensions();
+}
+
+void UserScriptsDispatcher::OnRenderFrameCreated(content::RenderFrame* render_frame) {
+  script_injection_manager_->OnRenderFrameCreated(render_frame);
+  //content_watcher_->OnRenderFrameCreated(render_frame);
+}
+
+//void Dispatcher::OnSetActivityLoggingEnabled(bool enabled) {
+//  activity_logging_enabled_ = enabled;
+//  if (enabled) {
+//    for (const std::string& id : active_extension_ids_)
+//      DOMActivityLogger::AttachToWorld(DOMActivityLogger::kMainWorldId, id);
+//  }
+//  script_injection_manager_->set_activity_logging_enabled(enabled);
+//  user_script_set_manager_->set_activity_logging_enabled(enabled);
+//}
+
+//void Dispatcher::UpdateActiveExtensions() {
+//  std::set<std::string> active_extensions = active_extension_ids_;
+//  user_script_set_manager_->GetAllActiveExtensionIds(&active_extensions);
+//  delegate_->OnActiveExtensionsUpdated(active_extensions);
+//}
+
+}
\ No newline at end of file
diff --git a/components/user_scripts/renderer/user_scripts_dispatcher.h b/components/user_scripts/renderer/user_scripts_dispatcher.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/user_scripts_dispatcher.h
@@ -0,0 +1,51 @@
+#ifndef COMPONENTS_USER_SCRIPTS_RENDER_DISPATCHER_H_
+#define COMPONENTS_USER_SCRIPTS_RENDER_DISPATCHER_H_
+
+#include "user_script_set_manager.h"
+#include "script_injection_manager.h"
+
+#include <stdint.h>
+
+#include <map>
+#include <memory>
+#include <set>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/scoped_observer.h"
+#include "content/public/renderer/render_thread_observer.h"
+#include "content/public/renderer/render_thread.h"
+#include "../common/host_id.h"
+#include "user_script_set_manager.h"
+#include "script_injection.h"
+
+namespace user_scripts {
+
+class UserScriptsDispatcher : public content::RenderThreadObserver,
+                              public UserScriptSetManager::Observer {
+
+ public:
+  explicit UserScriptsDispatcher();
+  ~UserScriptsDispatcher() override;
+
+  void OnRenderThreadStarted(content::RenderThread* thread);
+  void OnUserScriptsUpdated(const std::set<HostID>& changed_hosts) override;
+  void OnRenderFrameCreated(content::RenderFrame* render_frame);
+
+ private:
+  std::unique_ptr<UserScriptSetManager> user_script_set_manager_;
+
+  std::unique_ptr<ScriptInjectionManager> script_injection_manager_;
+
+  ScopedObserver<UserScriptSetManager, UserScriptSetManager::Observer>
+      user_script_set_manager_observer_;
+
+  // Whether or not extension activity is enabled.
+  //bool activity_logging_enabled_;
+};
+
+}
+
+#endif
\ No newline at end of file
diff --git a/components/user_scripts/renderer/user_scripts_renderer_client.cc b/components/user_scripts/renderer/user_scripts_renderer_client.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/user_scripts_renderer_client.cc
@@ -0,0 +1,72 @@
+#include "user_scripts_renderer_client.h"
+
+#include <memory>
+#include <utility>
+
+#include "base/logging.h"
+#include "base/lazy_instance.h"
+#include "content/public/renderer/render_thread.h"
+#include "user_scripts_dispatcher.h"
+#include "extension_frame_helper.h"
+
+namespace user_scripts {
+
+// was ChromeExtensionsRendererClient
+UserScriptsRendererClient::UserScriptsRendererClient() {}
+
+UserScriptsRendererClient::~UserScriptsRendererClient() {}
+
+// static
+UserScriptsRendererClient* UserScriptsRendererClient::GetInstance() {
+  static base::LazyInstance<UserScriptsRendererClient>::Leaky client =
+      LAZY_INSTANCE_INITIALIZER;
+  return client.Pointer();
+}
+
+void UserScriptsRendererClient::RenderThreadStarted() {
+  LOG(INFO) << "---UserScriptsRendererClient::RenderThreadStarted";
+  content::RenderThread* thread = content::RenderThread::Get();
+
+  dispatcher_ = std::make_unique<UserScriptsDispatcher>();
+
+  dispatcher_->OnRenderThreadStarted(thread);
+  thread->AddObserver(dispatcher_.get());
+}
+
+void UserScriptsRendererClient::RenderFrameCreated(
+    content::RenderFrame* render_frame,
+    service_manager::BinderRegistry* registry) {
+  //new user_scripts::ExtensionsRenderFrameObserver(render_frame, registry);
+  new user_scripts::ExtensionFrameHelper(render_frame
+                                         /*,dispatcher_.get()*/);
+  dispatcher_->OnRenderFrameCreated(render_frame);
+}
+
+void UserScriptsRendererClient::RunScriptsAtDocumentStart(content::RenderFrame* render_frame) {
+  ExtensionFrameHelper* frame_helper = ExtensionFrameHelper::Get(render_frame);
+  if (!frame_helper)
+    return;  // The frame is invisible to extensions.
+
+  frame_helper->RunScriptsAtDocumentStart();
+  // |frame_helper| and |render_frame| might be dead by now.
+}
+
+void UserScriptsRendererClient::RunScriptsAtDocumentEnd(content::RenderFrame* render_frame) {
+  ExtensionFrameHelper* frame_helper = ExtensionFrameHelper::Get(render_frame);
+  if (!frame_helper)
+    return;  // The frame is invisible to extensions.
+
+  frame_helper->RunScriptsAtDocumentEnd();
+  // |frame_helper| and |render_frame| might be dead by now.
+}
+
+void UserScriptsRendererClient::RunScriptsAtDocumentIdle(content::RenderFrame* render_frame) {
+  ExtensionFrameHelper* frame_helper = ExtensionFrameHelper::Get(render_frame);
+  if (!frame_helper)
+    return;  // The frame is invisible to extensions.
+
+  frame_helper->RunScriptsAtDocumentIdle();
+  // |frame_helper| and |render_frame| might be dead by now.
+}
+
+}
\ No newline at end of file
diff --git a/components/user_scripts/renderer/user_scripts_renderer_client.h b/components/user_scripts/renderer/user_scripts_renderer_client.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/user_scripts_renderer_client.h
@@ -0,0 +1,33 @@
+#ifndef COMPONENTS_USER_SCRIPTS_RENDER_CLIENT_H_
+#define COMPONENTS_USER_SCRIPTS_RENDER_CLIENT_H_
+
+#include <memory>
+#include <string>
+
+#include "base/macros.h"
+#include "user_scripts_dispatcher.h"
+#include "services/service_manager/public/cpp/binder_registry.h"
+
+namespace user_scripts {
+
+class UserScriptsRendererClient {
+ public:
+  UserScriptsRendererClient();
+  ~UserScriptsRendererClient();
+
+  static UserScriptsRendererClient* GetInstance();
+
+  void RenderThreadStarted();
+  void RenderFrameCreated(content::RenderFrame* render_frame,
+    service_manager::BinderRegistry* registry);
+  void RunScriptsAtDocumentStart(content::RenderFrame* render_frame);
+  void RunScriptsAtDocumentEnd(content::RenderFrame* render_frame);
+  void RunScriptsAtDocumentIdle(content::RenderFrame* render_frame);
+
+ private:
+  std::unique_ptr<UserScriptsDispatcher> dispatcher_;
+};
+
+}
+
+#endif
\ No newline at end of file
diff --git a/components/user_scripts/renderer/web_ui_injection_host.cc b/components/user_scripts/renderer/web_ui_injection_host.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/web_ui_injection_host.cc
@@ -0,0 +1,35 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "web_ui_injection_host.h"
+
+WebUIInjectionHost::WebUIInjectionHost(const HostID& host_id)
+  : InjectionHost(host_id),
+    url_(host_id.id()) {
+}
+
+WebUIInjectionHost::~WebUIInjectionHost() {
+}
+
+const std::string* WebUIInjectionHost::GetContentSecurityPolicy() const {
+  // Use the main world CSP.
+  return nullptr;
+}
+
+const GURL& WebUIInjectionHost::url() const {
+  return url_;
+}
+
+const std::string& WebUIInjectionHost::name() const {
+  return id().id();
+}
+
+//extensions::PermissionsData::PageAccess WebUIInjectionHost::CanExecuteOnFrame(
+//    const GURL& document_url,
+//    content::RenderFrame* render_frame,
+//    int tab_id,
+//    bool is_declarative) const {
+//  // Content scripts are allowed to inject on webviews created by WebUI.
+//  return extensions::PermissionsData::PageAccess::kAllowed;
+//}
diff --git a/components/user_scripts/renderer/web_ui_injection_host.h b/components/user_scripts/renderer/web_ui_injection_host.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/renderer/web_ui_injection_host.h
@@ -0,0 +1,33 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_WEB_UI_INJECTION_HOST_H_
+#define EXTENSIONS_RENDERER_WEB_UI_INJECTION_HOST_H_
+
+#include "base/macros.h"
+#include "injection_host.h"
+
+class WebUIInjectionHost : public InjectionHost {
+ public:
+  WebUIInjectionHost(const HostID& host_id);
+  ~WebUIInjectionHost() override;
+
+ private:
+  // InjectionHost:
+  const std::string* GetContentSecurityPolicy() const override;
+  const GURL& url() const override;
+  const std::string& name() const override;
+//  extensions::PermissionsData::PageAccess CanExecuteOnFrame(
+//      const GURL& document_url,
+//      content::RenderFrame* render_frame,
+//      int tab_id,
+//      bool is_declarative) const override;
+
+ private:
+  GURL url_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebUIInjectionHost);
+};
+
+#endif  // EXTENSIONS_RENDERER_WEB_UI_INJECTION_HOST_H_
diff --git a/tools/gritsettings/resource_ids.spec b/tools/gritsettings/resource_ids.spec
--- a/tools/gritsettings/resource_ids.spec
+++ b/tools/gritsettings/resource_ids.spec
@@ -426,6 +426,9 @@
   "components/autofill/core/browser/autofill_address_rewriter_resources.grd":{
     "includes": [2880]
   },
+  "components/user_scripts/renderer/resources/user_scripts_renderer_resources.grd": {
+    "includes": [3000],
+  },
   # END components/ section.
 
   # START ios/ section.
-- 
2.17.1

