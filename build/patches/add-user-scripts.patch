From: root <root@ubuntu.cabponte>
Date: Fri, 6 Nov 2020 20:53:27 +0000
Subject: First version

---
 chrome/renderer/BUILD.gn                      |    1 +
 .../chrome_content_renderer_client.cc         |   11 +
 .../user_scripts/content/common/constants.cc  |  196 +++
 .../user_scripts/content/common/constants.h   |  304 +++++
 .../content/common/error_utils.cc             |   85 ++
 .../user_scripts/content/common/error_utils.h |   45 +
 .../content/common/extension_id.h             |   23 +
 .../common/extension_message_generator.cc     |   30 +
 .../common/extension_message_generator.h      |   16 +
 .../content/common/extension_messages.cc      |  358 ++++++
 .../content/common/extension_messages.h       | 1128 +++++++++++++++++
 .../user_scripts/content/common/host_id.cc    |   31 +
 .../user_scripts/content/common/host_id.h     |   35 +
 .../content/common/script_constants.h         |   33 +
 .../content/common/url_pattern.cc             |  807 ++++++++++++
 .../user_scripts/content/common/url_pattern.h |  301 +++++
 .../content/common/url_pattern_set.cc         |  327 +++++
 .../content/common/url_pattern_set.h          |  161 +++
 .../content/common/user_script.cc             |  337 +++++
 .../user_scripts/content/common/user_script.h |  357 ++++++
 .../user_scripts/content/common/view_type.cc  |   39 +
 .../user_scripts/content/common/view_type.h   |   48 +
 .../user_scripts/content/renderer/BUILD.gn    |   97 ++
 .../renderer/extension_frame_helper.cc        |  531 ++++++++
 .../content/renderer/extension_frame_helper.h |  204 +++
 .../content/renderer/injection_host.cc        |   12 +
 .../content/renderer/injection_host.h         |   50 +
 .../renderer/resources/greasemonkey_api.js    |   82 ++
 .../user_scripts_renderer_resources.grd       |   14 +
 .../content/renderer/script_context.cc        |  665 ++++++++++
 .../content/renderer/script_context.h         |  332 +++++
 .../content/renderer/script_injection.cc      |  412 ++++++
 .../content/renderer/script_injection.h       |  160 +++
 .../renderer/script_injection_callback.cc     |   26 +
 .../renderer/script_injection_callback.h      |   38 +
 .../renderer/script_injection_manager.cc      |  550 ++++++++
 .../renderer/script_injection_manager.h       |  119 ++
 .../content/renderer/script_injector.h        |  103 ++
 .../content/renderer/scripts_run_info.cc      |   78 ++
 .../content/renderer/scripts_run_info.h       |   70 +
 .../content/renderer/user_script_injector.cc  |  284 +++++
 .../content/renderer/user_script_injector.h   |   98 ++
 .../content/renderer/user_script_set.cc       |  293 +++++
 .../content/renderer/user_script_set.h        |  113 ++
 .../renderer/user_script_set_manager.cc       |  178 +++
 .../renderer/user_script_set_manager.h        |   76 ++
 .../renderer/user_scripts_dispatcher.cc       |   61 +
 .../renderer/user_scripts_dispatcher.h        |   51 +
 .../renderer/user_scripts_renderer_client.cc  |   72 ++
 .../renderer/user_scripts_renderer_client.h   |   33 +
 .../content/renderer/web_ui_injection_host.cc |   35 +
 .../content/renderer/web_ui_injection_host.h  |   33 +
 tools/gritsettings/resource_ids.spec          |    3 +
 53 files changed, 9546 insertions(+)
 create mode 100755 components/user_scripts/content/common/constants.cc
 create mode 100755 components/user_scripts/content/common/constants.h
 create mode 100755 components/user_scripts/content/common/error_utils.cc
 create mode 100755 components/user_scripts/content/common/error_utils.h
 create mode 100755 components/user_scripts/content/common/extension_id.h
 create mode 100755 components/user_scripts/content/common/extension_message_generator.cc
 create mode 100755 components/user_scripts/content/common/extension_message_generator.h
 create mode 100755 components/user_scripts/content/common/extension_messages.cc
 create mode 100755 components/user_scripts/content/common/extension_messages.h
 create mode 100755 components/user_scripts/content/common/host_id.cc
 create mode 100755 components/user_scripts/content/common/host_id.h
 create mode 100755 components/user_scripts/content/common/script_constants.h
 create mode 100755 components/user_scripts/content/common/url_pattern.cc
 create mode 100755 components/user_scripts/content/common/url_pattern.h
 create mode 100755 components/user_scripts/content/common/url_pattern_set.cc
 create mode 100755 components/user_scripts/content/common/url_pattern_set.h
 create mode 100755 components/user_scripts/content/common/user_script.cc
 create mode 100755 components/user_scripts/content/common/user_script.h
 create mode 100755 components/user_scripts/content/common/view_type.cc
 create mode 100755 components/user_scripts/content/common/view_type.h
 create mode 100755 components/user_scripts/content/renderer/BUILD.gn
 create mode 100755 components/user_scripts/content/renderer/extension_frame_helper.cc
 create mode 100755 components/user_scripts/content/renderer/extension_frame_helper.h
 create mode 100755 components/user_scripts/content/renderer/injection_host.cc
 create mode 100755 components/user_scripts/content/renderer/injection_host.h
 create mode 100755 components/user_scripts/content/renderer/resources/greasemonkey_api.js
 create mode 100755 components/user_scripts/content/renderer/resources/user_scripts_renderer_resources.grd
 create mode 100755 components/user_scripts/content/renderer/script_context.cc
 create mode 100755 components/user_scripts/content/renderer/script_context.h
 create mode 100755 components/user_scripts/content/renderer/script_injection.cc
 create mode 100755 components/user_scripts/content/renderer/script_injection.h
 create mode 100755 components/user_scripts/content/renderer/script_injection_callback.cc
 create mode 100755 components/user_scripts/content/renderer/script_injection_callback.h
 create mode 100755 components/user_scripts/content/renderer/script_injection_manager.cc
 create mode 100755 components/user_scripts/content/renderer/script_injection_manager.h
 create mode 100755 components/user_scripts/content/renderer/script_injector.h
 create mode 100755 components/user_scripts/content/renderer/scripts_run_info.cc
 create mode 100755 components/user_scripts/content/renderer/scripts_run_info.h
 create mode 100755 components/user_scripts/content/renderer/user_script_injector.cc
 create mode 100755 components/user_scripts/content/renderer/user_script_injector.h
 create mode 100755 components/user_scripts/content/renderer/user_script_set.cc
 create mode 100755 components/user_scripts/content/renderer/user_script_set.h
 create mode 100755 components/user_scripts/content/renderer/user_script_set_manager.cc
 create mode 100755 components/user_scripts/content/renderer/user_script_set_manager.h
 create mode 100755 components/user_scripts/content/renderer/user_scripts_dispatcher.cc
 create mode 100755 components/user_scripts/content/renderer/user_scripts_dispatcher.h
 create mode 100755 components/user_scripts/content/renderer/user_scripts_renderer_client.cc
 create mode 100755 components/user_scripts/content/renderer/user_scripts_renderer_client.h
 create mode 100755 components/user_scripts/content/renderer/web_ui_injection_host.cc
 create mode 100755 components/user_scripts/content/renderer/web_ui_injection_host.h

diff --git a/chrome/renderer/BUILD.gn b/chrome/renderer/BUILD.gn
--- a/chrome/renderer/BUILD.gn
+++ b/chrome/renderer/BUILD.gn
@@ -147,6 +147,7 @@ static_library("renderer") {
     "//components/contextual_search/content:renderer",
     "//components/data_reduction_proxy/core/common",
     "//components/dom_distiller/content/renderer",
+    "//components/user_scripts/content/renderer",
     "//components/network_hints/renderer",
     "//components/omnibox/common",
     "//components/page_image_annotation/content/renderer",
diff --git a/chrome/renderer/chrome_content_renderer_client.cc b/chrome/renderer/chrome_content_renderer_client.cc
--- a/chrome/renderer/chrome_content_renderer_client.cc
+++ b/chrome/renderer/chrome_content_renderer_client.cc
@@ -166,6 +166,7 @@
 
 #if defined(OS_ANDROID)
 #include "chrome/renderer/sandbox_status_extension_android.h"
+#include "components/user_scripts/content/renderer/user_scripts_renderer_client.h"
 #else
 #include "chrome/renderer/media/chrome_speech_recognition_client.h"
 #include "chrome/renderer/searchbox/search_bouncer.h"
@@ -361,6 +362,8 @@ void ChromeContentRendererClient::RenderThreadStarted() {
   ChromeExtensionsRendererClient::GetInstance()->RenderThreadStarted();
 #endif
 
+  user_scripts::UserScriptsRendererClient::GetInstance()->RenderThreadStarted();
+
 #if BUILDFLAG(ENABLE_SPELLCHECK)
   if (!spellcheck_)
     InitSpellCheck();
@@ -499,6 +502,8 @@ void ChromeContentRendererClient::RenderFrameCreated(
   ChromeExtensionsRendererClient::GetInstance()->RenderFrameCreated(
       render_frame, registry);
 #endif
+  user_scripts::UserScriptsRendererClient::GetInstance()->RenderFrameCreated(
+      render_frame, registry);
 
 #if BUILDFLAG(ENABLE_PLUGINS)
   new PepperHelper(render_frame);
@@ -1466,6 +1471,8 @@ void ChromeContentRendererClient::RunScriptsAtDocumentStart(
       render_frame);
   // |render_frame| might be dead by now.
 #endif
+  user_scripts::UserScriptsRendererClient::GetInstance()->RunScriptsAtDocumentStart(
+      render_frame);
 }
 
 void ChromeContentRendererClient::RunScriptsAtDocumentEnd(
@@ -1475,6 +1482,8 @@ void ChromeContentRendererClient::RunScriptsAtDocumentEnd(
       render_frame);
   // |render_frame| might be dead by now.
 #endif
+  user_scripts::UserScriptsRendererClient::GetInstance()->RunScriptsAtDocumentEnd(
+      render_frame);
 }
 
 void ChromeContentRendererClient::RunScriptsAtDocumentIdle(
@@ -1484,6 +1493,8 @@ void ChromeContentRendererClient::RunScriptsAtDocumentIdle(
       render_frame);
   // |render_frame| might be dead by now.
 #endif
+  user_scripts::UserScriptsRendererClient::GetInstance()->RunScriptsAtDocumentIdle(
+      render_frame);
 }
 
 void ChromeContentRendererClient::
diff --git a/components/user_scripts/content/common/constants.cc b/components/user_scripts/content/common/constants.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/constants.cc
@@ -0,0 +1,196 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "constants.h"
+
+#include "base/stl_util.h"
+#include "base/strings/string_piece.h"
+#include "build/chromecast_buildflags.h"
+
+namespace user_scripts {
+
+// const char kExtensionScheme[] = "chrome-extension";
+
+// const base::FilePath::CharType kManifestFilename[] =
+//     FILE_PATH_LITERAL("manifest.json");
+// const base::FilePath::CharType kDifferentialFingerprintFilename[] =
+//     FILE_PATH_LITERAL("manifest.fingerprint");
+// const base::FilePath::CharType kLocaleFolder[] =
+//     FILE_PATH_LITERAL("_locales");
+// const base::FilePath::CharType kMessagesFilename[] =
+//     FILE_PATH_LITERAL("messages.json");
+// const base::FilePath::CharType kGzippedMessagesFilename[] =
+//     FILE_PATH_LITERAL("messages.json.gz");
+// const base::FilePath::CharType kPlatformSpecificFolder[] =
+//     FILE_PATH_LITERAL("_platform_specific");
+// const base::FilePath::CharType kMetadataFolder[] =
+//     FILE_PATH_LITERAL("_metadata");
+// const base::FilePath::CharType kVerifiedContentsFilename[] =
+//     FILE_PATH_LITERAL("verified_contents.json");
+// const base::FilePath::CharType kComputedHashesFilename[] =
+//     FILE_PATH_LITERAL("computed_hashes.json");
+// const base::FilePath::CharType kIndexedRulesetDirectory[] =
+//     FILE_PATH_LITERAL("generated_indexed_rulesets");
+
+// const char kInstallDirectoryName[] = "Extensions";
+
+// const char kTempExtensionName[] = "CRX_INSTALL";
+
+// const char kDecodedMessageCatalogsFilename[] = "DECODED_MESSAGE_CATALOGS";
+
+// const char kGeneratedBackgroundPageFilename[] =
+//     "_generated_background_page.html";
+
+// const char kModulesDir[] = "_modules";
+
+// const base::FilePath::CharType kExtensionFileExtension[] =
+//     FILE_PATH_LITERAL(".crx");
+// const base::FilePath::CharType kExtensionKeyFileExtension[] =
+//     FILE_PATH_LITERAL(".pem");
+
+// // If auto-updates are turned on, default to running every 5 hours.
+// const int kDefaultUpdateFrequencySeconds = 60 * 60 * 5;
+
+// const char kLocalAppSettingsDirectoryName[] = "Local App Settings";
+// const char kLocalExtensionSettingsDirectoryName[] = "Local Extension Settings";
+// const char kSyncAppSettingsDirectoryName[] = "Sync App Settings";
+// const char kSyncExtensionSettingsDirectoryName[] = "Sync Extension Settings";
+// const char kManagedSettingsDirectoryName[] = "Managed Extension Settings";
+// const char kStateStoreName[] = "Extension State";
+// const char kRulesStoreName[] = "Extension Rules";
+// const char kWebStoreAppId[] = "ahfgeienlihckogmohjhadlkjgocpleb";
+
+// const uint8_t kWebstoreSignaturesPublicKey[] = {
+//     0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,
+//     0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00,
+//     0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0x8f, 0xfb, 0xbf,
+//     0x5c, 0x37, 0x63, 0x94, 0x3c, 0xb0, 0xee, 0x01, 0xc4, 0xb5, 0xa6, 0x9a,
+//     0xb1, 0x9f, 0x46, 0x74, 0x6f, 0x16, 0x38, 0xa0, 0x32, 0x27, 0x35, 0xdd,
+//     0xf0, 0x71, 0x6b, 0x0e, 0xdc, 0xf6, 0x25, 0xcb, 0xb2, 0xed, 0xea, 0xfb,
+//     0x32, 0xd5, 0xaf, 0x1e, 0x03, 0x43, 0x03, 0x46, 0xf0, 0xa7, 0x39, 0xdb,
+//     0x23, 0x96, 0x1d, 0x65, 0xe5, 0x78, 0x51, 0xf0, 0x84, 0xb0, 0x0e, 0x12,
+//     0xac, 0x0e, 0x5b, 0xdc, 0xc9, 0xd6, 0x4c, 0x7c, 0x00, 0xd5, 0xb8, 0x1b,
+//     0x88, 0x33, 0x3e, 0x2f, 0xda, 0xeb, 0xaa, 0xf7, 0x1a, 0x75, 0xc2, 0xae,
+//     0x3a, 0x54, 0xde, 0x37, 0x8f, 0x10, 0xd2, 0x28, 0xe6, 0x84, 0x79, 0x4d,
+//     0x15, 0xb4, 0xf3, 0xbd, 0x3f, 0x56, 0xd3, 0x3c, 0x3f, 0x18, 0xab, 0xfc,
+//     0x2e, 0x05, 0xc0, 0x1e, 0x08, 0x31, 0xb6, 0x61, 0xd0, 0xfd, 0x9f, 0x4f,
+//     0x3f, 0x64, 0x0d, 0x17, 0x93, 0xbc, 0xad, 0x41, 0xc7, 0x48, 0xbe, 0x00,
+//     0x27, 0xa8, 0x4d, 0x70, 0x42, 0x92, 0x05, 0x54, 0xa6, 0x6d, 0xb8, 0xde,
+//     0x56, 0x6e, 0x20, 0x49, 0x70, 0xee, 0x10, 0x3e, 0x6b, 0xd2, 0x7c, 0x31,
+//     0xbd, 0x1b, 0x6e, 0xa4, 0x3c, 0x46, 0x62, 0x9f, 0x08, 0x66, 0x93, 0xf9,
+//     0x2a, 0x51, 0x31, 0xa8, 0xdb, 0xb5, 0x9d, 0xb9, 0x0f, 0x73, 0xe8, 0xa0,
+//     0x09, 0x32, 0x01, 0xe9, 0x7b, 0x2a, 0x8a, 0x36, 0xa0, 0xcf, 0x17, 0xb0,
+//     0x50, 0x70, 0x9d, 0xa2, 0xf9, 0xa4, 0x6f, 0x62, 0x4d, 0xb6, 0xc9, 0x31,
+//     0xfc, 0xf3, 0x08, 0x12, 0xff, 0x93, 0xbd, 0x62, 0x31, 0xd8, 0x1c, 0xea,
+//     0x1a, 0x9e, 0xf5, 0x81, 0x28, 0x7f, 0x75, 0x5e, 0xd2, 0x27, 0x7a, 0xc2,
+//     0x96, 0xf5, 0x9d, 0xdb, 0x18, 0xfc, 0x76, 0xdc, 0x46, 0xf0, 0x57, 0xc0,
+//     0x58, 0x34, 0xc8, 0x22, 0x2d, 0x2a, 0x65, 0x75, 0xa7, 0xd9, 0x08, 0x62,
+//     0xcd, 0x02, 0x03, 0x01, 0x00, 0x01};
+
+// const size_t kWebstoreSignaturesPublicKeySize =
+//     base::size(kWebstoreSignaturesPublicKey);
+
+// const int kMainThreadId = 0;
+
+// const char kMimeTypeJpeg[] = "image/jpeg";
+// const char kMimeTypePng[] = "image/png";
+
+}  // namespace extensions
+
+// namespace extension_misc {
+
+// #if defined(OS_CHROMEOS) || BUILDFLAG(IS_CHROMECAST)
+// // The extension id for the built-in component extension.
+// const char kChromeVoxExtensionId[] = "mndnfokpggljbaajbnioimlmbfngpief";
+// #else
+// // The extension id for the web store extension.
+// const char kChromeVoxExtensionId[] = "kgejglhpjiefppelpmljglcjbhoiplfn";
+// #endif
+// const char kFeedbackExtensionId[] = "gfdkimpbcpahaombhbimeihdjnejgicl";
+// const char kPdfExtensionId[] = "mhjfbmdgcfjbbpaeojofohoefgiehjai";
+// const char kQuickOfficeComponentExtensionId[] =
+//     "bpmcpldpdmajfigpchkicefoigmkfalc";
+// const char kQuickOfficeInternalExtensionId[] =
+//     "ehibbfinohgbchlgdbfpikodjaojhccn";
+// const char kQuickOfficeExtensionId[] = "gbkeegbaiigmenfmjfclcdgdpimamgkj";
+// const char kMimeHandlerPrivateTestExtensionId[] =
+//     "oickdpebdnfbgkcaoklfcdhjniefkcji";
+// const char kCameraAppId[] = "hfhhnacclhffhdffklopdkcgdhifgngh";
+// const char kCameraAppDevId[] = "flgnmkgjffmkephdokeeliiopbjaafpm";
+// const char kChromeAppId[] = "mgndgikekgjfcpckkfioiadnlibdjbkf";
+// // Generated by: echo "lacros-chrome" | sha256sum | head -c32 | tr 0-9a-f a-p
+// const char kLacrosAppId[] = "jaimifaeiicidiikhmjedcgdimealfbh";
+// const char kFilesManagerAppId[] = "hhaomjibdihmijegdhdafkllkbggdgoj";
+// const char kCalculatorAppId[] = "joodangkbfjnajiiifokapkpmhfnpleo";
+// const char kCalendarDemoAppId[] = "fpgfohogebplgnamlafljlcidjedbdeb";
+// const char kGMailAppId[] = "pjkljhegncpnkpknbcohdijeoejaedia";
+// const char kGoogleDocsDemoAppId[] = "chdaoodbokekbiiphekbfjdmiodccljl";
+// const char kGoogleDriveAppId[] = "apdfllckaahabafndbhieahigkjlhalf";
+// const char kGoogleSheetsDemoAppId[] = "nifkmgcdokhkjghdlgflonppnefddien";
+// const char kGoogleSlidesDemoAppId[] = "hdmobeajeoanbanmdlabnbnlopepchip";
+// const char kGoogleKeepAppId[] = "hmjkmjkepdijhoojdojkdfohbdgmmhki";
+// const char kYoutubeAppId[] = "blpcfgokakmgnkcojhhkbfbldkacnbeo";
+// const char kGeniusAppId[] = "ljoammodoonkhnehlncldjelhidljdpi";
+
+// #if defined(OS_CHROMEOS)
+// // TODO(michaelpg): Deprecate old app IDs before adding new ones to avoid bloat.
+// const char kHighlightsAppId[] = "lpmakjfjcconjeehbidjclhdlpjmfjjj";
+// const char kHighlightsEveAppId[] = "iggildboghmjpbjcpmobahnkmoefkike";
+// const char kHighlightsNocturneAppId[] = "elhbopodaklenjkeihkdhhfaghalllba";
+// const char kHighlightsAtlasAppId[] = "gjeelkjnolfmhphfhhjokaijbicopfln";
+// const char kScreensaverAppId[] = "mnoijifedipmbjaoekhadjcijipaijjc";
+// const char kScreensaverEveAppId[] = "gdobaoeekhiklaljmhladjfdfkigampc";
+// const char kScreensaverNocturneAppId[] = "lminefdanffajachfahfpmphfkhahcnj";
+// const char kScreensaverAtlasAppId[] = "bnabjkecnachpogjlfilfcnlpcmacglh";
+// const char kScreensaverKukuiAppId[] = "fafhbhdboeiciklpkminlncemohljlkj";
+// const char kSigninProfileTestExtensionId[] = "mecfefiddjlmabpeilblgegnbioikfmp";
+
+// bool IsSystemUIApp(base::StringPiece extension_id) {
+//   static const char* const kApps[] = {
+//       // clang-format off
+//       kCameraAppId,
+//       kChromeVoxExtensionId,
+//       kFeedbackExtensionId,
+//       kFilesManagerAppId,
+//       kHighlightsEveAppId,
+//       kHighlightsNocturneAppId,
+//       kHighlightsAtlasAppId,
+//       kHighlightsAppId,
+//       kScreensaverEveAppId,
+//       kScreensaverNocturneAppId,
+//       kScreensaverAtlasAppId,
+//       kScreensaverAppId,
+//       // clang-format on
+//   };
+//   for (const char* id : kApps) {
+//     if (extension_id == id)
+//       return true;
+//   }
+//   return false;
+// }
+// #endif  // defined(OS_CHROMEOS)
+
+// const char kProdHangoutsExtensionId[] = "nckgahadagoaajjgafhacjanaoiihapd";
+// const char* const kHangoutsExtensionIds[6] = {
+//     kProdHangoutsExtensionId,
+//     "ljclpkphhpbpinifbeabbhlfddcpfdde",  // Debug.
+//     "ppleadejekpmccmnpjdimmlfljlkdfej",  // Alpha.
+//     "eggnbpckecmjlblplehfpjjdhhidfdoj",  // Beta.
+//     "jfjjdfefebklmdbmenmlehlopoocnoeh",  // Packaged App Debug.
+//     "knipolnnllmklapflnccelgolnpehhpl"   // Packaged App Prod.
+//     // Keep in sync with _api_features.json and _manifest_features.json.
+// };
+
+// // Error returned when scripting of a page is denied due to enterprise policy.
+// const char kPolicyBlockedScripting[] =
+//     "This page cannot be scripted due to an ExtensionsSettings policy.";
+
+// const int kContentVerificationDefaultBlockSize = 4096;
+
+// const logging::LogSeverity kMinimumSeverityToReportError = logging::LOG_WARNING;
+
+// const char kCastExtensionIdRelease[] = "pkedcjkdefgpdelpbcmbmeomcjbeemfm";
+// const char kCastExtensionIdDev[] = "enhhojjnijigcajfphajepfemndkmdlo";
+
+// }  // namespace extension_misc
diff --git a/components/user_scripts/content/common/constants.h b/components/user_scripts/content/common/constants.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/constants.h
@@ -0,0 +1,304 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_COMMON_CONSTANTS_H_
+#define EXTENSIONS_COMMON_CONSTANTS_H_
+
+#include "base/files/file_path.h"
+#include "base/strings/string_piece_forward.h"
+#include "components/services/app_service/public/mojom/types.mojom.h"
+#include "components/version_info/channel.h"
+#include "ui/base/layout.h"
+
+namespace user_scripts {
+
+// // Scheme we serve extension content from.
+// extern const char kExtensionScheme[];
+
+// // The name of the manifest inside an extension.
+// extern const base::FilePath::CharType kManifestFilename[];
+
+// // The name of the differential fingerprint file inside an extension.
+// extern const base::FilePath::CharType kDifferentialFingerprintFilename[];
+
+// // The name of locale folder inside an extension.
+// extern const base::FilePath::CharType kLocaleFolder[];
+
+// // The name of the messages file inside an extension.
+// extern const base::FilePath::CharType kMessagesFilename[];
+
+// // The name of the gzipped messages file inside an extension.
+// extern const base::FilePath::CharType kGzippedMessagesFilename[];
+
+// // The base directory for subdirectories with platform-specific code.
+// extern const base::FilePath::CharType kPlatformSpecificFolder[];
+
+// // A directory reserved for metadata, generated either by the webstore
+// // or chrome.
+// extern const base::FilePath::CharType kMetadataFolder[];
+
+// // Name of the verified contents file within the metadata folder.
+// extern const base::FilePath::CharType kVerifiedContentsFilename[];
+
+// // Name of the computed hashes file within the metadata folder.
+// extern const base::FilePath::CharType kComputedHashesFilename[];
+
+// // Name of the indexed ruleset directory for the Declarative Net Request API.
+// extern const base::FilePath::CharType kIndexedRulesetDirectory[];
+
+// // The name of the directory inside the profile where extensions are
+// // installed to.
+// extern const char kInstallDirectoryName[];
+
+// // The name of a temporary directory to install an extension into for
+// // validation before finalizing install.
+// extern const char kTempExtensionName[];
+
+// // The file to write our decoded message catalogs to, relative to the
+// // extension_path.
+// extern const char kDecodedMessageCatalogsFilename[];
+
+// // The filename to use for a background page generated from
+// // background.scripts.
+// extern const char kGeneratedBackgroundPageFilename[];
+
+// // Path to imported modules.
+// extern const char kModulesDir[];
+
+// // The file extension (.crx) for extensions.
+// extern const base::FilePath::CharType kExtensionFileExtension[];
+
+// // The file extension (.pem) for private key files.
+// extern const base::FilePath::CharType kExtensionKeyFileExtension[];
+
+// // Default frequency for auto updates, if turned on.
+// extern const int kDefaultUpdateFrequencySeconds;
+
+// // The name of the directory inside the profile where per-app local settings
+// // are stored.
+// extern const char kLocalAppSettingsDirectoryName[];
+
+// // The name of the directory inside the profile where per-extension local
+// // settings are stored.
+// extern const char kLocalExtensionSettingsDirectoryName[];
+
+// // The name of the directory inside the profile where per-app synced settings
+// // are stored.
+// extern const char kSyncAppSettingsDirectoryName[];
+
+// // The name of the directory inside the profile where per-extension synced
+// // settings are stored.
+// extern const char kSyncExtensionSettingsDirectoryName[];
+
+// // The name of the directory inside the profile where per-extension persistent
+// // managed settings are stored.
+// extern const char kManagedSettingsDirectoryName[];
+
+// // The name of the database inside the profile where chrome-internal
+// // extension state resides.
+// extern const char kStateStoreName[];
+
+// // The name of the database inside the profile where declarative extension
+// // rules are stored.
+// extern const char kRulesStoreName[];
+
+// // The URL query parameter key corresponding to multi-login user index.
+// extern const char kAuthUserQueryKey[];
+
+// // Mime type strings
+// extern const char kMimeTypeJpeg[];
+// extern const char kMimeTypePng[];
+
+// // The extension id of the Web Store component application.
+// extern const char kWebStoreAppId[];
+
+// // The key used for signing some pieces of data from the webstore.
+// extern const uint8_t kWebstoreSignaturesPublicKey[];
+// extern const size_t kWebstoreSignaturesPublicKeySize;
+
+// // Thread identifier for the main renderer thread (as opposed to a service
+// // worker thread).
+// // This is the default thread id used for extension event listeners registered
+// // from a non-service worker context
+// extern const int kMainThreadId;
+
+// using apps::mojom::AppLaunchSource;
+// using apps::mojom::LaunchContainer;
+
+// // This enum is used for the launch type the user wants to use for an
+// // application.
+// // Do not remove items or re-order this enum as it is used in preferences
+// // and histograms.
+// enum LaunchType {
+//   LAUNCH_TYPE_INVALID = -1,
+//   LAUNCH_TYPE_FIRST = 0,
+//   LAUNCH_TYPE_PINNED = LAUNCH_TYPE_FIRST,
+//   LAUNCH_TYPE_REGULAR = 1,
+//   LAUNCH_TYPE_FULLSCREEN = 2,
+//   LAUNCH_TYPE_WINDOW = 3,
+//   NUM_LAUNCH_TYPES,
+
+//   // Launch an app in the in the way a click on the NTP would,
+//   // if no user pref were set.  Update this constant to change
+//   // the default for the NTP and chrome.management.launchApp().
+//   LAUNCH_TYPE_DEFAULT = LAUNCH_TYPE_REGULAR
+// };
+
+// // The origin of injected CSS.
+enum CSSOrigin { CSS_ORIGIN_AUTHOR, CSS_ORIGIN_USER };
+// static const CSSOrigin CSS_ORIGIN_LAST = CSS_ORIGIN_USER;
+
+}  // namespace extensions
+
+// namespace extension_misc {
+
+// // Matches chrome.tabs.TAB_ID_NONE.
+// const int kUnknownTabId = -1;
+
+// // Matches chrome.windows.WINDOW_ID_NONE.
+// const int kUnknownWindowId = -1;
+
+// // Matches chrome.windows.WINDOW_ID_CURRENT.
+// const int kCurrentWindowId = -2;
+
+// enum ExtensionIcons {
+//   EXTENSION_ICON_GIGANTOR = 512,
+//   EXTENSION_ICON_EXTRA_LARGE = 256,
+//   EXTENSION_ICON_LARGE = 128,
+//   EXTENSION_ICON_MEDIUM = 48,
+//   EXTENSION_ICON_SMALL = 32,
+//   EXTENSION_ICON_SMALLISH = 24,
+//   EXTENSION_ICON_BITTY = 16,
+//   EXTENSION_ICON_INVALID = 0,
+// };
+
+// // The extension id of the ChromeVox extension.
+// extern const char kChromeVoxExtensionId[];
+
+// // The extension id of the feedback component extension.
+// extern const char kFeedbackExtensionId[];
+
+// // The extension id of the PDF extension.
+// extern const char kPdfExtensionId[];
+
+// // The extension id of the Office Viewer component extension.
+// extern const char kQuickOfficeComponentExtensionId[];
+
+// // The extension id of the Office Viewer extension on the internal webstore.
+// extern const char kQuickOfficeInternalExtensionId[];
+
+// // The extension id of the Office Viewer extension.
+// extern const char kQuickOfficeExtensionId[];
+
+// // The extension id used for testing mimeHandlerPrivate.
+// extern const char kMimeHandlerPrivateTestExtensionId[];
+
+// // The extension id of the Camera application.
+// extern const char kCameraAppId[];
+
+// // The extension id of the devoloper version of Camera application.
+// extern const char kCameraAppDevId[];
+
+// // The extension id of the Chrome component application.
+// extern const char kChromeAppId[];
+
+// // Fake extension ID for the Lacros chrome browser application.
+// extern const char kLacrosAppId[];
+
+// // The extension id of the Files Manager application.
+// extern const char kFilesManagerAppId[];
+
+// // The extension id of the Calculator application.
+// extern const char kCalculatorAppId[];
+
+// // The extension id of the demo Calendar application.
+// extern const char kCalendarDemoAppId[];
+
+// // The extension id of the GMail application.
+// extern const char kGMailAppId[];
+
+// // The extension id of the demo Google Docs application.
+// extern const char kGoogleDocsDemoAppId[];
+
+// // The extension id of the Google Drive application.
+// extern const char kGoogleDriveAppId[];
+
+// // The extension id of the demo Google Sheets application.
+// extern const char kGoogleSheetsDemoAppId[];
+
+// // The extension id of the demo Google Slides application.
+// extern const char kGoogleSlidesDemoAppId[];
+
+// // The extension id of the Google Keep application.
+// extern const char kGoogleKeepAppId[];
+
+// // The extension id of the Youtube application.
+// extern const char kYoutubeAppId[];
+
+// // The extension id of the genius (Get Help) app.
+// extern const char kGeniusAppId[];
+
+// #if defined(OS_CHROMEOS)
+// // The extension id of the default Demo Mode Highlights app.
+// extern const char kHighlightsAppId[];
+
+// // The extension id of the eve Demo Mode Highlights app.
+// extern const char kHighlightsEveAppId[];
+
+// // The extension id of the nocturne Demo Mode Highlights app.
+// extern const char kHighlightsNocturneAppId[];
+
+// // The extension id of the atlas Demo Mode Highlights app.
+// extern const char kHighlightsAtlasAppId[];
+
+// // The extension id of the default Demo Mode screensaver app.
+// extern const char kScreensaverAppId[];
+
+// // The extension id of the eve Demo Mode screensaver app.
+// extern const char kScreensaverEveAppId[];
+
+// // The extension id of the nocturne Demo Mode screensaver app.
+// extern const char kScreensaverNocturneAppId[];
+
+// // The extension id of the atlas Demo Mode screensaver app.
+// extern const char kScreensaverAtlasAppId[];
+
+// // The extension id of the kukui Demo Mode screensaver app.
+// extern const char kScreensaverKukuiAppId[];
+
+// // The id of the testing extension allowed in the signin profile.
+// extern const char kSigninProfileTestExtensionId[];
+
+// // Returns true if this app is part of the "system UI". Generally this is UI
+// // that that on other operating systems would be considered part of the OS,
+// // for example the file manager.
+// bool IsSystemUIApp(base::StringPiece extension_id);
+// #endif
+
+// // The extension id for the production version of Hangouts.
+// extern const char kProdHangoutsExtensionId[];
+
+// // Extension ids used by Hangouts.
+// extern const char* const kHangoutsExtensionIds[6];
+
+// // Error message when enterprise policy blocks scripting of webpage.
+// extern const char kPolicyBlockedScripting[];
+
+// // The default block size for hashing used in content verification.
+// extern const int kContentVerificationDefaultBlockSize;
+
+// // The minimum severity of a log or error in order to report it to the browser.
+// extern const logging::LogSeverity kMinimumSeverityToReportError;
+
+// // The minimum channel where Service Worker based extensions can run.
+// constexpr version_info::Channel kMinChannelForServiceWorkerBasedExtension =
+//     version_info::Channel::DEV;
+
+// // IDs for the Media Router Component Extension.
+// extern const char kCastExtensionIdRelease[];
+// extern const char kCastExtensionIdDev[];
+
+// }  // namespace extension_misc
+
+#endif  // EXTENSIONS_COMMON_CONSTANTS_H_
diff --git a/components/user_scripts/content/common/error_utils.cc b/components/user_scripts/content/common/error_utils.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/error_utils.cc
@@ -0,0 +1,85 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "error_utils.h"
+
+#include <initializer_list>
+
+#include "base/check_op.h"
+#include "base/strings/string_tokenizer.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+
+namespace user_scripts {
+
+namespace {
+
+std::string FormatErrorMessageInternal(
+    base::StringPiece format,
+    std::initializer_list<base::StringPiece> args) {
+  std::string format_str = format.as_string();
+  base::StringTokenizer tokenizer(format_str, "*");
+  tokenizer.set_options(base::StringTokenizer::RETURN_DELIMS);
+
+  std::vector<base::StringPiece> result_pieces;
+  auto* args_it = args.begin();
+  while (tokenizer.GetNext()) {
+    if (!tokenizer.token_is_delim()) {
+      result_pieces.push_back(tokenizer.token_piece());
+      continue;
+    }
+
+    CHECK_NE(args_it, args.end())
+        << "More placeholders (*) than substitutions.";
+
+    // Substitute the argument.
+    result_pieces.push_back(*args_it);
+    args_it++;
+  }
+
+  // Not all substitutions were consumed.
+  CHECK_EQ(args_it, args.end()) << "Fewer placeholders (*) than substitutions.";
+
+  return base::JoinString(result_pieces, "" /* separator */);
+}
+
+}  // namespace
+
+std::string ErrorUtils::FormatErrorMessage(base::StringPiece format,
+                                           base::StringPiece s1) {
+  return FormatErrorMessageInternal(format, {s1});
+}
+
+// std::string ErrorUtils::FormatErrorMessage(base::StringPiece format,
+//                                            base::StringPiece s1,
+//                                            base::StringPiece s2) {
+//   return FormatErrorMessageInternal(format, {s1, s2});
+// }
+
+// std::string ErrorUtils::FormatErrorMessage(base::StringPiece format,
+//                                            base::StringPiece s1,
+//                                            base::StringPiece s2,
+//                                            base::StringPiece s3) {
+//   return FormatErrorMessageInternal(format, {s1, s2, s3});
+// }
+
+// base::string16 ErrorUtils::FormatErrorMessageUTF16(base::StringPiece format,
+//                                                    base::StringPiece s1) {
+//   return base::UTF8ToUTF16(FormatErrorMessageInternal(format, {s1}));
+// }
+
+// base::string16 ErrorUtils::FormatErrorMessageUTF16(base::StringPiece format,
+//                                                    base::StringPiece s1,
+//                                                    base::StringPiece s2) {
+//   return base::UTF8ToUTF16(FormatErrorMessageInternal(format, {s1, s2}));
+// }
+
+// base::string16 ErrorUtils::FormatErrorMessageUTF16(base::StringPiece format,
+//                                                    base::StringPiece s1,
+//                                                    base::StringPiece s2,
+//                                                    base::StringPiece s3) {
+//   return base::UTF8ToUTF16(FormatErrorMessageInternal(format, {s1, s2, s3}));
+// }
+
+}  // namespace extensions
diff --git a/components/user_scripts/content/common/error_utils.h b/components/user_scripts/content/common/error_utils.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/error_utils.h
@@ -0,0 +1,45 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_COMMON_ERROR_UTILS_H_
+#define EXTENSIONS_COMMON_ERROR_UTILS_H_
+
+#include <string>
+
+#include "base/strings/string16.h"
+#include "base/strings/string_piece.h"
+
+namespace user_scripts {
+
+class ErrorUtils {
+ public:
+  // Creates an error messages from a pattern.
+   static std::string FormatErrorMessage(base::StringPiece format,
+                                         base::StringPiece s1);
+
+//   static std::string FormatErrorMessage(base::StringPiece format,
+//                                         base::StringPiece s1,
+//                                         base::StringPiece s2);
+
+//   static std::string FormatErrorMessage(base::StringPiece format,
+//                                         base::StringPiece s1,
+//                                         base::StringPiece s2,
+//                                         base::StringPiece s3);
+
+//   static base::string16 FormatErrorMessageUTF16(base::StringPiece format,
+//                                                 base::StringPiece s1);
+
+//   static base::string16 FormatErrorMessageUTF16(base::StringPiece format,
+//                                                 base::StringPiece s1,
+//                                                 base::StringPiece s2);
+
+//   static base::string16 FormatErrorMessageUTF16(base::StringPiece format,
+//                                                 base::StringPiece s1,
+//                                                 base::StringPiece s2,
+//                                                 base::StringPiece s3);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_COMMON_ERROR_UTILS_H_
diff --git a/components/user_scripts/content/common/extension_id.h b/components/user_scripts/content/common/extension_id.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/extension_id.h
@@ -0,0 +1,23 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_COMMON_EXTENSION_ID_H_
+#define EXTENSIONS_COMMON_EXTENSION_ID_H_
+
+#include <set>
+#include <string>
+#include <vector>
+
+namespace user_scripts {
+
+// // If valid, uniquely identifies an Extension using 32 characters from the
+// // alphabet 'a'-'p'.
+// using ExtensionId = std::string;
+
+// using ExtensionIdList = std::vector<ExtensionId>;
+// using ExtensionIdSet = std::set<ExtensionId>;
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_COMMON_EXTENSION_ID_H_
diff --git a/components/user_scripts/content/common/extension_message_generator.cc b/components/user_scripts/content/common/extension_message_generator.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/extension_message_generator.cc
@@ -0,0 +1,30 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Get basic type definitions.
+#define IPC_MESSAGE_IMPL
+#include "components/user_scripts/content/common/extension_message_generator.h"
+
+// Generate constructors.
+#include "ipc/struct_constructor_macros.h"
+#include "components/user_scripts/content/common/extension_message_generator.h"
+
+// Generate param traits write methods.
+#include "ipc/param_traits_write_macros.h"
+namespace IPC {
+#include "components/user_scripts/content/common/extension_message_generator.h"
+}  // namespace IPC
+
+// Generate param traits read methods.
+#include "ipc/param_traits_read_macros.h"
+namespace IPC {
+#include "components/user_scripts/content/common/extension_message_generator.h"
+}  // namespace IPC
+
+// Generate param traits log methods.
+#include "ipc/param_traits_log_macros.h"
+namespace IPC {
+#include "components/user_scripts/content/common/extension_message_generator.h"
+}  // namespace IPC
+
diff --git a/components/user_scripts/content/common/extension_message_generator.h b/components/user_scripts/content/common/extension_message_generator.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/extension_message_generator.h
@@ -0,0 +1,16 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Multiply-included file, hence no include guard.
+
+#undef EXTENSIONS_COMMON_EXTENSION_MESSAGES_H_
+#include "components/user_scripts/content/common/extension_messages.h"
+#ifndef EXTENSIONS_COMMON_EXTENSION_MESSAGES_H_
+#error "Failed to include header components/user_scripts/content/common/extension_messages.h"
+#endif
+// #undef EXTENSIONS_COMMON_GUEST_VIEW_EXTENSIONS_GUEST_VIEW_MESSAGES_H_
+// #include "extensions/common/guest_view/extensions_guest_view_messages.h"
+// #ifndef EXTENSIONS_COMMON_GUEST_VIEW_EXTENSIONS_GUEST_VIEW_MESSAGES_H_
+// #error "Failed to include header extensions_guest_view_messages.h"
+// #endif
diff --git a/components/user_scripts/content/common/extension_messages.cc b/components/user_scripts/content/common/extension_messages.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/extension_messages.cc
@@ -0,0 +1,358 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "extension_messages.h"
+
+#include <stddef.h>
+
+#include <memory>
+#include <utility>
+
+#include "content/public/common/common_param_traits.h"
+// #include "extensions/common/extension.h"
+// #include "extensions/common/manifest.h"
+// #include "extensions/common/manifest_handler.h"
+// #include "extensions/common/permissions/permissions_data.h"
+// #include "extensions/common/permissions/permissions_info.h"
+
+// using extensions::ActivationSequence;
+// using extensions::APIPermission;
+// using extensions::APIPermissionInfo;
+// using extensions::APIPermissionSet;
+// using extensions::Extension;
+// using extensions::Manifest;
+// using extensions::ManifestHandler;
+// using extensions::ManifestPermission;
+// using extensions::ManifestPermissionSet;
+// using extensions::PermissionSet;
+// using extensions::URLPatternSet;
+
+// ExtensionMsg_PermissionSetStruct::ExtensionMsg_PermissionSetStruct() {
+// }
+
+// ExtensionMsg_PermissionSetStruct::ExtensionMsg_PermissionSetStruct(
+//     const PermissionSet& permissions)
+//     : apis(permissions.apis().Clone()),
+//       manifest_permissions(permissions.manifest_permissions().Clone()),
+//       explicit_hosts(permissions.explicit_hosts().Clone()),
+//       scriptable_hosts(permissions.scriptable_hosts().Clone()) {}
+
+// ExtensionMsg_PermissionSetStruct::~ExtensionMsg_PermissionSetStruct() {}
+
+// ExtensionMsg_PermissionSetStruct::ExtensionMsg_PermissionSetStruct(
+//     ExtensionMsg_PermissionSetStruct&& other) = default;
+
+// ExtensionMsg_PermissionSetStruct& ExtensionMsg_PermissionSetStruct::operator=(
+//     ExtensionMsg_PermissionSetStruct&& other) = default;
+
+// std::unique_ptr<const PermissionSet>
+// ExtensionMsg_PermissionSetStruct::ToPermissionSet() const {
+//   // TODO(devlin): Make this destructive so we can std::move() the members.
+//   return std::make_unique<PermissionSet>(
+//       apis.Clone(), manifest_permissions.Clone(), explicit_hosts.Clone(),
+//       scriptable_hosts.Clone());
+// }
+
+// ExtensionMsg_Loaded_Params::ExtensionMsg_Loaded_Params()
+//     : location(Manifest::INVALID_LOCATION),
+//       creation_flags(Extension::NO_FLAGS) {}
+
+// ExtensionMsg_Loaded_Params::~ExtensionMsg_Loaded_Params() {}
+
+// ExtensionMsg_Loaded_Params::ExtensionMsg_Loaded_Params(
+//     const Extension* extension,
+//     bool include_tab_permissions,
+//     base::Optional<ActivationSequence> worker_activation_sequence)
+//     : manifest(static_cast<base::DictionaryValue&&>(
+//           extension->manifest()->value()->Clone())),
+//       location(extension->location()),
+//       path(extension->path()),
+//       active_permissions(extension->permissions_data()->active_permissions()),
+//       withheld_permissions(
+//           extension->permissions_data()->withheld_permissions()),
+//       policy_blocked_hosts(
+//           extension->permissions_data()->policy_blocked_hosts().Clone()),
+//       policy_allowed_hosts(
+//           extension->permissions_data()->policy_allowed_hosts().Clone()),
+//       uses_default_policy_blocked_allowed_hosts(
+//           extension->permissions_data()->UsesDefaultPolicyHostRestrictions()),
+//       id(extension->id()),
+//       worker_activation_sequence(worker_activation_sequence),
+//       creation_flags(extension->creation_flags()) {
+//   if (include_tab_permissions) {
+//     for (const auto& pair :
+//          extension->permissions_data()->tab_specific_permissions()) {
+//       tab_specific_permissions[pair.first] =
+//           ExtensionMsg_PermissionSetStruct(*pair.second);
+//     }
+//   }
+// }
+
+// ExtensionMsg_Loaded_Params::ExtensionMsg_Loaded_Params(
+//     ExtensionMsg_Loaded_Params&& other) = default;
+// ExtensionMsg_Loaded_Params& ExtensionMsg_Loaded_Params::operator=(
+//     ExtensionMsg_Loaded_Params&& other) = default;
+
+// scoped_refptr<Extension> ExtensionMsg_Loaded_Params::ConvertToExtension(
+//     const int context_id,
+//     std::string* error) const {
+//   // We pass in the |id| to the create call because it will save work in the
+//   // normal case, and because in tests, extensions may not have paths or keys,
+//   // but it's important to retain the same id.
+//   scoped_refptr<Extension> extension =
+//       Extension::Create(path, location, manifest, creation_flags, id, error);
+//   if (extension.get()) {
+//     const extensions::PermissionsData* permissions_data =
+//         extension->permissions_data();
+//     permissions_data->SetPermissions(active_permissions.ToPermissionSet(),
+//                                      withheld_permissions.ToPermissionSet());
+//     if (uses_default_policy_blocked_allowed_hosts) {
+//       permissions_data->SetUsesDefaultHostRestrictions(context_id);
+//     } else {
+//       permissions_data->SetPolicyHostRestrictions(policy_blocked_hosts,
+//                                                   policy_allowed_hosts);
+//     }
+//     for (const auto& pair : tab_specific_permissions) {
+//       permissions_data->UpdateTabSpecificPermissions(
+//           pair.first, *pair.second.ToPermissionSet());
+//     }
+//   }
+//   return extension;
+// }
+
+namespace IPC {
+
+// void ParamTraits<URLPattern>::Write(base::Pickle* m, const param_type& p) {
+//   WriteParam(m, p.valid_schemes());
+//   WriteParam(m, p.GetAsString());
+// }
+
+// bool ParamTraits<URLPattern>::Read(const base::Pickle* m,
+//                                    base::PickleIterator* iter,
+//                                    param_type* p) {
+//   int valid_schemes;
+//   std::string spec;
+//   if (!ReadParam(m, iter, &valid_schemes) ||
+//       !ReadParam(m, iter, &spec))
+//     return false;
+
+//   // TODO(jstritar): We don't want the URLPattern to fail parsing when the
+//   // scheme is invalid. Instead, the pattern should parse but it should not
+//   // match the invalid patterns. We get around this by setting the valid
+//   // schemes after parsing the pattern. Update these method calls once we can
+//   // ignore scheme validation with URLPattern parse options. crbug.com/90544
+//   p->SetValidSchemes(URLPattern::SCHEME_ALL);
+//   URLPattern::ParseResult result = p->Parse(spec);
+//   p->SetValidSchemes(valid_schemes);
+//   return URLPattern::ParseResult::kSuccess == result;
+// }
+
+// void ParamTraits<URLPattern>::Log(const param_type& p, std::string* l) {
+//   LogParam(p.GetAsString(), l);
+// }
+
+// void ParamTraits<URLPatternSet>::Write(base::Pickle* m, const param_type& p) {
+//   WriteParam(m, p.patterns());
+// }
+
+// bool ParamTraits<URLPatternSet>::Read(const base::Pickle* m,
+//                                       base::PickleIterator* iter,
+//                                       param_type* p) {
+//   std::set<URLPattern> patterns;
+//   if (!ReadParam(m, iter, &patterns))
+//     return false;
+
+//   for (auto i = patterns.begin(); i != patterns.end(); ++i)
+//     p->AddPattern(*i);
+//   return true;
+// }
+
+// void ParamTraits<URLPatternSet>::Log(const param_type& p, std::string* l) {
+//   LogParam(p.patterns(), l);
+// }
+
+// void ParamTraits<APIPermission::ID>::Write(base::Pickle* m,
+//                                            const param_type& p) {
+//   WriteParam(m, static_cast<int>(p));
+// }
+
+// bool ParamTraits<APIPermission::ID>::Read(const base::Pickle* m,
+//                                           base::PickleIterator* iter,
+//                                           param_type* p) {
+//   int api_id = -2;
+//   if (!ReadParam(m, iter, &api_id))
+//     return false;
+
+//   *p = static_cast<APIPermission::ID>(api_id);
+//   return true;
+// }
+
+// void ParamTraits<APIPermission::ID>::Log(
+//     const param_type& p, std::string* l) {
+//   LogParam(static_cast<int>(p), l);
+// }
+
+// void ParamTraits<APIPermissionSet>::Write(base::Pickle* m,
+//                                           const param_type& p) {
+//   APIPermissionSet::const_iterator it = p.begin();
+//   const APIPermissionSet::const_iterator end = p.end();
+//   WriteParam(m, static_cast<uint32_t>(p.size()));
+//   for (; it != end; ++it) {
+//     WriteParam(m, it->id());
+//     it->Write(m);
+//   }
+// }
+
+// bool ParamTraits<APIPermissionSet>::Read(const base::Pickle* m,
+//                                          base::PickleIterator* iter,
+//                                          param_type* r) {
+//   uint32_t size;
+//   if (!ReadParam(m, iter, &size))
+//     return false;
+//   for (uint32_t i = 0; i < size; ++i) {
+//     APIPermission::ID id;
+//     if (!ReadParam(m, iter, &id))
+//       return false;
+//     const APIPermissionInfo* permission_info =
+//       extensions::PermissionsInfo::GetInstance()->GetByID(id);
+//     if (!permission_info)
+//       return false;
+//     std::unique_ptr<APIPermission> p(permission_info->CreateAPIPermission());
+//     if (!p->Read(m, iter))
+//       return false;
+//     r->insert(std::move(p));
+//   }
+//   return true;
+// }
+
+// void ParamTraits<APIPermissionSet>::Log(
+//     const param_type& p, std::string* l) {
+//   LogParam(p.map(), l);
+// }
+
+// void ParamTraits<ManifestPermissionSet>::Write(base::Pickle* m,
+//                                                const param_type& p) {
+//   ManifestPermissionSet::const_iterator it = p.begin();
+//   const ManifestPermissionSet::const_iterator end = p.end();
+//   WriteParam(m, static_cast<uint32_t>(p.size()));
+//   for (; it != end; ++it) {
+//     WriteParam(m, it->name());
+//     it->Write(m);
+//   }
+// }
+
+// bool ParamTraits<ManifestPermissionSet>::Read(const base::Pickle* m,
+//                                               base::PickleIterator* iter,
+//                                               param_type* r) {
+//   uint32_t size;
+//   if (!ReadParam(m, iter, &size))
+//     return false;
+//   for (uint32_t i = 0; i < size; ++i) {
+//     std::string name;
+//     if (!ReadParam(m, iter, &name))
+//       return false;
+//     std::unique_ptr<ManifestPermission> p(
+//         ManifestHandler::CreatePermission(name));
+//     if (!p)
+//       return false;
+//     if (!p->Read(m, iter))
+//       return false;
+//     r->insert(std::move(p));
+//   }
+//   return true;
+// }
+
+// void ParamTraits<ManifestPermissionSet>::Log(
+//     const param_type& p, std::string* l) {
+//   LogParam(p.map(), l);
+// }
+
+void ParamTraits<HostID>::Write(base::Pickle* m, const param_type& p) {
+  WriteParam(m, p.type());
+  WriteParam(m, p.id());
+}
+
+bool ParamTraits<HostID>::Read(const base::Pickle* m,
+                               base::PickleIterator* iter,
+                               param_type* r) {
+  HostID::HostType type;
+  std::string id;
+  if (!ReadParam(m, iter, &type))
+    return false;
+  if (!ReadParam(m, iter, &id))
+    return false;
+  *r = HostID(type, id);
+  return true;
+}
+
+void ParamTraits<HostID>::Log(
+    const param_type& p, std::string* l) {
+  LogParam(p.type(), l);
+  LogParam(p.id(), l);
+}
+
+// void ParamTraits<ExtensionMsg_PermissionSetStruct>::Write(base::Pickle* m,
+//                                                           const param_type& p) {
+//   WriteParam(m, p.apis);
+//   WriteParam(m, p.manifest_permissions);
+//   WriteParam(m, p.explicit_hosts);
+//   WriteParam(m, p.scriptable_hosts);
+// }
+
+// bool ParamTraits<ExtensionMsg_PermissionSetStruct>::Read(
+//     const base::Pickle* m,
+//     base::PickleIterator* iter,
+//     param_type* p) {
+//   return ReadParam(m, iter, &p->apis) &&
+//          ReadParam(m, iter, &p->manifest_permissions) &&
+//          ReadParam(m, iter, &p->explicit_hosts) &&
+//          ReadParam(m, iter, &p->scriptable_hosts);
+// }
+
+// void ParamTraits<ExtensionMsg_PermissionSetStruct>::Log(const param_type& p,
+//                                                         std::string* l) {
+//   LogParam(p.apis, l);
+//   LogParam(p.manifest_permissions, l);
+//   LogParam(p.explicit_hosts, l);
+//   LogParam(p.scriptable_hosts, l);
+// }
+
+// void ParamTraits<ExtensionMsg_Loaded_Params>::Write(base::Pickle* m,
+//                                                     const param_type& p) {
+//   WriteParam(m, p.location);
+//   WriteParam(m, p.path);
+//   WriteParam(m, p.manifest);
+//   WriteParam(m, p.creation_flags);
+//   WriteParam(m, p.id);
+//   WriteParam(m, p.active_permissions);
+//   WriteParam(m, p.withheld_permissions);
+//   WriteParam(m, p.tab_specific_permissions);
+//   WriteParam(m, p.policy_blocked_hosts);
+//   WriteParam(m, p.policy_allowed_hosts);
+//   WriteParam(m, p.uses_default_policy_blocked_allowed_hosts);
+//   WriteParam(m, p.worker_activation_sequence);
+// }
+
+// bool ParamTraits<ExtensionMsg_Loaded_Params>::Read(const base::Pickle* m,
+//                                                    base::PickleIterator* iter,
+//                                                    param_type* p) {
+//   p->manifest.Clear();
+//   return ReadParam(m, iter, &p->location) && ReadParam(m, iter, &p->path) &&
+//          ReadParam(m, iter, &p->manifest) &&
+//          ReadParam(m, iter, &p->creation_flags) && ReadParam(m, iter, &p->id) &&
+//          ReadParam(m, iter, &p->active_permissions) &&
+//          ReadParam(m, iter, &p->withheld_permissions) &&
+//          ReadParam(m, iter, &p->tab_specific_permissions) &&
+//          ReadParam(m, iter, &p->policy_blocked_hosts) &&
+//          ReadParam(m, iter, &p->policy_allowed_hosts) &&
+//          ReadParam(m, iter, &p->uses_default_policy_blocked_allowed_hosts) &&
+//          ReadParam(m, iter, &p->worker_activation_sequence);
+// }
+
+// void ParamTraits<ExtensionMsg_Loaded_Params>::Log(const param_type& p,
+//                                                   std::string* l) {
+//   l->append(p.id);
+// }
+
+}  // namespace IPC
diff --git a/components/user_scripts/content/common/extension_messages.h b/components/user_scripts/content/common/extension_messages.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/extension_messages.h
@@ -0,0 +1,1128 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// IPC messages for extensions.
+
+#ifndef EXTENSIONS_COMMON_EXTENSION_MESSAGES_H_
+#define EXTENSIONS_COMMON_EXTENSION_MESSAGES_H_
+
+#include <stdint.h>
+
+#include <map>
+#include <memory>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/memory/read_only_shared_memory_region.h"
+#include "base/values.h"
+#include "content/public/common/common_param_traits.h"
+//#include "content/public/common/socket_permission_request.h"
+// #include "extensions/common/activation_sequence.h"
+// #include "extensions/common/api/messaging/message.h"
+// #include "extensions/common/api/messaging/messaging_endpoint.h"
+// #include "extensions/common/api/messaging/port_context.h"
+// #include "extensions/common/api/messaging/port_id.h"
+// #include "extensions/common/common_param_traits.h"
+#include "constants.h"
+//#include "extensions/common/draggable_region.h"
+//#include "extensions/common/event_filtering_info.h"
+//#include "extensions/common/extension.h"
+//#include "extensions/common/extensions_client.h"
+#include "host_id.h"
+//#include "extensions/common/permissions/permission_set.h"
+//#include "extensions/common/permissions/socket_permission_data.h"
+//#include "extensions/common/permissions/usb_device_permission_data.h"
+//#include "extensions/common/stack_frame.h"
+//#include "extensions/common/url_pattern.h"
+//#include "extensions/common/url_pattern_set.h"
+//#include "extensions/common/user_script.h"
+//#include "extensions/common/view_type.h"
+#include "ipc/ipc_message_macros.h"
+//#include "ui/accessibility/ax_param_traits.h"
+#include "url/gurl.h"
+#include "url/origin.h"
+
+#define IPC_MESSAGE_START ExtensionMsgStart
+
+// IPC_ENUM_TRAITS_MAX_VALUE(extensions::CSSOrigin, extensions::CSS_ORIGIN_LAST)
+
+// IPC_ENUM_TRAITS_MAX_VALUE(extensions::ViewType, extensions::VIEW_TYPE_LAST)
+// IPC_ENUM_TRAITS_MAX_VALUE(content::SocketPermissionRequest::OperationType,
+//                           content::SocketPermissionRequest::OPERATION_TYPE_LAST)
+
+// IPC_ENUM_TRAITS_MAX_VALUE(extensions::UserScript::InjectionType,
+//                           extensions::UserScript::INJECTION_TYPE_LAST)
+
+// IPC_ENUM_TRAITS_MAX_VALUE(extensions::UserScript::RunLocation,
+//                           extensions::UserScript::RUN_LOCATION_LAST - 1)
+
+// IPC_ENUM_TRAITS_MAX_VALUE(extensions::MessagingEndpoint::Type,
+//                           extensions::MessagingEndpoint::Type::kLast)
+
+IPC_ENUM_TRAITS_MAX_VALUE(HostID::HostType, HostID::HOST_TYPE_LAST)
+
+// // Parameters structure for ExtensionHostMsg_AddAPIActionToActivityLog and
+// // ExtensionHostMsg_AddEventToActivityLog.
+// IPC_STRUCT_BEGIN(ExtensionHostMsg_APIActionOrEvent_Params)
+//   // API name.
+//   IPC_STRUCT_MEMBER(std::string, api_call)
+
+//   // List of arguments.
+//   IPC_STRUCT_MEMBER(base::ListValue, arguments)
+
+//   // Extra logging information.
+//   IPC_STRUCT_MEMBER(std::string, extra)
+// IPC_STRUCT_END()
+
+// // Parameters structure for ExtensionHostMsg_AddDOMActionToActivityLog.
+// IPC_STRUCT_BEGIN(ExtensionHostMsg_DOMAction_Params)
+//   // URL of the page.
+//   IPC_STRUCT_MEMBER(GURL, url)
+
+//   // Title of the page.
+//   IPC_STRUCT_MEMBER(base::string16, url_title)
+
+//   // API name.
+//   IPC_STRUCT_MEMBER(std::string, api_call)
+
+//   // List of arguments.
+//   IPC_STRUCT_MEMBER(base::ListValue, arguments)
+
+//   // Type of DOM API call.
+//   IPC_STRUCT_MEMBER(int, call_type)
+// IPC_STRUCT_END()
+
+// // Parameters structure for ExtensionHostMsg_Request.
+// IPC_STRUCT_BEGIN(ExtensionHostMsg_Request_Params)
+//   // Message name.
+//   IPC_STRUCT_MEMBER(std::string, name)
+
+//   // List of message arguments.
+//   IPC_STRUCT_MEMBER(base::ListValue, arguments)
+
+//   // Extension ID this request was sent from. This can be empty, in the case
+//   // where we expose APIs to normal web pages using the extension function
+//   // system.
+//   IPC_STRUCT_MEMBER(std::string, extension_id)
+
+//   // URL of the frame the request was sent from. This isn't necessarily an
+//   // extension url. Extension requests can also originate from content scripts,
+//   // in which case extension_id will indicate the ID of the associated
+//   // extension. Or, they can originate from hosted apps or normal web pages.
+//   IPC_STRUCT_MEMBER(GURL, source_url)
+
+//   // Unique request id to match requests and responses.
+//   IPC_STRUCT_MEMBER(int, request_id)
+
+//   // True if request has a callback specified.
+//   IPC_STRUCT_MEMBER(bool, has_callback)
+
+//   // True if request is executed in response to an explicit user gesture.
+//   IPC_STRUCT_MEMBER(bool, user_gesture)
+
+//   // If this API call is for a service worker, then this is the worker thread
+//   // id. Otherwise, this is kMainThreadId.
+//   IPC_STRUCT_MEMBER(int, worker_thread_id)
+
+//   // If this API call is for a service worker, then this is the service
+//   // worker version id. Otherwise, this is set to
+//   // blink::mojom::kInvalidServiceWorkerVersionId.
+//   IPC_STRUCT_MEMBER(int64_t, service_worker_version_id)
+// IPC_STRUCT_END()
+
+// IPC_STRUCT_BEGIN(ExtensionMsg_DispatchEvent_Params)
+//   // If this event is for a service worker, then this is the worker thread
+//   // id. Otherwise, this is 0.
+//   IPC_STRUCT_MEMBER(int, worker_thread_id)
+
+//   // The id of the extension to dispatch the event to.
+//   IPC_STRUCT_MEMBER(std::string, extension_id)
+
+//   // The name of the event to dispatch.
+//   IPC_STRUCT_MEMBER(std::string, event_name)
+
+//   // The id of the event for use in the EventAck response message.
+//   IPC_STRUCT_MEMBER(int, event_id)
+
+//   // Whether or not the event is part of a user gesture.
+//   IPC_STRUCT_MEMBER(bool, is_user_gesture)
+
+//   // Additional filtering info for the event.
+//   IPC_STRUCT_MEMBER(extensions::EventFilteringInfo, filtering_info)
+// IPC_STRUCT_END()
+
+// // Allows an extension to execute code in a tab.
+// IPC_STRUCT_BEGIN(ExtensionMsg_ExecuteCode_Params)
+//   // The extension API request id, for responding.
+//   IPC_STRUCT_MEMBER(int, request_id)
+
+//   // The ID of the requesting injection host.
+//   IPC_STRUCT_MEMBER(HostID, host_id)
+
+//   // Whether the code is JavaScript or CSS.
+//   IPC_STRUCT_MEMBER(bool, is_javascript)
+
+//   // String of code to execute.
+//   IPC_STRUCT_MEMBER(std::string, code)
+
+//   // The webview guest source who calls to execute code.
+//   IPC_STRUCT_MEMBER(GURL, webview_src)
+
+//   // Whether to inject into about:blank (sub)frames.
+//   IPC_STRUCT_MEMBER(bool, match_about_blank)
+
+//   // When to inject the code.
+//   IPC_STRUCT_MEMBER(extensions::UserScript::RunLocation, run_at)
+
+//   // Whether the request is coming from a <webview>.
+//   IPC_STRUCT_MEMBER(bool, is_web_view)
+
+//   // Whether the caller is interested in the result value. Manifest-declared
+//   // content scripts and executeScript() calls without a response callback
+//   // are examples of when this will be false.
+//   IPC_STRUCT_MEMBER(bool, wants_result)
+
+//   // The URL of the script that was injected, if any.
+//   IPC_STRUCT_MEMBER(GURL, script_url)
+
+//   // Whether the code to be executed should be associated with a user gesture.
+//   IPC_STRUCT_MEMBER(bool, user_gesture)
+
+//   // The origin of the CSS.
+//   IPC_STRUCT_MEMBER(base::Optional<extensions::CSSOrigin>, css_origin)
+
+//   // The autogenerated key for the CSS injection.
+//   IPC_STRUCT_MEMBER(base::Optional<std::string>, injection_key)
+// IPC_STRUCT_END()
+
+// // Struct containing information about the sender of connect() calls that
+// // originate from a tab.
+// IPC_STRUCT_BEGIN(ExtensionMsg_TabConnectionInfo)
+//   // The tab from where the connection was created.
+//   IPC_STRUCT_MEMBER(base::DictionaryValue, tab)
+
+//   // The ID of the frame that initiated the connection.
+//   // 0 if main frame, positive otherwise. -1 if not initiated from a frame.
+//   IPC_STRUCT_MEMBER(int, frame_id)
+// IPC_STRUCT_END()
+
+// // Struct containing information about the destination of tab.connect().
+// IPC_STRUCT_BEGIN(ExtensionMsg_TabTargetConnectionInfo)
+//   // The destination tab's ID.
+//   IPC_STRUCT_MEMBER(int, tab_id)
+
+//   // Frame ID of the destination. -1 for all frames, 0 for main frame and
+//   // positive if the destination is a specific child frame.
+//   IPC_STRUCT_MEMBER(int, frame_id)
+// IPC_STRUCT_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::MessagingEndpoint)
+//   IPC_STRUCT_TRAITS_MEMBER(type)
+//   IPC_STRUCT_TRAITS_MEMBER(extension_id)
+//   IPC_STRUCT_TRAITS_MEMBER(native_app_name)
+// IPC_STRUCT_TRAITS_END()
+
+// // Struct containing the data for external connections to extensions. Used to
+// // handle the IPCs initiated by both connect() and onConnect().
+// IPC_STRUCT_BEGIN(ExtensionMsg_ExternalConnectionInfo)
+//   // The ID of the extension that is the target of the request.
+//   IPC_STRUCT_MEMBER(std::string, target_id)
+
+//   // Specifies the type and the ID of the endpoint that initiated the request.
+//   IPC_STRUCT_MEMBER(extensions::MessagingEndpoint, source_endpoint)
+
+//   // The URL of the frame that initiated the request.
+//   IPC_STRUCT_MEMBER(GURL, source_url)
+
+//   // The origin of the object that initiated the request.
+//   IPC_STRUCT_MEMBER(base::Optional<url::Origin>, source_origin)
+
+//   // The process ID of the webview that initiated the request.
+//   IPC_STRUCT_MEMBER(int, guest_process_id)
+
+//   // The render frame routing ID of the webview that initiated the request.
+//   IPC_STRUCT_MEMBER(int, guest_render_frame_routing_id)
+// IPC_STRUCT_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::DraggableRegion)
+//   IPC_STRUCT_TRAITS_MEMBER(draggable)
+//   IPC_STRUCT_TRAITS_MEMBER(bounds)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(content::SocketPermissionRequest)
+//   IPC_STRUCT_TRAITS_MEMBER(type)
+//   IPC_STRUCT_TRAITS_MEMBER(host)
+//   IPC_STRUCT_TRAITS_MEMBER(port)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::PortContext::FrameContext)
+//   IPC_STRUCT_TRAITS_MEMBER(routing_id)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::PortContext::WorkerContext)
+//   IPC_STRUCT_TRAITS_MEMBER(thread_id)
+//   IPC_STRUCT_TRAITS_MEMBER(version_id)
+//   IPC_STRUCT_TRAITS_MEMBER(extension_id)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::PortContext)
+//   IPC_STRUCT_TRAITS_MEMBER(frame)
+//   IPC_STRUCT_TRAITS_MEMBER(worker)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::SocketPermissionEntry)
+//   IPC_STRUCT_TRAITS_MEMBER(pattern_)
+//   IPC_STRUCT_TRAITS_MEMBER(match_subdomains_)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::SocketPermissionData)
+//   IPC_STRUCT_TRAITS_MEMBER(entry())
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::StackFrame)
+//   IPC_STRUCT_TRAITS_MEMBER(line_number)
+//   IPC_STRUCT_TRAITS_MEMBER(column_number)
+//   IPC_STRUCT_TRAITS_MEMBER(source)
+//   IPC_STRUCT_TRAITS_MEMBER(function)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::UsbDevicePermissionData)
+//   IPC_STRUCT_TRAITS_MEMBER(vendor_id())
+//   IPC_STRUCT_TRAITS_MEMBER(product_id())
+//   IPC_STRUCT_TRAITS_MEMBER(interface_class())
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::Message)
+//   IPC_STRUCT_TRAITS_MEMBER(data)
+//   IPC_STRUCT_TRAITS_MEMBER(user_gesture)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::PortId)
+//   IPC_STRUCT_TRAITS_MEMBER(context_id)
+//   IPC_STRUCT_TRAITS_MEMBER(port_number)
+//   IPC_STRUCT_TRAITS_MEMBER(is_opener)
+// IPC_STRUCT_TRAITS_END()
+
+// IPC_STRUCT_TRAITS_BEGIN(extensions::EventFilteringInfo)
+//   IPC_STRUCT_TRAITS_MEMBER(url)
+//   IPC_STRUCT_TRAITS_MEMBER(service_type)
+//   IPC_STRUCT_TRAITS_MEMBER(instance_id)
+//   IPC_STRUCT_TRAITS_MEMBER(window_type)
+//   IPC_STRUCT_TRAITS_MEMBER(window_exposed_by_default)
+// IPC_STRUCT_TRAITS_END()
+
+// // Identifier containing info about a service worker, used in event listener
+// // IPCs.
+// IPC_STRUCT_BEGIN(ServiceWorkerIdentifier)
+//   IPC_STRUCT_MEMBER(GURL, scope)
+//   IPC_STRUCT_MEMBER(int64_t, version_id)
+//   IPC_STRUCT_MEMBER(int, thread_id)
+// IPC_STRUCT_END()
+
+// Singly-included section for custom IPC traits.
+#ifndef INTERNAL_EXTENSIONS_COMMON_EXTENSION_MESSAGES_H_
+#define INTERNAL_EXTENSIONS_COMMON_EXTENSION_MESSAGES_H_
+
+// // IPC_MESSAGE macros choke on extra , in the std::map, when expanding. We need
+// // to typedef it to avoid that.
+// // Substitution map for l10n messages.
+// typedef std::map<std::string, std::string> SubstitutionMap;
+
+// // Map of extensions IDs to the executing script paths.
+// typedef std::map<std::string, std::set<std::string> > ExecutingScriptsMap;
+
+// struct ExtensionMsg_PermissionSetStruct {
+//   ExtensionMsg_PermissionSetStruct();
+//   explicit ExtensionMsg_PermissionSetStruct(
+//       const extensions::PermissionSet& permissions);
+//   ~ExtensionMsg_PermissionSetStruct();
+
+//   ExtensionMsg_PermissionSetStruct(ExtensionMsg_PermissionSetStruct&& other);
+//   ExtensionMsg_PermissionSetStruct& operator=(
+//       ExtensionMsg_PermissionSetStruct&& other);
+
+//   std::unique_ptr<const extensions::PermissionSet> ToPermissionSet() const;
+
+//   extensions::APIPermissionSet apis;
+//   extensions::ManifestPermissionSet manifest_permissions;
+//   extensions::URLPatternSet explicit_hosts;
+//   extensions::URLPatternSet scriptable_hosts;
+
+//   DISALLOW_COPY_AND_ASSIGN(ExtensionMsg_PermissionSetStruct);
+// };
+
+// struct ExtensionMsg_Loaded_Params {
+//   ExtensionMsg_Loaded_Params();
+//   ~ExtensionMsg_Loaded_Params();
+//   ExtensionMsg_Loaded_Params(const extensions::Extension* extension,
+//                              bool include_tab_permissions,
+//                              base::Optional<extensions::ActivationSequence>
+//                                  worker_activation_sequence);
+
+//   ExtensionMsg_Loaded_Params(ExtensionMsg_Loaded_Params&& other);
+//   ExtensionMsg_Loaded_Params& operator=(ExtensionMsg_Loaded_Params&& other);
+
+//   // Creates a new extension from the data in this object.
+//   // A context_id needs to be passed because each browser context can have
+//   // different values for default_policy_blocked/allowed_hosts.
+//   // (see extension_util.cc#GetBrowserContextId)
+//   scoped_refptr<extensions::Extension> ConvertToExtension(
+//       int context_id,
+//       std::string* error) const;
+
+//   // The subset of the extension manifest data we send to renderers.
+//   base::DictionaryValue manifest;
+
+//   // The location the extension was installed from.
+//   extensions::Manifest::Location location;
+
+//   // The path the extension was loaded from. This is used in the renderer only
+//   // to generate the extension ID for extensions that are loaded unpacked.
+//   base::FilePath path;
+
+//   // The extension's active and withheld permissions.
+//   ExtensionMsg_PermissionSetStruct active_permissions;
+//   ExtensionMsg_PermissionSetStruct withheld_permissions;
+//   std::map<int, ExtensionMsg_PermissionSetStruct> tab_specific_permissions;
+
+//   // Contains URLPatternSets defining which URLs an extension may not interact
+//   // with by policy.
+//   extensions::URLPatternSet policy_blocked_hosts;
+//   extensions::URLPatternSet policy_allowed_hosts;
+
+//   // If the extension uses the default list of blocked / allowed URLs.
+//   bool uses_default_policy_blocked_allowed_hosts = true;
+
+//   // We keep this separate so that it can be used in logging.
+//   std::string id;
+
+//   // If this extension is Service Worker based, then this contains the
+//   // activation sequence of the extension.
+//   base::Optional<extensions::ActivationSequence> worker_activation_sequence;
+
+//   // Send creation flags so extension is initialized identically.
+//   int creation_flags;
+
+//  private:
+//   DISALLOW_COPY_AND_ASSIGN(ExtensionMsg_Loaded_Params);
+// };
+
+// struct ExtensionHostMsg_AutomationQuerySelector_Error {
+//   enum Value { kNone, kNoDocument, kNodeDestroyed };
+
+//   ExtensionHostMsg_AutomationQuerySelector_Error() : value(kNone) {}
+
+//   Value value;
+// };
+
+namespace IPC {
+
+// template <>
+// struct ParamTraits<URLPattern> {
+//   typedef URLPattern param_type;
+//   static void Write(base::Pickle* m, const param_type& p);
+//   static bool Read(const base::Pickle* m,
+//                    base::PickleIterator* iter,
+//                    param_type* p);
+//   static void Log(const param_type& p, std::string* l);
+// };
+
+// template <>
+// struct ParamTraits<extensions::URLPatternSet> {
+//   typedef extensions::URLPatternSet param_type;
+//   static void Write(base::Pickle* m, const param_type& p);
+//   static bool Read(const base::Pickle* m,
+//                    base::PickleIterator* iter,
+//                    param_type* p);
+//   static void Log(const param_type& p, std::string* l);
+// };
+
+// template <>
+// struct ParamTraits<extensions::APIPermission::ID> {
+//   typedef extensions::APIPermission::ID param_type;
+//   static void Write(base::Pickle* m, const param_type& p);
+//   static bool Read(const base::Pickle* m,
+//                    base::PickleIterator* iter,
+//                    param_type* p);
+//   static void Log(const param_type& p, std::string* l);
+// };
+
+// template <>
+// struct ParamTraits<extensions::APIPermissionSet> {
+//   typedef extensions::APIPermissionSet param_type;
+//   static void Write(base::Pickle* m, const param_type& p);
+//   static bool Read(const base::Pickle* m,
+//                    base::PickleIterator* iter,
+//                    param_type* r);
+//   static void Log(const param_type& p, std::string* l);
+// };
+
+// template <>
+// struct ParamTraits<extensions::ManifestPermissionSet> {
+//   typedef extensions::ManifestPermissionSet param_type;
+//   static void Write(base::Pickle* m, const param_type& p);
+//   static bool Read(const base::Pickle* m,
+//                    base::PickleIterator* iter,
+//                    param_type* r);
+//   static void Log(const param_type& p, std::string* l);
+// };
+
+template <>
+struct ParamTraits<HostID> {
+  typedef HostID param_type;
+  static void Write(base::Pickle* m, const param_type& p);
+  static bool Read(const base::Pickle* m,
+                   base::PickleIterator* iter,
+                   param_type* r);
+  static void Log(const param_type& p, std::string* l);
+};
+
+// template <>
+// struct ParamTraits<ExtensionMsg_PermissionSetStruct> {
+//   typedef ExtensionMsg_PermissionSetStruct param_type;
+//   static void Write(base::Pickle* m, const param_type& p);
+//   static bool Read(const base::Pickle* m,
+//                    base::PickleIterator* iter,
+//                    param_type* p);
+//   static void Log(const param_type& p, std::string* l);
+// };
+
+// template <>
+// struct ParamTraits<ExtensionMsg_Loaded_Params> {
+//   typedef ExtensionMsg_Loaded_Params param_type;
+//   static void Write(base::Pickle* m, const param_type& p);
+//   static bool Read(const base::Pickle* m,
+//                    base::PickleIterator* iter,
+//                    param_type* p);
+//   static void Log(const param_type& p, std::string* l);
+// };
+
+}  // namespace IPC
+
+#endif  // INTERNAL_EXTENSIONS_COMMON_EXTENSION_MESSAGES_H_
+
+// IPC_ENUM_TRAITS_MAX_VALUE(
+//     ExtensionHostMsg_AutomationQuerySelector_Error::Value,
+//     ExtensionHostMsg_AutomationQuerySelector_Error::kNodeDestroyed)
+
+// IPC_STRUCT_TRAITS_BEGIN(ExtensionHostMsg_AutomationQuerySelector_Error)
+// IPC_STRUCT_TRAITS_MEMBER(value)
+// IPC_STRUCT_TRAITS_END()
+
+// // Parameters structure for ExtensionMsg_UpdatePermissions.
+// IPC_STRUCT_BEGIN(ExtensionMsg_UpdatePermissions_Params)
+//   IPC_STRUCT_MEMBER(std::string, extension_id)
+//   IPC_STRUCT_MEMBER(ExtensionMsg_PermissionSetStruct, active_permissions)
+//   IPC_STRUCT_MEMBER(ExtensionMsg_PermissionSetStruct, withheld_permissions)
+//   IPC_STRUCT_MEMBER(extensions::URLPatternSet, policy_blocked_hosts)
+//   IPC_STRUCT_MEMBER(extensions::URLPatternSet, policy_allowed_hosts)
+//   IPC_STRUCT_MEMBER(bool, uses_default_policy_host_restrictions)
+// IPC_STRUCT_END()
+
+// // Parameters structure for ExtensionMsg_UpdateDefaultPolicyHostRestrictions.
+// IPC_STRUCT_BEGIN(ExtensionMsg_UpdateDefaultPolicyHostRestrictions_Params)
+//   IPC_STRUCT_MEMBER(extensions::URLPatternSet, default_policy_blocked_hosts)
+//   IPC_STRUCT_MEMBER(extensions::URLPatternSet, default_policy_allowed_hosts)
+// IPC_STRUCT_END()
+
+// // Messages sent from the browser to the renderer:
+
+// // The browser sends this message in response to all extension api calls. The
+// // response data (if any) is one of the base::Value subclasses, wrapped as the
+// // first element in a ListValue.
+// IPC_MESSAGE_ROUTED4(ExtensionMsg_Response,
+//                     int /* request_id */,
+//                     bool /* success */,
+//                     base::ListValue /* response wrapper (see comment above) */,
+//                     std::string /* error */)
+
+// // Sent to the renderer to dispatch an event to an extension.
+// // Note: |event_args| is separate from the params to avoid having the message
+// // take ownership.
+// IPC_MESSAGE_CONTROL2(ExtensionMsg_DispatchEvent,
+//                      ExtensionMsg_DispatchEvent_Params /* params */,
+//                      base::ListValue /* event_args */)
+
+// // This message is optionally routed.  If used as a control message, it will
+// // call a javascript function |function_name| from module |module_name| in
+// // every registered context in the target process.  If routed, it will be
+// // restricted to the contexts that are part of the target RenderView.
+// //
+// // If |extension_id| is non-empty, the function will be invoked only in
+// // contexts owned by the extension. |args| is a list of primitive Value types
+// // that are passed to the function.
+// IPC_MESSAGE_ROUTED4(ExtensionMsg_MessageInvoke,
+//                     std::string /* extension_id */,
+//                     std::string /* module_name */,
+//                     std::string /* function_name */,
+//                     base::ListValue /* args */)
+
+// // Set the top-level frame to the provided name.
+// IPC_MESSAGE_ROUTED1(ExtensionMsg_SetFrameName,
+//                     std::string /* frame_name */)
+
+// // Tell the renderer process the platforms system font.
+// IPC_MESSAGE_CONTROL2(ExtensionMsg_SetSystemFont,
+//                      std::string /* font_family */,
+//                      std::string /* font_size */)
+
+// // Marks an extension as 'active' in an extension process. 'Active' extensions
+// // have more privileges than other extension content that might end up running
+// // in the process (e.g. because of iframes or content scripts).
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_ActivateExtension,
+//                      std::string /* extension_id */)
+
+// // Notifies the renderer that extensions were loaded in the browser.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_Loaded,
+//                      std::vector<ExtensionMsg_Loaded_Params>)
+
+// // Notifies the renderer that an extension was unloaded in the browser.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_Unloaded,
+//                      std::string)
+
+// // Updates the scripting allowlist for extensions in the render process. This is
+// // only used for testing.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_SetScriptingAllowlist,
+//                      // extension ids
+//                      extensions::ExtensionsClient::ScriptingAllowlist)
+
+// // Notification that renderer should run some JavaScript code.
+// IPC_MESSAGE_ROUTED1(ExtensionMsg_ExecuteCode,
+//                     ExtensionMsg_ExecuteCode_Params)
+
+// Notification that the user scripts have been updated. It has one
+// ReadOnlySharedMemoryRegion argument consisting of the pickled script data.
+// This memory region is valid in the context of the renderer.
+// If |owner| is not empty, then the shared memory handle refers to |owner|'s
+// programmatically-defined scripts. Otherwise, the handle refers to all
+// hosts' statically defined scripts. So far, only extension-hosts support
+// statically defined scripts; WebUI-hosts don't.
+// If |changed_hosts| is not empty, only the host in that set will
+// be updated. Otherwise, all hosts that have scripts in the shared memory
+// region will be updated. Note that the empty set => all hosts case is not
+// supported for per-extension programmatically-defined script regions; in such
+// regions, the owner is expected to list itself as the only changed host.
+// If |whitelisted_only| is true, this process should only run whitelisted
+// scripts and not all user scripts.
+IPC_MESSAGE_CONTROL4(ExtensionMsg_UpdateUserScripts,
+                     base::ReadOnlySharedMemoryRegion,
+                     HostID /* owner */,
+                     std::set<HostID> /* changed hosts */,
+                     bool /* whitelisted_only */)
+
+// // Trigger to execute declarative content script under browser control.
+// IPC_MESSAGE_ROUTED4(ExtensionMsg_ExecuteDeclarativeScript,
+//                     int /* tab identifier */,
+//                     extensions::ExtensionId /* extension identifier */,
+//                     int /* script identifier */,
+//                     GURL /* page URL where script should be injected */)
+
+// // Tell the render view which browser window it's being attached to.
+// IPC_MESSAGE_ROUTED1(ExtensionMsg_UpdateBrowserWindowId,
+//                     int /* id of browser window */)
+
+// // Tell the render view what its tab ID is.
+// IPC_MESSAGE_ROUTED1(ExtensionMsg_SetTabId,
+//                     int /* id of tab */)
+
+// // Tell the renderer to update an extension's permission set.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_UpdatePermissions,
+//                      ExtensionMsg_UpdatePermissions_Params)
+
+// // Tell the renderer to update an extension's policy_blocked_hosts set.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_UpdateDefaultPolicyHostRestrictions,
+//                      ExtensionMsg_UpdateDefaultPolicyHostRestrictions_Params)
+
+// // Tell the render view about new tab-specific permissions for an extension.
+// IPC_MESSAGE_CONTROL5(ExtensionMsg_UpdateTabSpecificPermissions,
+//                      GURL /* url */,
+//                      std::string /* extension_id */,
+//                      extensions::URLPatternSet /* hosts */,
+//                      bool /* update origin whitelist */,
+//                      int /* tab_id */)
+
+// // Tell the render view to clear tab-specific permissions for some extensions.
+// IPC_MESSAGE_CONTROL3(ExtensionMsg_ClearTabSpecificPermissions,
+//                      std::vector<std::string> /* extension_ids */,
+//                      bool /* update origin whitelist */,
+//                      int /* tab_id */)
+
+// // Tell the renderer which type this view is.
+// IPC_MESSAGE_ROUTED1(ExtensionMsg_NotifyRenderViewType,
+//                     extensions::ViewType /* view_type */)
+
+// // The browser's response to the ExtensionMsg_WakeEventPage IPC.
+// IPC_MESSAGE_CONTROL2(ExtensionMsg_WakeEventPageResponse,
+//                      int /* request_id */,
+//                      bool /* success */)
+
+// // Ask the lazy background page if it is ready to be suspended. This is sent
+// // when the page is considered idle. The renderer will reply with the same
+// // sequence_id so that we can tell which message it is responding to.
+// IPC_MESSAGE_CONTROL2(ExtensionMsg_ShouldSuspend,
+//                      std::string /* extension_id */,
+//                      uint64_t /* sequence_id */)
+
+// // If we complete a round of ShouldSuspend->ShouldSuspendAck messages without
+// // the lazy background page becoming active again, we are ready to unload. This
+// // message tells the page to dispatch the suspend event.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_Suspend,
+//                      std::string /* extension_id */)
+
+// // The browser changed its mind about suspending this extension.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_CancelSuspend,
+//                      std::string /* extension_id */)
+
+// // Response to the renderer for ExtensionHostMsg_GetAppInstallState.
+// IPC_MESSAGE_ROUTED2(ExtensionMsg_GetAppInstallStateResponse,
+//                     std::string /* state */,
+//                     int32_t /* callback_id */)
+
+// // Check whether the Port for extension messaging exists in a frame or a Service
+// // Worker. If the port ID is unknown, the frame replies with
+// // ExtensionHostMsg_CloseMessagePort.
+// IPC_MESSAGE_ROUTED2(ExtensionMsg_ValidateMessagePort,
+//                     // For main thread, this is kMainThreadId.
+//                     int /* worker_thread_id */,
+//                     extensions::PortId /* port_id */)
+
+// // Dispatch the Port.onConnect event for message channels.
+// IPC_MESSAGE_ROUTED5(ExtensionMsg_DispatchOnConnect,
+//                     // For main thread, this is kMainThreadId.
+//                     // TODO(lazyboy): Can this be base::Optional<int> instead?
+//                     int /* worker_thread_id */,
+//                     extensions::PortId /* target_port_id */,
+//                     std::string /* channel_name */,
+//                     ExtensionMsg_TabConnectionInfo /* source */,
+//                     ExtensionMsg_ExternalConnectionInfo)
+
+// // Deliver a message sent with ExtensionHostMsg_PostMessage.
+// IPC_MESSAGE_ROUTED3(ExtensionMsg_DeliverMessage,
+//                     // For main thread, this is kMainThreadId.
+//                     int /* worker_thread_id */,
+//                     extensions::PortId /* target_port_id */,
+//                     extensions::Message)
+
+// // Dispatch the Port.onDisconnect event for message channels.
+// IPC_MESSAGE_ROUTED3(ExtensionMsg_DispatchOnDisconnect,
+//                     // For main thread, this is kMainThreadId.
+//                     int /* worker_thread_id */,
+//                     extensions::PortId /* port_id */,
+//                     std::string /* error_message */)
+
+// // Informs the renderer what channel (dev, beta, stable, etc) and user session
+// // type is running.
+// IPC_MESSAGE_CONTROL3(ExtensionMsg_SetSessionInfo,
+//                      version_info::Channel /* channel */,
+//                      extensions::FeatureSessionType /* session_type */,
+//                      bool /* is_lock_screen_context */)
+
+// // Notify the renderer that its window has closed.
+// IPC_MESSAGE_ROUTED1(ExtensionMsg_AppWindowClosed, bool /* send_onclosed */)
+
+// // Notify the renderer that an extension wants notifications when certain
+// // searches match the active page.  This message replaces the old set of
+// // searches, and triggers ExtensionHostMsg_OnWatchedPageChange messages from
+// // each tab to keep the browser updated about changes.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_WatchPages,
+//                      std::vector<std::string> /* CSS selectors */)
+
+// // Send by the browser to indicate a Blob handle has been transferred to the
+// // renderer. This is sent after the actual extension response, and depends on
+// // the sequential nature of IPCs so that the blob has already been caught.
+// // This is a separate control message, so that the renderer process will send
+// // an acknowledgement even if the RenderView has closed or navigated away.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_TransferBlobs,
+//                      std::vector<std::string> /* blob_uuids */)
+
+// // Report the WebView partition ID to the WebView guest renderer process.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_SetWebViewPartitionID,
+//                      std::string /* webview_partition_id */)
+
+// // Enable or disable spatial navigation.
+// IPC_MESSAGE_ROUTED1(ExtensionMsg_SetSpatialNavigationEnabled,
+//                     bool /* spatial_nav_enabled */)
+
+// // Messages sent from the renderer to the browser:
+
+// // A renderer sends this message when an extension process starts an API
+// // request. The browser will always respond with a ExtensionMsg_Response.
+// IPC_MESSAGE_ROUTED1(ExtensionHostMsg_Request,
+//                     ExtensionHostMsg_Request_Params)
+
+// // Notify the browser that the given extension added a listener to an event.
+// IPC_MESSAGE_CONTROL5(ExtensionHostMsg_AddListener,
+//                      std::string /* extension_id */,
+//                      GURL /* listener_or_worker_scope_url */,
+//                      std::string /* name */,
+//                      int64_t /* service_worker_version_id */,
+//                      int /* worker_thread_id */)
+
+// // Notify the browser that the given extension removed a listener from an
+// // event.
+// IPC_MESSAGE_CONTROL5(ExtensionHostMsg_RemoveListener,
+//                      std::string /* extension_id */,
+//                      GURL /* listener_or_worker_scope_url */,
+//                      std::string /* name */,
+//                      int64_t /* service_worker_version_id */,
+//                      int /* worker_thread_id */)
+
+// // Notify the browser that the given extension added a listener to an event from
+// // a lazy background page.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_AddLazyListener,
+//                      std::string /* extension_id */,
+//                      std::string /* name */)
+
+// // Notify the browser that the given extension is no longer interested in
+// // receiving the given event from a lazy background page.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_RemoveLazyListener,
+//                      std::string /* extension_id */,
+//                      std::string /* event_name */)
+
+// // Notify the browser that the given extension added a listener to an event from
+// // an extension service worker.
+// IPC_MESSAGE_CONTROL3(ExtensionHostMsg_AddLazyServiceWorkerListener,
+//                      std::string /* extension_id */,
+//                      std::string /* name */,
+//                      GURL /* service_worker_scope */)
+
+// // Notify the browser that the given extension is no longer interested in
+// // receiving the given event from an extension service worker.
+// IPC_MESSAGE_CONTROL3(ExtensionHostMsg_RemoveLazyServiceWorkerListener,
+//                      std::string /* extension_id */,
+//                      std::string /* name */,
+//                      GURL /* service_worker_scope */)
+
+// // Notify the browser that the given extension added a listener to instances of
+// // the named event that satisfy the filter.
+// // If |sw_identifier| is specified, it implies that the listener is for a
+// // service worker, and the param is used to identify the worker.
+// IPC_MESSAGE_CONTROL5(
+//     ExtensionHostMsg_AddFilteredListener,
+//     std::string /* extension_id */,
+//     std::string /* name */,
+//     base::Optional<ServiceWorkerIdentifier> /* sw_identifier */,
+//     base::DictionaryValue /* filter */,
+//     bool /* lazy */)
+
+// // Notify the browser that the given extension is no longer interested in
+// // instances of the named event that satisfy the filter.
+// // If |sw_identifier| is specified, it implies that the listener is for a
+// // service worker, and the param is used to identify the worker.
+// IPC_MESSAGE_CONTROL5(
+//     ExtensionHostMsg_RemoveFilteredListener,
+//     std::string /* extension_id */,
+//     std::string /* name */,
+//     base::Optional<ServiceWorkerIdentifier> /* sw_identifier */,
+//     base::DictionaryValue /* filter */,
+//     bool /* lazy */)
+
+// // Notify the browser that an event has finished being dispatched.
+// IPC_MESSAGE_ROUTED1(ExtensionHostMsg_EventAck, int /* message_id */)
+
+// // Open a channel to all listening contexts owned by the extension with
+// // the given ID. This responds asynchronously with ExtensionMsg_AssignPortId.
+// // If an error occurred, the opener will be notified asynchronously.
+// IPC_MESSAGE_CONTROL4(ExtensionHostMsg_OpenChannelToExtension,
+//                      extensions::PortContext /* source_context */,
+//                      ExtensionMsg_ExternalConnectionInfo,
+//                      std::string /* channel_name */,
+//                      extensions::PortId /* port_id */)
+
+// IPC_MESSAGE_CONTROL3(ExtensionHostMsg_OpenChannelToNativeApp,
+//                      extensions::PortContext /* source_context */,
+//                      std::string /* native_app_name */,
+//                      extensions::PortId /* port_id */)
+
+// // Get a port handle to the given tab.  The handle can be used for sending
+// // messages to the extension.
+// IPC_MESSAGE_CONTROL5(ExtensionHostMsg_OpenChannelToTab,
+//                      extensions::PortContext /* source_context */,
+//                      ExtensionMsg_TabTargetConnectionInfo,
+//                      std::string /* extension_id */,
+//                      std::string /* channel_name */,
+//                      extensions::PortId /* port_id */)
+
+// // Sent in response to ExtensionMsg_DispatchOnConnect when the port is accepted.
+// // The handle is the value returned by ExtensionHostMsg_OpenChannelTo*.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_OpenMessagePort,
+//                      extensions::PortContext /* port_context */,
+//                      extensions::PortId /* port_id */)
+
+// // Sent in response to ExtensionMsg_DispatchOnConnect and whenever the port is
+// // closed. The handle is the value returned by ExtensionHostMsg_OpenChannelTo*.
+// IPC_MESSAGE_CONTROL3(ExtensionHostMsg_CloseMessagePort,
+//                      extensions::PortContext /* port_context */,
+//                      extensions::PortId /* port_id */,
+//                      bool /* force_close */)
+
+// // Send a message to an extension process.  The handle is the value returned
+// // by ExtensionHostMsg_OpenChannelTo*.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_PostMessage,
+//                      extensions::PortId /* port_id */,
+//                      extensions::Message)
+
+// // Used to get the extension message bundle.
+// IPC_SYNC_MESSAGE_CONTROL1_1(ExtensionHostMsg_GetMessageBundle,
+//                             std::string /* extension id */,
+//                             SubstitutionMap /* message bundle */)
+
+// // Sent from the renderer to the browser to return the script running result.
+// IPC_MESSAGE_ROUTED4(
+//     ExtensionHostMsg_ExecuteCodeFinished,
+//     int /* request id */,
+//     std::string /* error; empty implies success */,
+//     GURL /* URL of the code executed on. May be empty if unsuccessful. */,
+//     base::ListValue /* result of the script */)
+
+// // Sent from the renderer to the browser to notify that content scripts are
+// // running in the renderer that the IPC originated from.
+// IPC_MESSAGE_ROUTED2(ExtensionHostMsg_ContentScriptsExecuting,
+//                     ExecutingScriptsMap,
+//                     GURL /* url of the _topmost_ frame */)
+
+// // Sent from the renderer to the browser to request permission for a script
+// // injection.
+// // If request id is -1, this signals that the request has already ran, and this
+// // merely serves as a notification. This happens when the feature to disable
+// // scripts running without user consent is not enabled.
+// IPC_MESSAGE_ROUTED4(ExtensionHostMsg_RequestScriptInjectionPermission,
+//                     std::string /* extension id */,
+//                     extensions::UserScript::InjectionType /* script type */,
+//                     extensions::UserScript::RunLocation /* run location */,
+//                     int64_t /* request id */)
+
+// // Sent from the browser to the renderer in reply to a
+// // RequestScriptInjectionPermission message, granting permission for a script
+// // script to run.
+// IPC_MESSAGE_ROUTED1(ExtensionMsg_PermitScriptInjection,
+//                     int64_t /* request id */)
+
+// // Sent by the renderer when a web page is checking if its app is installed.
+// IPC_MESSAGE_ROUTED3(ExtensionHostMsg_GetAppInstallState,
+//                     GURL /* requestor_url */,
+//                     int32_t /* return_route_id */,
+//                     int32_t /* callback_id */)
+
+// // Optional Ack message sent to the browser to notify that the response to a
+// // function has been processed.
+// IPC_MESSAGE_ROUTED1(ExtensionHostMsg_ResponseAck,
+//                     int /* request_id */)
+
+// // Response to ExtensionMsg_ShouldSuspend.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_ShouldSuspendAck,
+//                      std::string /* extension_id */,
+//                      uint64_t /* sequence_id */)
+
+// // Response to ExtensionMsg_Suspend, after we dispatch the suspend event.
+// IPC_MESSAGE_CONTROL1(ExtensionHostMsg_SuspendAck,
+//                      std::string /* extension_id */)
+
+// // Informs the browser to increment the keepalive count for the lazy background
+// // page, keeping it alive.
+// IPC_MESSAGE_ROUTED0(ExtensionHostMsg_IncrementLazyKeepaliveCount)
+
+// // Informs the browser there is one less thing keeping the lazy background page
+// // alive.
+// IPC_MESSAGE_ROUTED0(ExtensionHostMsg_DecrementLazyKeepaliveCount)
+
+// // Notify the browser that an app window is ready and can resume resource
+// // requests.
+// IPC_MESSAGE_ROUTED0(ExtensionHostMsg_AppWindowReady)
+
+// // Sent by the renderer when the draggable regions are updated.
+// IPC_MESSAGE_ROUTED1(ExtensionHostMsg_UpdateDraggableRegions,
+//                     std::vector<extensions::DraggableRegion> /* regions */)
+
+// // Sent by the renderer to log an API action to the extension activity log.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_AddAPIActionToActivityLog,
+//                      std::string /* extension_id */,
+//                      ExtensionHostMsg_APIActionOrEvent_Params)
+
+// // Sent by the renderer to log an event to the extension activity log.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_AddEventToActivityLog,
+//                     std::string /* extension_id */,
+//                     ExtensionHostMsg_APIActionOrEvent_Params)
+
+// // Sent by the renderer to log a DOM action to the extension activity log.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_AddDOMActionToActivityLog,
+//                      std::string /* extension_id */,
+//                      ExtensionHostMsg_DOMAction_Params)
+
+// // Notifies the browser process that a tab has started or stopped matching
+// // certain conditions.  This message is sent in response to several events:
+// //
+// // * ExtensionMsg_WatchPages was received, updating the set of conditions.
+// // * A new page is loaded.  This will be sent after
+// //   mojom::FrameHost::DidCommitProvisionalLoad. Currently this only fires for
+// //   the main frame.
+// // * Something changed on an existing frame causing the set of matching searches
+// //   to change.
+// IPC_MESSAGE_ROUTED1(ExtensionHostMsg_OnWatchedPageChange,
+//                     std::vector<std::string> /* Matching CSS selectors */)
+
+// // Sent by the renderer when it has received a Blob handle from the browser.
+// IPC_MESSAGE_CONTROL1(ExtensionHostMsg_TransferBlobsAck,
+//                      std::vector<std::string> /* blob_uuids */)
+
+// // Asks the browser to wake the event page of an extension.
+// // The browser will reply with ExtensionHostMsg_WakeEventPageResponse.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_WakeEventPage,
+//                      int /* request_id */,
+//                      std::string /* extension_id */)
+
+// // Tells listeners that a detailed message was reported to the console by
+// // WebKit.
+// IPC_MESSAGE_ROUTED4(ExtensionHostMsg_DetailedConsoleMessageAdded,
+//                     base::string16 /* message */,
+//                     base::string16 /* source */,
+//                     extensions::StackTrace /* stack trace */,
+//                     int32_t /* severity level */)
+
+// // Sent when a query selector request is made from the automation API.
+// // acc_obj_id is the accessibility tree ID of the starting element.
+// IPC_MESSAGE_ROUTED3(ExtensionMsg_AutomationQuerySelector,
+//                     int /* request_id */,
+//                     int /* acc_obj_id */,
+//                     base::string16 /* selector */)
+
+// // Result of a query selector request.
+// // result_acc_obj_id is the accessibility tree ID of the result element; 0
+// // indicates no result.
+// IPC_MESSAGE_ROUTED3(ExtensionHostMsg_AutomationQuerySelector_Result,
+//                     int /* request_id */,
+//                     ExtensionHostMsg_AutomationQuerySelector_Error /* error */,
+//                     int /* result_acc_obj_id */)
+
+// // Tells the renderer whether or not activity logging is enabled. This is only
+// // sent if logging is or was previously enabled; not being enabled is assumed
+// // otherwise.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_SetActivityLoggingEnabled, bool /* enabled */)
+
+// // Messages related to Extension Service Worker.
+// #undef IPC_MESSAGE_START
+// #define IPC_MESSAGE_START ExtensionWorkerMsgStart
+// // A service worker thread sends this message when an extension service worker
+// // starts an API request. The browser will always respond with a
+// // ExtensionMsg_ResponseWorker.
+// IPC_MESSAGE_CONTROL1(ExtensionHostMsg_RequestWorker,
+//                      ExtensionHostMsg_Request_Params)
+
+// // The browser sends this message in response to all service worker extension
+// // api calls. The response data (if any) is one of the base::Value subclasses,
+// // wrapped as the first element in a ListValue.
+// IPC_MESSAGE_CONTROL5(ExtensionMsg_ResponseWorker,
+//                      int /* thread_id */,
+//                      int /* request_id */,
+//                      bool /* success */,
+//                      base::ListValue /* response wrapper (see comment above) */,
+//                      std::string /* error */)
+
+// // Asks the browser to increment the pending activity count for
+// // the worker with version id |service_worker_version_id|.
+// // Each request to increment must use unique |request_uuid|. If a request with
+// // |request_uuid| is already in progress (due to race condition or renderer
+// // compromise), browser process ignores the IPC.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_IncrementServiceWorkerActivity,
+//                      int64_t /* service_worker_version_id */,
+//                      std::string /* request_uuid */)
+
+// // Asks the browser to decrement the pending activity count for
+// // the worker with version id |service_worker_version_id|.
+// // |request_uuid| must match the GUID of a previous request, otherwise the
+// // browser process ignores the IPC.
+// IPC_MESSAGE_CONTROL2(ExtensionHostMsg_DecrementServiceWorkerActivity,
+//                      int64_t /* service_worker_version_id */,
+//                      std::string /* request_uuid */)
+
+// // Tells the browser that an event with |event_id| was successfully dispatched
+// // to the worker with version |service_worker_version_id|.
+// IPC_MESSAGE_CONTROL4(ExtensionHostMsg_EventAckWorker,
+//                      std::string /* extension_id */,
+//                      int64_t /* service_worker_version_id */,
+//                      int /* worker_thread_id */,
+//                      int /* event_id */)
+
+// // Tells the browser that an extension service worker context was initialized,
+// // but possibly didn't start executing its top-level JavaScript.
+// IPC_MESSAGE_CONTROL3(ExtensionHostMsg_DidInitializeServiceWorkerContext,
+//                      std::string /* extension_id */,
+//                      int64_t /* service_worker_version_id */,
+//                      int /* worker_thread_id */)
+
+// // Tells the browser that an extension service worker context has started and
+// // finished executing its top-level JavaScript.
+// // Start corresponds to EmbeddedWorkerInstance::OnStarted notification.
+// //
+// // TODO(lazyboy): This is a workaround: ideally this IPC should be redundant
+// // because it directly corresponds to EmbeddedWorkerInstance::OnStarted message.
+// // However, because OnStarted message is on different mojo IPC pipe, and most
+// // extension IPCs are on legacy IPC pipe, this IPC is necessary to ensure FIFO
+// // ordering of this message with rest of the extension IPCs.
+// // Two possible solutions to this:
+// //   - Associate extension IPCs with Service Worker IPCs. This can be done (and
+// //     will be a requirement) when extension IPCs are moved to mojo, but
+// //     requires resolving or defining ordering dependencies amongst the
+// //     extension messages, and any additional messages in Chrome.
+// //   - Make Service Worker IPCs channel-associated so that there's FIFO
+// //     guarantee between extension IPCs and Service Worker IPCs. This isn't
+// //     straightforward as it changes SW IPC ordering with respect of rest of
+// //     Chrome.
+// // See https://crbug.com/879015#c4 for details.
+// IPC_MESSAGE_CONTROL5(ExtensionHostMsg_DidStartServiceWorkerContext,
+//                      std::string /* extension_id */,
+//                      extensions::ActivationSequence /* activation_sequence */,
+//                      GURL /* service_worker_scope */,
+//                      int64_t /* service_worker_version_id */,
+//                      int /* worker_thread_id */)
+
+// // Tells the browser that an extension service worker context has been
+// // destroyed.
+// IPC_MESSAGE_CONTROL5(ExtensionHostMsg_DidStopServiceWorkerContext,
+//                      std::string /* extension_id */,
+//                      extensions::ActivationSequence /* activation_sequence */,
+//                      GURL /* service_worker_scope */,
+//                      int64_t /* service_worker_version_id */,
+//                      int /* worker_thread_id */)
+
+// IPC_STRUCT_BEGIN(ExtensionMsg_AccessibilityEventBundleParams)
+//   // ID of the accessibility tree that this event applies to.
+//   IPC_STRUCT_MEMBER(ui::AXTreeID, tree_id)
+
+//   // Zero or more updates to the accessibility tree to apply first.
+//   IPC_STRUCT_MEMBER(std::vector<ui::AXTreeUpdate>, updates)
+
+//   // Zero or more events to fire after the tree updates have been applied.
+//   IPC_STRUCT_MEMBER(std::vector<ui::AXEvent>, events)
+
+//   // The mouse location in screen coordinates.
+//   IPC_STRUCT_MEMBER(gfx::Point, mouse_location)
+// IPC_STRUCT_END()
+
+// IPC_STRUCT_BEGIN(ExtensionMsg_AccessibilityLocationChangeParams)
+//   // ID of the accessibility tree that this event applies to.
+//   IPC_STRUCT_MEMBER(ui::AXTreeID, tree_id)
+
+//   // ID of the object whose location is changing.
+//   IPC_STRUCT_MEMBER(int, id)
+
+//   // The object's new location info.
+//   IPC_STRUCT_MEMBER(ui::AXRelativeBounds, new_location)
+// IPC_STRUCT_END()
+
+// // Forward an accessibility message to an extension process where an
+// // extension is using the automation API to listen for accessibility events.
+// IPC_MESSAGE_CONTROL2(ExtensionMsg_AccessibilityEventBundle,
+//                      ExtensionMsg_AccessibilityEventBundleParams /* events */,
+//                      bool /* is_active_profile */)
+
+// // Forward an accessibility location change message to an extension process
+// // where an extension is using the automation API to listen for
+// // accessibility events.
+// IPC_MESSAGE_CONTROL1(ExtensionMsg_AccessibilityLocationChange,
+//                      ExtensionMsg_AccessibilityLocationChangeParams)
+
+#endif  // EXTENSIONS_COMMON_EXTENSION_MESSAGES_H_
diff --git a/components/user_scripts/content/common/host_id.cc b/components/user_scripts/content/common/host_id.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/host_id.cc
@@ -0,0 +1,31 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "host_id.h"
+
+#include <tuple>
+
+HostID::HostID()
+    : type_(HostType::EXTENSIONS) {
+}
+
+HostID::HostID(HostType type, const std::string& id)
+    : type_(type), id_(id) {
+}
+
+HostID::HostID(const HostID& host_id)
+    : type_(host_id.type()),
+      id_(host_id.id()) {
+}
+
+HostID::~HostID() {
+}
+
+bool HostID::operator<(const HostID& host_id) const {
+  return std::tie(type_, id_) < std::tie(host_id.type_, host_id.id_);
+}
+
+bool HostID::operator==(const HostID& host_id) const {
+  return type_ == host_id.type_ && id_ == host_id.id_;
+}
diff --git a/components/user_scripts/content/common/host_id.h b/components/user_scripts/content/common/host_id.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/host_id.h
@@ -0,0 +1,35 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_COMMON_HOST_ID_H_
+#define EXTENSIONS_COMMON_HOST_ID_H_
+
+#include <string>
+
+// IDs of hosts who own user scripts.
+// A HostID is immutable after creation.
+struct HostID {
+  enum HostType { EXTENSIONS, WEBUI, HOST_TYPE_LAST = WEBUI };
+
+  HostID();
+  HostID(HostType type, const std::string& id);
+  HostID(const HostID& host_id);
+  ~HostID();
+
+  bool operator<(const HostID& host_id) const;
+  bool operator==(const HostID& host_id) const;
+
+  HostType type() const { return type_; }
+  const std::string& id() const { return id_; }
+
+ private:
+  // The type of the host.
+  HostType type_;
+
+  // Similar to extension_id, host_id is a unique indentifier for a host,
+  // e.g., an Extension or WebUI.
+  std::string id_;
+};
+
+#endif  // EXTENSIONS_COMMON_HOST_ID_H_
diff --git a/components/user_scripts/content/common/script_constants.h b/components/user_scripts/content/common/script_constants.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/script_constants.h
@@ -0,0 +1,33 @@
+// Copyright 2020 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_COMMON_SCRIPT_CONSTANTS_H_
+#define EXTENSIONS_COMMON_SCRIPT_CONSTANTS_H_
+
+namespace user_scripts {
+
+// Whether to fall back to matching the origin for frames where the URL
+// cannot be matched directly, such as those with about: or data: schemes.
+enum class MatchOriginAsFallbackBehavior {
+  // Never fall back on the origin; this means scripts will never match on
+  // these frames.
+  kNever,
+  // Match the origin only for about:-scheme frames, and then climb the frame
+  // tree to find an appropriate ancestor to get a full URL (including path).
+  // This is for supporting the "match_about_blank" key.
+  // TODO(devlin): I wonder if we could simplify this to be "MatchForAbout",
+  // and not worry about climbing the frame tree. It would be a behavior
+  // change, but I wonder how many extensions it would impact in practice.
+  kMatchForAboutSchemeAndClimbTree,
+  // Match the origin as a fallback whenever applicable. This won't have a
+  // corresponding path.
+  kAlways,
+};
+
+// TODO(devlin): Move the other non-UserScript-specific constants like
+// RunLocation and InjectionType from UserScript into here.
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_COMMON_SCRIPT_CONSTANTS_H_
diff --git a/components/user_scripts/content/common/url_pattern.cc b/components/user_scripts/content/common/url_pattern.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/url_pattern.cc
@@ -0,0 +1,807 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "url_pattern.h"
+
+#include <stddef.h>
+
+#include <ostream>
+
+#include "base/logging.h"
+#include "base/stl_util.h"
+#include "base/strings/pattern.h"
+#include "base/strings/strcat.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_split.h"
+#include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "content/public/common/url_constants.h"
+#include "constants.h"
+#include "net/base/registry_controlled_domains/registry_controlled_domain.h"
+#include "net/base/url_util.h"
+#include "url/gurl.h"
+#include "url/url_util.h"
+
+const char URLPattern::kAllUrlsPattern[] = "<all_urls>";
+
+namespace {
+
+// TODO(aa): What about more obscure schemes like javascript: ?
+// Note: keep this array in sync with kValidSchemeMasks.
+const char* const kValidSchemes[] = {
+    url::kHttpScheme,         url::kHttpsScheme,
+    url::kFileScheme,         url::kFtpScheme,
+    /*content::kChromeUIScheme,*/ /*extensions::kExtensionScheme,*/
+    url::kFileSystemScheme,   url::kWsScheme,
+    url::kWssScheme,          url::kDataScheme,
+};
+
+const int kValidSchemeMasks[] = {
+    URLPattern::SCHEME_HTTP,       URLPattern::SCHEME_HTTPS,
+    URLPattern::SCHEME_FILE,       URLPattern::SCHEME_FTP,
+    /*URLPattern::SCHEME_CHROMEUI,*/   /*URLPattern::SCHEME_EXTENSION,*/
+    URLPattern::SCHEME_FILESYSTEM, URLPattern::SCHEME_WS,
+    URLPattern::SCHEME_WSS,        URLPattern::SCHEME_DATA,
+};
+
+static_assert(base::size(kValidSchemes) == base::size(kValidSchemeMasks),
+              "must keep these arrays in sync");
+
+const char kParseSuccess[] = "Success.";
+const char kParseErrorMissingSchemeSeparator[] = "Missing scheme separator.";
+const char kParseErrorInvalidScheme[] = "Invalid scheme.";
+const char kParseErrorWrongSchemeType[] = "Wrong scheme type.";
+const char kParseErrorEmptyHost[] = "Host can not be empty.";
+const char kParseErrorInvalidHostWildcard[] = "Invalid host wildcard.";
+const char kParseErrorEmptyPath[] = "Empty path.";
+const char kParseErrorInvalidPort[] = "Invalid port.";
+const char kParseErrorInvalidHost[] = "Invalid host.";
+
+// Message explaining each URLPattern::ParseResult.
+const char* const kParseResultMessages[] = {
+  kParseSuccess,
+  kParseErrorMissingSchemeSeparator,
+  kParseErrorInvalidScheme,
+  kParseErrorWrongSchemeType,
+  kParseErrorEmptyHost,
+  kParseErrorInvalidHostWildcard,
+  kParseErrorEmptyPath,
+  kParseErrorInvalidPort,
+  kParseErrorInvalidHost,
+};
+
+static_assert(static_cast<int>(URLPattern::ParseResult::kNumParseResults) ==
+                  base::size(kParseResultMessages),
+              "must add message for each parse result");
+
+const char kPathSeparator[] = "/";
+
+bool IsStandardScheme(base::StringPiece scheme) {
+  // "*" gets the same treatment as a standard scheme.
+  if (scheme == "*")
+    return true;
+
+  return url::IsStandard(scheme.data(),
+                         url::Component(0, static_cast<int>(scheme.length())));
+}
+
+bool IsValidPortForScheme(base::StringPiece scheme, base::StringPiece port) {
+  if (port == "*")
+    return true;
+
+  // Only accept non-wildcard ports if the scheme uses ports.
+  if (url::DefaultPortForScheme(scheme.data(), scheme.length()) ==
+      url::PORT_UNSPECIFIED) {
+    return false;
+  }
+
+  int parsed_port = url::PORT_UNSPECIFIED;
+  if (!base::StringToInt(port, &parsed_port))
+    return false;
+  return (parsed_port >= 0) && (parsed_port < 65536);
+}
+
+// Returns |path| with the trailing wildcard stripped if one existed.
+//
+// The functions that rely on this (OverlapsWith and Contains) are only
+// called for the patterns inside URLPatternSet. In those cases, we know that
+// the path will have only a single wildcard at the end. This makes figuring
+// out overlap much easier. It seems like there is probably a computer-sciency
+// way to solve the general case, but we don't need that yet.
+base::StringPiece StripTrailingWildcard(base::StringPiece path) {
+  if (base::EndsWith(path, "*"))
+    path.remove_suffix(1);
+  return path;
+}
+
+// Removes trailing dot from |host_piece| if any.
+base::StringPiece CanonicalizeHostForMatching(base::StringPiece host_piece) {
+  if (base::EndsWith(host_piece, "."))
+    host_piece.remove_suffix(1);
+  return host_piece;
+}
+
+}  // namespace
+
+// static
+bool URLPattern::IsValidSchemeForExtensions(base::StringPiece scheme) {
+  for (size_t i = 0; i < base::size(kValidSchemes); ++i) {
+    if (scheme == kValidSchemes[i])
+      return true;
+  }
+  return false;
+}
+
+// static
+int URLPattern::GetValidSchemeMaskForExtensions() {
+  int result = 0;
+  for (size_t i = 0; i < base::size(kValidSchemeMasks); ++i)
+    result |= kValidSchemeMasks[i];
+  return result;
+}
+
+URLPattern::URLPattern()
+    : valid_schemes_(SCHEME_NONE),
+      match_all_urls_(false),
+      match_subdomains_(false),
+      port_("*") {}
+
+URLPattern::URLPattern(int valid_schemes)
+    : valid_schemes_(valid_schemes),
+      match_all_urls_(false),
+      match_subdomains_(false),
+      port_("*") {}
+
+URLPattern::URLPattern(int valid_schemes, base::StringPiece pattern)
+    // Strict error checking is used, because this constructor is only
+    // appropriate when we know |pattern| is valid.
+    : valid_schemes_(valid_schemes),
+      match_all_urls_(false),
+      match_subdomains_(false),
+      port_("*") {
+  ParseResult result = Parse(pattern);
+  if (result != ParseResult::kSuccess) {
+    const char* error_string = GetParseResultString(result);
+    // Temporarily add more logging to investigate why this code path is
+    // reached. For http://crbug.com/856948
+    LOG(ERROR) << "Invalid pattern was given " << pattern << " result "
+               << error_string;
+    NOTREACHED() << "URLPattern invalid: '" << pattern
+                 << "'; error: " << error_string;
+  }
+}
+
+URLPattern::URLPattern(const URLPattern& other) = default;
+
+URLPattern::URLPattern(URLPattern&& other) = default;
+
+URLPattern::~URLPattern() {
+}
+
+URLPattern& URLPattern::operator=(const URLPattern& other) = default;
+
+URLPattern& URLPattern::operator=(URLPattern&& other) = default;
+
+bool URLPattern::operator<(const URLPattern& other) const {
+  return GetAsString() < other.GetAsString();
+}
+
+bool URLPattern::operator>(const URLPattern& other) const {
+  return GetAsString() > other.GetAsString();
+}
+
+bool URLPattern::operator==(const URLPattern& other) const {
+  return GetAsString() == other.GetAsString();
+}
+
+std::ostream& operator<<(std::ostream& out, const URLPattern& url_pattern) {
+  return out << '"' << url_pattern.GetAsString() << '"';
+}
+
+URLPattern::ParseResult URLPattern::Parse(base::StringPiece pattern) {
+  spec_.clear();
+  SetMatchAllURLs(false);
+  SetMatchSubdomains(false);
+  SetPort("*");
+
+  // Special case pattern to match every valid URL.
+  if (pattern == kAllUrlsPattern) {
+    SetMatchAllURLs(true);
+    return ParseResult::kSuccess;
+  }
+
+  // Parse out the scheme.
+  size_t scheme_end_pos = pattern.find(url::kStandardSchemeSeparator);
+  bool has_standard_scheme_separator = true;
+
+  // Some urls also use ':' alone as the scheme separator.
+  if (scheme_end_pos == base::StringPiece::npos) {
+    scheme_end_pos = pattern.find(':');
+    has_standard_scheme_separator = false;
+  }
+
+  if (scheme_end_pos == base::StringPiece::npos)
+    return ParseResult::kMissingSchemeSeparator;
+
+  if (!SetScheme(pattern.substr(0, scheme_end_pos)))
+    return ParseResult::kInvalidScheme;
+
+  bool standard_scheme = IsStandardScheme(scheme_);
+  if (standard_scheme != has_standard_scheme_separator)
+    return ParseResult::kWrongSchemeSeparator;
+
+  // Advance past the scheme separator.
+  scheme_end_pos +=
+      (standard_scheme ? strlen(url::kStandardSchemeSeparator) : 1);
+  if (scheme_end_pos >= pattern.size())
+    return ParseResult::kEmptyHost;
+
+  // Parse out the host and path.
+  size_t host_start_pos = scheme_end_pos;
+  size_t path_start_pos = 0;
+
+  if (!standard_scheme) {
+    path_start_pos = host_start_pos;
+  } else if (scheme_ == url::kFileScheme) {
+    size_t host_end_pos = pattern.find(kPathSeparator, host_start_pos);
+    if (host_end_pos == base::StringPiece::npos) {
+      // Allow hostname omission.
+      // e.g. file://* is interpreted as file:///*,
+      // file://foo* is interpreted as file:///foo*.
+      path_start_pos = host_start_pos - 1;
+    } else {
+      // Ignore hostname if scheme is file://.
+      // e.g. file://localhost/foo is equal to file:///foo.
+      path_start_pos = host_end_pos;
+    }
+  } else {
+    size_t host_end_pos = pattern.find(kPathSeparator, host_start_pos);
+
+    // Host is required.
+    if (host_start_pos == host_end_pos)
+      return ParseResult::kEmptyHost;
+
+    if (host_end_pos == base::StringPiece::npos)
+      return ParseResult::kEmptyPath;
+
+    base::StringPiece host_and_port =
+        pattern.substr(host_start_pos, host_end_pos - host_start_pos);
+
+    size_t port_separator_pos = base::StringPiece::npos;
+    if (host_and_port[0] != '[') {
+      // Not IPv6 (either IPv4 or just a normal address).
+      port_separator_pos = host_and_port.find(':');
+    } else {  // IPv6.
+      size_t host_end_pos = host_and_port.find(']');
+      if (host_end_pos == base::StringPiece::npos)
+        return ParseResult::kInvalidHost;
+      if (host_end_pos == 1)
+        return ParseResult::kEmptyHost;
+
+      if (host_end_pos < host_and_port.length() - 1) {
+        // The host isn't the only component. Check for a port. This would
+        // require a ':' to follow the closing ']' from the host.
+        if (host_and_port[host_end_pos + 1] != ':')
+          return ParseResult::kInvalidHost;
+
+        port_separator_pos = host_end_pos + 1;
+      }
+    }
+
+    if (port_separator_pos != base::StringPiece::npos &&
+        !SetPort(host_and_port.substr(port_separator_pos + 1))) {
+      return ParseResult::kInvalidPort;
+    }
+
+    // Note: this substr() will be the entire string if the port position
+    // wasn't found.
+    base::StringPiece host_piece = host_and_port.substr(0, port_separator_pos);
+
+    if (host_piece.empty())
+      return ParseResult::kEmptyHost;
+
+    if (host_piece == "*") {
+      match_subdomains_ = true;
+      host_piece = base::StringPiece();
+    } else if (base::StartsWith(host_piece, "*.")) {
+      if (host_piece.length() == 2) {
+        // We don't allow just '*.' as a host.
+        return ParseResult::kEmptyHost;
+      }
+      match_subdomains_ = true;
+      host_piece = host_piece.substr(2);
+    }
+
+    host_ = host_piece.as_string();
+
+    path_start_pos = host_end_pos;
+  }
+
+  SetPath(pattern.substr(path_start_pos));
+
+  // No other '*' can occur in the host, though. This isn't necessary, but is
+  // done as a convenience to developers who might otherwise be confused and
+  // think '*' works as a glob in the host.
+  if (host_.find('*') != std::string::npos)
+    return ParseResult::kInvalidHostWildcard;
+
+  if (!host_.empty()) {
+    // If |host_| is present (i.e., isn't a wildcard), we need to canonicalize
+    // it.
+    url::CanonHostInfo host_info;
+    host_ = net::CanonicalizeHost(host_, &host_info);
+    // net::CanonicalizeHost() returns an empty string on failure.
+    if (host_.empty())
+      return ParseResult::kInvalidHost;
+  }
+
+  // Null characters are not allowed in hosts.
+  if (host_.find('\0') != std::string::npos)
+    return ParseResult::kInvalidHost;
+
+  return ParseResult::kSuccess;
+}
+
+void URLPattern::SetValidSchemes(int valid_schemes) {
+  // TODO(devlin): Should we check that valid_schemes agrees with |scheme_|
+  // here? Otherwise, valid_schemes_ and schemes_ may stop agreeing with each
+  // other (e.g., in the case of `*://*/*`, where the scheme should only be
+  // http or https).
+  spec_.clear();
+  valid_schemes_ = valid_schemes;
+}
+
+void URLPattern::SetHost(base::StringPiece host) {
+  spec_.clear();
+  host_.assign(host.data(), host.size());
+}
+
+void URLPattern::SetMatchAllURLs(bool val) {
+  spec_.clear();
+  match_all_urls_ = val;
+
+  if (val) {
+    match_subdomains_ = true;
+    scheme_ = "*";
+    host_.clear();
+    SetPath("/*");
+  }
+}
+
+void URLPattern::SetMatchSubdomains(bool val) {
+  spec_.clear();
+  match_subdomains_ = val;
+}
+
+bool URLPattern::SetScheme(base::StringPiece scheme) {
+  spec_.clear();
+  scheme_.assign(scheme.data(), scheme.size());
+  if (scheme_ == "*") {
+    valid_schemes_ &= (SCHEME_HTTP | SCHEME_HTTPS);
+  } else if (!IsValidScheme(scheme_)) {
+    return false;
+  }
+  return true;
+}
+
+bool URLPattern::IsValidScheme(base::StringPiece scheme) const {
+  if (valid_schemes_ == SCHEME_ALL)
+    return true;
+
+  for (size_t i = 0; i < base::size(kValidSchemes); ++i) {
+    if (scheme == kValidSchemes[i] && (valid_schemes_ & kValidSchemeMasks[i]))
+      return true;
+  }
+
+  return false;
+}
+
+void URLPattern::SetPath(base::StringPiece path) {
+  spec_.clear();
+  path_.assign(path.data(), path.size());
+  path_escaped_ = path_;
+  base::ReplaceSubstringsAfterOffset(&path_escaped_, 0, "\\", "\\\\");
+  base::ReplaceSubstringsAfterOffset(&path_escaped_, 0, "?", "\\?");
+}
+
+bool URLPattern::SetPort(base::StringPiece port) {
+  spec_.clear();
+  if (IsValidPortForScheme(scheme_, port)) {
+    port_.assign(port.data(), port.size());
+    return true;
+  }
+  return false;
+}
+
+bool URLPattern::MatchesURL(const GURL& test) const {
+  // Invalid URLs can never match.
+  if (!test.is_valid())
+    return false;
+
+  const GURL* test_url = &test;
+  bool has_inner_url = test.inner_url() != nullptr;
+
+  if (has_inner_url) {
+    if (!test.SchemeIsFileSystem())
+      return false;  // The only nested URLs we handle are filesystem URLs.
+    test_url = test.inner_url();
+  }
+
+  // Ensure the scheme matches first, since <all_urls> may not match this URL if
+  // the scheme is excluded.
+  if (!MatchesScheme(test_url->scheme_piece()))
+    return false;
+
+  if (match_all_urls_)
+    return true;
+
+  // Unless |match_all_urls_| is true, the grammar only permits matching
+  // URLs with nonempty paths.
+  if (!test.has_path())
+    return false;
+
+  std::string path_for_request = test.PathForRequest();
+  if (has_inner_url) {
+    path_for_request = base::StringPrintf("%s%s", test_url->path_piece().data(),
+                                          path_for_request.c_str());
+  }
+
+  return MatchesSecurityOriginHelper(*test_url) &&
+         MatchesPath(path_for_request);
+}
+
+bool URLPattern::MatchesSecurityOrigin(const GURL& test) const {
+  const GURL* test_url = &test;
+  bool has_inner_url = test.inner_url() != NULL;
+
+  if (has_inner_url) {
+    if (!test.SchemeIsFileSystem())
+      return false;  // The only nested URLs we handle are filesystem URLs.
+    test_url = test.inner_url();
+  }
+
+  if (!MatchesScheme(test_url->scheme()))
+    return false;
+
+  if (match_all_urls_)
+    return true;
+
+  return MatchesSecurityOriginHelper(*test_url);
+}
+
+bool URLPattern::MatchesScheme(base::StringPiece test) const {
+  if (!IsValidScheme(test))
+    return false;
+
+  return scheme_ == "*" || test == scheme_;
+}
+
+bool URLPattern::MatchesHost(base::StringPiece host) const {
+  // TODO(devlin): This is a bit sad. Parsing urls is expensive. However, it's
+  // important that we do this conversion to a GURL in order to canonicalize the
+  // host (the pattern's host_ already is canonicalized from Parse()). We can't
+  // just do string comparison.
+  return MatchesHost(
+      GURL(base::StringPrintf("%s%s%s/", url::kHttpScheme,
+                              url::kStandardSchemeSeparator, host.data())));
+}
+
+bool URLPattern::MatchesHost(const GURL& test) const {
+  base::StringPiece test_host(CanonicalizeHostForMatching(test.host_piece()));
+  const base::StringPiece pattern_host(CanonicalizeHostForMatching(host_));
+
+  // If the hosts are exactly equal, we have a match.
+  if (test_host == pattern_host)
+    return true;
+
+  // If we're matching subdomains, and we have no host in the match pattern,
+  // that means that we're matching all hosts, which means we have a match no
+  // matter what the test host is.
+  if (match_subdomains_ && pattern_host.empty())
+    return true;
+
+  // Otherwise, we can only match if our match pattern matches subdomains.
+  if (!match_subdomains_)
+    return false;
+
+  // We don't do subdomain matching against IP addresses, so we can give up now
+  // if the test host is an IP address.
+  if (test.HostIsIPAddress())
+    return false;
+
+  // Check if the test host is a subdomain of our host.
+  if (test_host.length() <= (pattern_host.length() + 1))
+    return false;
+
+  if (!base::EndsWith(test_host, pattern_host))
+    return false;
+
+  return test_host[test_host.length() - pattern_host.length() - 1] == '.';
+}
+
+bool URLPattern::MatchesEffectiveTld(
+    net::registry_controlled_domains::PrivateRegistryFilter private_filter,
+    net::registry_controlled_domains::UnknownRegistryFilter unknown_filter)
+    const {
+  // Check if it matches all urls or is a pattern like http://*/*.
+  if (match_all_urls_ || (match_subdomains_ && host_.empty()))
+    return true;
+
+  // If this doesn't even match subdomains, it can't possibly be a TLD wildcard.
+  if (!match_subdomains_)
+    return false;
+
+  // If there was more than just a TLD in the host (e.g., *.foobar.com), it
+  // doesn't match all hosts in an effective TLD.
+  if (net::registry_controlled_domains::HostHasRegistryControlledDomain(
+          host_, unknown_filter, private_filter)) {
+    return false;
+  }
+
+  // At this point the host could either be just a TLD ("com") or some unknown
+  // TLD-like string ("notatld"). To disambiguate between them construct a
+  // fake URL, and check the registry.
+  //
+  // If we recognized this TLD, then this is a pattern like *.com, and it
+  // matches an effective TLD.
+  return net::registry_controlled_domains::HostHasRegistryControlledDomain(
+      "notatld." + host_, unknown_filter, private_filter);
+}
+
+bool URLPattern::MatchesSingleOrigin() const {
+  // Strictly speaking, the port is part of the origin, but in URLPattern it
+  // defaults to *. It's not very interesting anyway, so leave it out.
+  return !MatchesEffectiveTld() && scheme_ != "*" && !match_subdomains_;
+}
+
+bool URLPattern::MatchesPath(base::StringPiece test) const {
+  // Make the behaviour of OverlapsWith consistent with MatchesURL, which is
+  // need to match hosted apps on e.g. 'google.com' also run on 'google.com/'.
+  // The below if is a no-copy way of doing (test + "/*" == path_escaped_).
+  if (path_escaped_.length() == test.length() + 2 &&
+      base::StartsWith(path_escaped_.c_str(), test) &&
+      base::EndsWith(path_escaped_, "/*")) {
+    return true;
+  }
+
+  return base::MatchPattern(test, path_escaped_);
+}
+
+const std::string& URLPattern::GetAsString() const {
+  if (!spec_.empty())
+    return spec_;
+
+  if (match_all_urls_) {
+    spec_ = kAllUrlsPattern;
+    return spec_;
+  }
+
+  bool standard_scheme = IsStandardScheme(scheme_);
+
+  std::string spec = scheme_ +
+      (standard_scheme ? url::kStandardSchemeSeparator : ":");
+
+  if (scheme_ != url::kFileScheme && standard_scheme) {
+    if (match_subdomains_) {
+      spec += "*";
+      if (!host_.empty())
+        spec += ".";
+    }
+
+    if (!host_.empty())
+      spec += host_;
+
+    if (port_ != "*") {
+      spec += ":";
+      spec += port_;
+    }
+  }
+
+  if (!path_.empty())
+    spec += path_;
+
+  spec_ = std::move(spec);
+  return spec_;
+}
+
+bool URLPattern::OverlapsWith(const URLPattern& other) const {
+  if (match_all_urls() || other.match_all_urls())
+    return true;
+  return (MatchesAnyScheme(other.GetExplicitSchemes()) ||
+          other.MatchesAnyScheme(GetExplicitSchemes()))
+      && (MatchesHost(other.host()) || other.MatchesHost(host()))
+      && (MatchesPortPattern(other.port()) || other.MatchesPortPattern(port()))
+      && (MatchesPath(StripTrailingWildcard(other.path())) ||
+          other.MatchesPath(StripTrailingWildcard(path())));
+}
+
+bool URLPattern::Contains(const URLPattern& other) const {
+  // Important: it's not enough to just check match_all_urls(); we also need to
+  // make sure that the schemes in this pattern are a superset of those in
+  // |other|.
+  if (match_all_urls() &&
+      (valid_schemes_ & other.valid_schemes_) == other.valid_schemes_) {
+    return true;
+  }
+
+  return MatchesAllSchemes(other.GetExplicitSchemes()) &&
+         MatchesHost(other.host()) &&
+         (!other.match_subdomains_ || match_subdomains_) &&
+         MatchesPortPattern(other.port()) &&
+         MatchesPath(StripTrailingWildcard(other.path()));
+}
+
+base::Optional<URLPattern> URLPattern::CreateIntersection(
+    const URLPattern& other) const {
+  // Easy case: Schemes don't overlap. Return nullopt.
+  int intersection_schemes = URLPattern::SCHEME_NONE;
+  if (valid_schemes_ == URLPattern::SCHEME_ALL)
+    intersection_schemes = other.valid_schemes_;
+  else if (other.valid_schemes_ == URLPattern::SCHEME_ALL)
+    intersection_schemes = valid_schemes_;
+  else
+    intersection_schemes = valid_schemes_ & other.valid_schemes_;
+
+  if (intersection_schemes == URLPattern::SCHEME_NONE)
+    return base::nullopt;
+
+  {
+    // In a few cases, we can (mostly) return a copy of one of the patterns.
+    // This can happen when either:
+    // - The URLPattern's are identical (possibly excluding valid_schemes_)
+    // - One of the patterns has match_all_urls() equal to true.
+    // NOTE(devlin): Theoretically, we could use Contains() instead of
+    // match_all_urls() here. However, Contains() strips the trailing wildcard
+    // from the path, which could yield the incorrect result.
+    const URLPattern* copy_source = nullptr;
+    if (*this == other || other.match_all_urls())
+      copy_source = this;
+    else if (match_all_urls())
+      copy_source = &other;
+
+    if (copy_source) {
+      // NOTE: equality checks don't take into account valid_schemes_, and
+      // schemes can be different in the case of match_all_urls() as well, so
+      // we can't always just return *copy_source.
+      if (intersection_schemes == copy_source->valid_schemes_)
+        return *copy_source;
+      URLPattern result(intersection_schemes);
+      ParseResult parse_result = result.Parse(copy_source->GetAsString());
+      CHECK_EQ(ParseResult::kSuccess, parse_result);
+      return result;
+    }
+  }
+
+  // No more easy cases. Go through component by component to find the patterns
+  // that intersect.
+
+  // Note: Alias the function type (rather than using auto) because
+  // MatchesHost() is overloaded.
+  using match_function_type = bool (URLPattern::*)(base::StringPiece) const;
+
+  auto get_intersection = [this, &other](base::StringPiece own_str,
+                                         base::StringPiece other_str,
+                                         match_function_type match_function,
+                                         base::StringPiece* out) {
+    if ((this->*match_function)(other_str)) {
+      *out = other_str;
+      return true;
+    }
+    if ((other.*match_function)(own_str)) {
+      *out = own_str;
+      return true;
+    }
+    return false;
+  };
+
+  base::StringPiece scheme;
+  base::StringPiece host;
+  base::StringPiece port;
+  base::StringPiece path;
+  // If any pieces fail to overlap, then there is no intersection.
+  if (!get_intersection(scheme_, other.scheme_, &URLPattern::MatchesScheme,
+                        &scheme) ||
+      !get_intersection(host_, other.host_, &URLPattern::MatchesHost, &host) ||
+      !get_intersection(port_, other.port_, &URLPattern::MatchesPortPattern,
+                        &port) ||
+      !get_intersection(path_, other.path_, &URLPattern::MatchesPath, &path)) {
+    return base::nullopt;
+  }
+
+  // Only match subdomains if both patterns match subdomains.
+  base::StringPiece subdomains;
+  if (match_subdomains_ && other.match_subdomains_) {
+    // The host may be empty (e.g., in the case of *://*/* - in that case, only
+    // append '*' instead of '*.'.
+    subdomains = host.empty() ? "*" : "*.";
+  }
+
+  base::StringPiece scheme_separator =
+      IsStandardScheme(scheme) ? url::kStandardSchemeSeparator : ":";
+
+  std::string pattern_str = base::StrCat(
+      {scheme, scheme_separator, subdomains, host, ":", port, path});
+
+  URLPattern pattern(intersection_schemes);
+  ParseResult result = pattern.Parse(pattern_str);
+  // TODO(devlin): I don't think there's any way this should ever fail, but
+  // use a CHECK() to flush any cases out. If nothing crops up, downgrade this
+  // to a DCHECK in M72.
+  CHECK_EQ(ParseResult::kSuccess, result);
+
+  return pattern;
+}
+
+bool URLPattern::MatchesAnyScheme(
+    const std::vector<std::string>& schemes) const {
+  for (auto i = schemes.cbegin(); i != schemes.cend(); ++i) {
+    if (MatchesScheme(*i))
+      return true;
+  }
+
+  return false;
+}
+
+bool URLPattern::MatchesAllSchemes(
+    const std::vector<std::string>& schemes) const {
+  for (auto i = schemes.cbegin(); i != schemes.cend(); ++i) {
+    if (!MatchesScheme(*i))
+      return false;
+  }
+
+  return true;
+}
+
+bool URLPattern::MatchesSecurityOriginHelper(const GURL& test) const {
+  // Ignore hostname if scheme is file://.
+  if (scheme_ != url::kFileScheme && !MatchesHost(test))
+    return false;
+
+  if (!MatchesPortPattern(base::NumberToString(test.EffectiveIntPort())))
+    return false;
+
+  return true;
+}
+
+bool URLPattern::MatchesPortPattern(base::StringPiece port) const {
+  return port_ == "*" || port_ == port;
+}
+
+std::vector<std::string> URLPattern::GetExplicitSchemes() const {
+  std::vector<std::string> result;
+
+  if (scheme_ != "*" && !match_all_urls_ && IsValidScheme(scheme_)) {
+    result.push_back(scheme_);
+    return result;
+  }
+
+  for (size_t i = 0; i < base::size(kValidSchemes); ++i) {
+    if (MatchesScheme(kValidSchemes[i])) {
+      result.push_back(kValidSchemes[i]);
+    }
+  }
+
+  return result;
+}
+
+std::vector<URLPattern> URLPattern::ConvertToExplicitSchemes() const {
+  std::vector<std::string> explicit_schemes = GetExplicitSchemes();
+  std::vector<URLPattern> result;
+
+  for (std::vector<std::string>::const_iterator i = explicit_schemes.begin();
+       i != explicit_schemes.end(); ++i) {
+    URLPattern temp = *this;
+    temp.SetScheme(*i);
+    temp.SetMatchAllURLs(false);
+    result.push_back(temp);
+  }
+
+  return result;
+}
+
+// static
+const char* URLPattern::GetParseResultString(
+    URLPattern::ParseResult parse_result) {
+  return kParseResultMessages[static_cast<int>(parse_result)];
+}
diff --git a/components/user_scripts/content/common/url_pattern.h b/components/user_scripts/content/common/url_pattern.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/url_pattern.h
@@ -0,0 +1,301 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+#ifndef EXTENSIONS_COMMON_URL_PATTERN_H_
+#define EXTENSIONS_COMMON_URL_PATTERN_H_
+
+#include <functional>
+#include <iosfwd>
+#include <string>
+#include <vector>
+
+#include "base/strings/string_piece.h"
+#include "net/base/registry_controlled_domains/registry_controlled_domain.h"
+
+class GURL;
+
+// A pattern that can be used to match URLs. A URLPattern is a very restricted
+// subset of URL syntax:
+//
+// <url-pattern> := <scheme>://<host><port><path> | '<all_urls>'
+// <scheme> := '*' | 'http' | 'https' | 'file' | 'ftp' | 'chrome' |
+//             'chrome-extension' | 'filesystem'
+// <host> := '*' | <IPv4 address> | [<IPv6 address>] |
+//           '*.' <anychar except '/' and '*'>+
+// <port> := [':' ('*' | <port number between 0 and 65535>)]
+// <path> := '/' <any chars>
+//
+// * Host is not used when the scheme is 'file'.
+// * The path can have embedded '*' characters which act as glob wildcards.
+// * '<all_urls>' is a special pattern that matches any valid URL that contains
+//   a valid scheme (as specified by valid_schemes_).
+// * The '*' scheme pattern excludes file URLs.
+//
+// Examples of valid patterns:
+// - http://*/*
+// - http://*/foo*
+// - https://*.google.com/foo*bar
+// - file://monkey*
+// - http://127.0.0.1/*
+// - http://[2607:f8b0:4005:805::200e]/*
+//
+// Examples of invalid patterns:
+// - http://* -- path not specified
+// - http://*foo/bar -- * not allowed as substring of host component
+// - http://foo.*.bar/baz -- * must be first component
+// - http:/bar -- scheme separator not found
+// - foo://* -- invalid scheme
+// - chrome:// -- we don't support chrome internal URLs
+class URLPattern {
+ public:
+  // A collection of scheme bitmasks for use with valid_schemes.
+  enum SchemeMasks {
+    SCHEME_NONE = 0,
+    SCHEME_HTTP = 1 << 0,
+    SCHEME_HTTPS = 1 << 1,
+    SCHEME_FILE = 1 << 2,
+    SCHEME_FTP = 1 << 3,
+    SCHEME_CHROMEUI = 1 << 4,
+    SCHEME_EXTENSION = 1 << 5,
+    SCHEME_FILESYSTEM = 1 << 6,
+    SCHEME_WS = 1 << 7,
+    SCHEME_WSS = 1 << 8,
+    SCHEME_DATA = 1 << 9,
+
+    // IMPORTANT!
+    // SCHEME_ALL will match every scheme, including chrome://, chrome-
+    // extension://, about:, etc. Because this has lots of security
+    // implications, third-party extensions should usually not be able to get
+    // access to URL patterns initialized this way. If there is a reason
+    // for violating this general rule, document why this it safe.
+    SCHEME_ALL = -1,
+  };
+
+  // Error codes returned from Parse().
+  enum class ParseResult {
+    kSuccess = 0,
+    kMissingSchemeSeparator,
+    kInvalidScheme,
+    kWrongSchemeSeparator,
+    kEmptyHost,
+    kInvalidHostWildcard,
+    kEmptyPath,
+    kInvalidPort,
+    kInvalidHost,
+    kNumParseResults,
+  };
+
+  // The <all_urls> string pattern.
+  static const char kAllUrlsPattern[];
+
+  // Returns true if the given |scheme| is considered valid for extensions.
+  static bool IsValidSchemeForExtensions(base::StringPiece scheme);
+
+  // Returns the mask for all schemes considered valid for extensions.
+  static int GetValidSchemeMaskForExtensions();
+
+  explicit URLPattern(int valid_schemes);
+
+  // Convenience to construct a URLPattern from a string. If the string is not
+  // known ahead of time, use Parse() instead, which returns success or failure.
+  URLPattern(int valid_schemes, base::StringPiece pattern);
+
+  URLPattern();
+  URLPattern(const URLPattern& other);
+  URLPattern(URLPattern&& other);
+  ~URLPattern();
+
+  URLPattern& operator=(const URLPattern& other);
+  URLPattern& operator=(URLPattern&& other);
+
+  bool operator<(const URLPattern& other) const;
+  bool operator>(const URLPattern& other) const;
+  bool operator==(const URLPattern& other) const;
+
+  // Initializes this instance by parsing the provided string. Returns
+  // URLPattern::ParseResult::kSuccess on success, or an error code otherwise.
+  // On failure, this instance will have some intermediate values and is in an
+  // invalid state.
+  ParseResult Parse(base::StringPiece pattern_str);
+
+  // Gets the bitmask of valid schemes.
+  int valid_schemes() const { return valid_schemes_; }
+  void SetValidSchemes(int valid_schemes);
+
+  // Gets the host the pattern matches. This can be an empty string if the
+  // pattern matches all hosts (the input was <scheme>://*/<whatever>).
+  const std::string& host() const { return host_; }
+  void SetHost(base::StringPiece host);
+
+  // Gets whether to match subdomains of host().
+  bool match_subdomains() const { return match_subdomains_; }
+  void SetMatchSubdomains(bool val);
+
+  // Gets the path the pattern matches with the leading slash. This can have
+  // embedded asterisks which are interpreted using glob rules.
+  const std::string& path() const { return path_; }
+  void SetPath(base::StringPiece path);
+
+  // Returns true if this pattern matches all (valid) urls.
+  bool match_all_urls() const { return match_all_urls_; }
+  void SetMatchAllURLs(bool val);
+
+  // Sets the scheme for pattern matches. This can be a single '*' if the
+  // pattern matches all valid schemes (as defined by the valid_schemes_
+  // property). Returns false on failure (if the scheme is not valid).
+  bool SetScheme(base::StringPiece scheme);
+  // Note: You should use MatchesScheme() instead of this getter unless you
+  // absolutely need the exact scheme. This is exposed for testing.
+  const std::string& scheme() const { return scheme_; }
+
+  // Returns true if the specified scheme can be used in this URL pattern, and
+  // false otherwise. Uses valid_schemes_ to determine validity.
+  bool IsValidScheme(base::StringPiece scheme) const;
+
+  // Returns true if this instance matches the specified URL. Always returns
+  // false for invalid URLs.
+  bool MatchesURL(const GURL& test) const;
+
+  // Returns true if this instance matches the specified security origin.
+  bool MatchesSecurityOrigin(const GURL& test) const;
+
+  // Returns true if |test| matches our scheme.
+  // Note that if test is "filesystem", this may fail whereas MatchesURL
+  // may succeed.  MatchesURL is smart enough to look at the inner_url instead
+  // of the outer "filesystem:" part.
+  bool MatchesScheme(base::StringPiece test) const;
+
+  // Returns true if |test| matches our host.
+  bool MatchesHost(base::StringPiece test) const;
+  bool MatchesHost(const GURL& test) const;
+
+  // Returns true if |test| matches our path.
+  bool MatchesPath(base::StringPiece test) const;
+
+  // Returns true if the pattern matches all patterns in an (e)TLD. This
+  // includes patterns like *://*.com/*, *://*.co.uk/*, etc. A pattern that
+  // matches all domains (e.g., *://*/*) will return true.
+  // |private_filter| specifies whether private registries (like appspot.com)
+  // should be considered; if included, patterns like *://*.appspot.com/* will
+  // return true. By default, we exclude private registries (so *.appspot.com
+  // returns false).
+  // Note: This is an expensive method, and should be used sparingly!
+  // You should probably use URLPatternSet::ShouldWarnAllHosts(), which is
+  // cached.
+  bool MatchesEffectiveTld(
+      net::registry_controlled_domains::PrivateRegistryFilter private_filter =
+          net::registry_controlled_domains::EXCLUDE_PRIVATE_REGISTRIES,
+      net::registry_controlled_domains::UnknownRegistryFilter unknown_filter =
+          net::registry_controlled_domains::EXCLUDE_UNKNOWN_REGISTRIES) const;
+
+  // Returns true if the pattern only matches a single origin. The pattern may
+  // include a path.
+  bool MatchesSingleOrigin() const;
+
+  // Sets the port. Returns false if the port is invalid.
+  bool SetPort(base::StringPiece port);
+  const std::string& port() const { return port_; }
+
+  // Returns a string representing this instance.
+  const std::string& GetAsString() const;
+
+  // Determines whether there is a URL that would match this instance and
+  // another instance. This method is symmetrical: Calling
+  // other.OverlapsWith(this) would result in the same answer.
+  bool OverlapsWith(const URLPattern& other) const;
+
+  // Returns true if this pattern matches all possible URLs that |other| can
+  // match. For example, http://*.google.com encompasses http://www.google.com.
+  bool Contains(const URLPattern& other) const;
+
+  // Creates a new URLPattern that represents the intersection of this
+  // URLPattern with the |other|, or base::nullopt if no intersection exists.
+  // For instance, given the patterns http://*.google.com/* and
+  // *://maps.google.com/*, the intersection is http://maps.google.com/*.
+  // NOTES:
+  // - Though scheme intersections are supported, the serialization of
+  //   URLPatternSet does not record them. Be sure that this is safe for your
+  //   use cases.
+  // - Path intersection is done on a best-effort basis. If one path clearly
+  //   contains another, it will be handled correctly, but this method does not
+  //   deal with cases like /*a* and /*b* (where technically the intersection
+  //   is /*a*b*|/*b*a*); the intersection returned for that case will be empty.
+  base::Optional<URLPattern> CreateIntersection(const URLPattern& other) const;
+
+  // Converts this URLPattern into an equivalent set of URLPatterns that don't
+  // use a wildcard in the scheme component. If this URLPattern doesn't use a
+  // wildcard scheme, then the returned set will contain one element that is
+  // equivalent to this instance.
+  std::vector<URLPattern> ConvertToExplicitSchemes() const;
+
+  static bool EffectiveHostCompare(const URLPattern& a, const URLPattern& b) {
+    if (a.match_all_urls_ && b.match_all_urls_)
+      return false;
+    return a.host_.compare(b.host_) < 0;
+  }
+
+  // Used for origin comparisons in a std::set.
+  class EffectiveHostCompareFunctor {
+   public:
+    bool operator()(const URLPattern& a, const URLPattern& b) const {
+      return EffectiveHostCompare(a, b);
+    }
+  };
+
+  // Get an error string for a ParseResult.
+  static const char* GetParseResultString(URLPattern::ParseResult parse_result);
+
+ private:
+  // Returns true if any of the |schemes| items matches our scheme.
+  bool MatchesAnyScheme(const std::vector<std::string>& schemes) const;
+
+  // Returns true if all of the |schemes| items matches our scheme.
+  bool MatchesAllSchemes(const std::vector<std::string>& schemes) const;
+
+  bool MatchesSecurityOriginHelper(const GURL& test) const;
+
+  // Returns true if our port matches the |port| pattern (it may be "*").
+  bool MatchesPortPattern(base::StringPiece port) const;
+
+  // If the URLPattern contains a wildcard scheme, returns a list of
+  // equivalent literal schemes, otherwise returns the current scheme.
+  std::vector<std::string> GetExplicitSchemes() const;
+
+  // A bitmask containing the schemes which are considered valid for this
+  // pattern. Parse() uses this to decide whether a pattern contains a valid
+  // scheme.
+  int valid_schemes_;
+
+  // True if this is a special-case "<all_urls>" pattern.
+  bool match_all_urls_;
+
+  // The scheme for the pattern.
+  std::string scheme_;
+
+  // The host without any leading "*" components.
+  std::string host_;
+
+  // Whether we should match subdomains of the host. This is true if the first
+  // component of the pattern's host was "*".
+  bool match_subdomains_;
+
+  // The port.
+  std::string port_;
+
+  // The path to match. This is everything after the host of the URL, or
+  // everything after the scheme in the case of file:// URLs.
+  std::string path_;
+
+  // The path with "?" and "\" characters escaped for use with the
+  // MatchPattern() function.
+  std::string path_escaped_;
+
+  // A string representing this URLPattern.
+  mutable std::string spec_;
+};
+
+std::ostream& operator<<(std::ostream& out, const URLPattern& url_pattern);
+
+typedef std::vector<URLPattern> URLPatternList;
+
+#endif  // EXTENSIONS_COMMON_URL_PATTERN_H_
diff --git a/components/user_scripts/content/common/url_pattern_set.cc b/components/user_scripts/content/common/url_pattern_set.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/url_pattern_set.cc
@@ -0,0 +1,327 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "url_pattern_set.h"
+
+#include <iterator>
+#include <ostream>
+
+#include "base/logging.h"
+#include "base/stl_util.h"
+#include "base/values.h"
+#include "error_utils.h"
+#include "url_pattern.h"
+#include "url/gurl.h"
+#include "url/origin.h"
+#include "url/url_constants.h"
+
+namespace user_scripts {
+
+namespace {
+
+const char kInvalidURLPatternError[] = "Invalid url pattern '*'";
+
+}  // namespace
+
+// static
+URLPatternSet URLPatternSet::CreateDifference(const URLPatternSet& set1,
+                                              const URLPatternSet& set2) {
+  return URLPatternSet(base::STLSetDifference<std::set<URLPattern>>(
+      set1.patterns_, set2.patterns_));
+}
+
+// static
+URLPatternSet URLPatternSet::CreateIntersection(
+    const URLPatternSet& set1,
+    const URLPatternSet& set2,
+    IntersectionBehavior intersection_behavior) {
+  // Note: leverage return value optimization; always return the same object.
+  URLPatternSet result;
+
+  if (intersection_behavior == IntersectionBehavior::kStringComparison) {
+    // String comparison just relies on STL set behavior, which looks at the
+    // string representation.
+    result = URLPatternSet(base::STLSetIntersection<std::set<URLPattern>>(
+        set1.patterns_, set2.patterns_));
+    return result;
+  }
+
+  // Look for a semantic intersection.
+
+  // Step 1: Iterate over each set. Find any patterns that are completely
+  // contained by the other (thus being necessarily present in any intersection)
+  // and add them, collecting the others in a set of unique items.
+  // Note: Use a collection of pointers for the uniques to avoid excessive
+  // copies. Since these are owned by the URLPatternSet passed in, which is
+  // const, this should be safe.
+  std::vector<const URLPattern*> unique_set1;
+  for (const URLPattern& pattern : set1) {
+    if (set2.ContainsPattern(pattern))
+      result.patterns_.insert(pattern);
+    else
+      unique_set1.push_back(&pattern);
+  }
+  std::vector<const URLPattern*> unique_set2;
+  for (const URLPattern& pattern : set2) {
+    if (set1.ContainsPattern(pattern))
+      result.patterns_.insert(pattern);
+    else
+      unique_set2.push_back(&pattern);
+  }
+
+  // If we're just looking for patterns contained by both, we're done.
+  if (intersection_behavior == IntersectionBehavior::kPatternsContainedByBoth)
+    return result;
+
+  DCHECK_EQ(IntersectionBehavior::kDetailed, intersection_behavior);
+
+  // Step 2: Iterate over all the unique patterns and find the intersections
+  // they have with the other patterns.
+  for (const auto* pattern : unique_set1) {
+    for (const auto* pattern2 : unique_set2) {
+      base::Optional<URLPattern> intersection =
+          pattern->CreateIntersection(*pattern2);
+      if (intersection)
+        result.patterns_.insert(std::move(*intersection));
+    }
+  }
+
+  return result;
+}
+
+// static
+URLPatternSet URLPatternSet::CreateUnion(const URLPatternSet& set1,
+                                         const URLPatternSet& set2) {
+  return URLPatternSet(
+      base::STLSetUnion<std::set<URLPattern>>(set1.patterns_, set2.patterns_));
+}
+
+// static
+URLPatternSet URLPatternSet::CreateUnion(
+    const std::vector<URLPatternSet>& sets) {
+  URLPatternSet result;
+  if (sets.empty())
+    return result;
+
+  // N-way union algorithm is basic O(nlog(n)) merge algorithm.
+  //
+  // Do the first merge step into a working set so that we don't mutate any of
+  // the input.
+  // TODO(devlin): Looks like this creates a bunch of copies; we can probably
+  // clean that up.
+  std::vector<URLPatternSet> working;
+  for (size_t i = 0; i < sets.size(); i += 2) {
+    if (i + 1 < sets.size())
+      working.push_back(CreateUnion(sets[i], sets[i + 1]));
+    else
+      working.push_back(sets[i].Clone());
+  }
+
+  for (size_t skip = 1; skip < working.size(); skip *= 2) {
+    for (size_t i = 0; i < (working.size() - skip); i += skip) {
+      URLPatternSet u = CreateUnion(working[i], working[i + skip]);
+      working[i].patterns_.swap(u.patterns_);
+    }
+  }
+
+  result.patterns_.swap(working[0].patterns_);
+  return result;
+}
+
+URLPatternSet::URLPatternSet() = default;
+
+URLPatternSet::URLPatternSet(URLPatternSet&& rhs) = default;
+
+URLPatternSet::URLPatternSet(const std::set<URLPattern>& patterns)
+    : patterns_(patterns) {}
+
+URLPatternSet::~URLPatternSet() = default;
+
+URLPatternSet& URLPatternSet::operator=(URLPatternSet&& rhs) = default;
+
+bool URLPatternSet::operator==(const URLPatternSet& other) const {
+  return patterns_ == other.patterns_;
+}
+
+std::ostream& operator<<(std::ostream& out,
+                         const URLPatternSet& url_pattern_set) {
+  out << "{ ";
+
+  auto iter = url_pattern_set.patterns().cbegin();
+  if (!url_pattern_set.patterns().empty()) {
+    out << *iter;
+    ++iter;
+  }
+
+  for (;iter != url_pattern_set.patterns().end(); ++iter)
+    out << ", " << *iter;
+
+  if (!url_pattern_set.patterns().empty())
+    out << " ";
+
+  out << "}";
+  return out;
+}
+
+URLPatternSet URLPatternSet::Clone() const {
+  return URLPatternSet(patterns_);
+}
+
+bool URLPatternSet::is_empty() const {
+  return patterns_.empty();
+}
+
+size_t URLPatternSet::size() const {
+  return patterns_.size();
+}
+
+bool URLPatternSet::AddPattern(const URLPattern& pattern) {
+  return patterns_.insert(pattern).second;
+}
+
+void URLPatternSet::AddPatterns(const URLPatternSet& set) {
+  patterns_.insert(set.patterns().begin(),
+                   set.patterns().end());
+}
+
+void URLPatternSet::ClearPatterns() {
+  patterns_.clear();
+}
+
+bool URLPatternSet::AddOrigin(int valid_schemes, const GURL& origin) {
+  if (origin.is_empty())
+    return false;
+  const url::Origin real_origin = url::Origin::Create(origin);
+  DCHECK(real_origin.IsSameOriginWith(url::Origin::Create(origin.GetOrigin())));
+  URLPattern origin_pattern(valid_schemes);
+  // Origin adding could fail if |origin| does not match |valid_schemes|.
+  if (origin_pattern.Parse(origin.spec()) !=
+      URLPattern::ParseResult::kSuccess) {
+    return false;
+  }
+  origin_pattern.SetPath("/*");
+  return AddPattern(origin_pattern);
+}
+
+bool URLPatternSet::Contains(const URLPatternSet& other) const {
+  for (auto it = other.begin(); it != other.end(); ++it) {
+    if (!ContainsPattern(*it))
+      return false;
+  }
+
+  return true;
+}
+
+bool URLPatternSet::ContainsPattern(const URLPattern& pattern) const {
+  for (auto it = begin(); it != end(); ++it) {
+    if (it->Contains(pattern))
+      return true;
+  }
+  return false;
+}
+
+bool URLPatternSet::MatchesURL(const GURL& url) const {
+  LOG(INFO) << "---URLPatternSet::MatchesURL  " << url.spec();
+
+  for (auto pattern = patterns_.cbegin(); pattern != patterns_.cend();
+       ++pattern) {
+    if (pattern->MatchesURL(url)) {
+      LOG(INFO) << "---URLPatternSet::MatchesURL    true";
+      return true;
+    }
+  }
+
+  LOG(INFO) << "---URLPatternSet::MatchesURL    false";
+  return false;
+}
+
+bool URLPatternSet::MatchesAllURLs() const {
+  for (auto host = begin(); host != end(); ++host) {
+    if (host->match_all_urls() ||
+        (host->match_subdomains() && host->host().empty()))
+      return true;
+  }
+  return false;
+}
+
+bool URLPatternSet::MatchesSecurityOrigin(const GURL& origin) const {
+  for (auto pattern = patterns_.begin(); pattern != patterns_.end();
+       ++pattern) {
+    if (pattern->MatchesSecurityOrigin(origin))
+      return true;
+  }
+
+  return false;
+}
+
+bool URLPatternSet::OverlapsWith(const URLPatternSet& other) const {
+  // Two extension extents overlap if there is any one URL that would match at
+  // least one pattern in each of the extents.
+  for (auto i = patterns_.cbegin(); i != patterns_.cend(); ++i) {
+    for (auto j = other.patterns().cbegin(); j != other.patterns().cend();
+         ++j) {
+      if (i->OverlapsWith(*j))
+        return true;
+    }
+  }
+
+  return false;
+}
+
+std::unique_ptr<base::ListValue> URLPatternSet::ToValue() const {
+  std::unique_ptr<base::ListValue> value(new base::ListValue);
+  for (auto i = patterns_.cbegin(); i != patterns_.cend(); ++i)
+    value->AppendIfNotPresent(std::make_unique<base::Value>(i->GetAsString()));
+  return value;
+}
+
+bool URLPatternSet::Populate(const std::vector<std::string>& patterns,
+                             int valid_schemes,
+                             bool allow_file_access,
+                             std::string* error) {
+  ClearPatterns();
+  for (size_t i = 0; i < patterns.size(); ++i) {
+    URLPattern pattern(valid_schemes);
+    if (pattern.Parse(patterns[i]) != URLPattern::ParseResult::kSuccess) {
+      if (error) {
+        *error = ErrorUtils::FormatErrorMessage(kInvalidURLPatternError,
+                                                patterns[i]);
+      } else {
+        LOG(ERROR) << "Invalid url pattern: " << patterns[i];
+      }
+      return false;
+    }
+    if (!allow_file_access && pattern.MatchesScheme(url::kFileScheme)) {
+      pattern.SetValidSchemes(
+          pattern.valid_schemes() & ~URLPattern::SCHEME_FILE);
+    }
+    AddPattern(pattern);
+  }
+  return true;
+}
+
+std::unique_ptr<std::vector<std::string>> URLPatternSet::ToStringVector()
+    const {
+  std::unique_ptr<std::vector<std::string>> value(new std::vector<std::string>);
+  for (auto i = patterns_.cbegin(); i != patterns_.cend(); ++i) {
+    value->push_back(i->GetAsString());
+  }
+  return value;
+}
+
+bool URLPatternSet::Populate(const base::ListValue& value,
+                             int valid_schemes,
+                             bool allow_file_access,
+                             std::string* error) {
+  std::vector<std::string> patterns;
+  for (size_t i = 0; i < value.GetSize(); ++i) {
+    std::string item;
+    if (!value.GetString(i, &item))
+      return false;
+    patterns.push_back(item);
+  }
+  return Populate(patterns, valid_schemes, allow_file_access, error);
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/content/common/url_pattern_set.h b/components/user_scripts/content/common/url_pattern_set.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/url_pattern_set.h
@@ -0,0 +1,161 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_COMMON_URL_PATTERN_SET_H_
+#define EXTENSIONS_COMMON_URL_PATTERN_SET_H_
+
+#include <stddef.h>
+
+#include <iosfwd>
+#include <memory>
+#include <set>
+
+#include "base/macros.h"
+#include "url_pattern.h"
+
+class GURL;
+
+namespace base {
+class ListValue;
+class Value;
+}
+
+namespace user_scripts {
+
+// Represents the set of URLs an extension uses for web content.
+class URLPatternSet {
+ public:
+  typedef std::set<URLPattern>::const_iterator const_iterator;
+  typedef std::set<URLPattern>::iterator iterator;
+
+  // Returns |set1| - |set2|.
+  static URLPatternSet CreateDifference(const URLPatternSet& set1,
+                                        const URLPatternSet& set2);
+
+  enum class IntersectionBehavior {
+    // For the following descriptions, consider the two URLPatternSets:
+    // Set 1: {"https://example.com/*", "https://*.google.com/*", "http://*/*"}
+    // Set 2: {"https://example.com/*", "https://google.com/maps",
+    //         "*://chromium.org/*"}
+
+    // Only includes patterns that are exactly in both sets. The intersection of
+    // the two sets above is {"https://example.com/*"}, since that is the only
+    // pattern that appears exactly in each.
+    kStringComparison,
+
+    // Includes patterns that are effectively contained by both sets. The
+    // intersection of the two sets above is
+    // {
+    //   "https://example.com/*" (contained exactly by each set)
+    //   "https://google.com/maps" (contained exactly by set 2 and a strict
+    //                              subset of https://*.google.com/* in set 1)
+    // }
+    kPatternsContainedByBoth,
+
+    // Includes patterns that are contained by both sets and creates new
+    // patterns to represent the intersection of any others. The intersection of
+    // the two sets above is
+    // {
+    //   "https://example.com/*" (contained exactly by each set)
+    //   "https://google.com/maps" (contained exactly by set 2 and a strict
+    //                              subset of https://*.google.com/* in set 1)
+    //   "http://chromium.org/*" (the overlap between "http://*/*" in set 1 and
+    //                            *://chromium.org/*" in set 2).
+    // }
+    // Note that this is the most computationally expensive - potentially
+    // O(n^2) - since it can require comparing each pattern in one set to every
+    // pattern in the other set.
+    kDetailed,
+  };
+
+  // Returns the intersection of |set1| and |set2| according to
+  // |intersection_behavior|.
+  static URLPatternSet CreateIntersection(
+      const URLPatternSet& set1,
+      const URLPatternSet& set2,
+      IntersectionBehavior intersection_behavior);
+
+  // Returns the union of |set1| and |set2|.
+  static URLPatternSet CreateUnion(const URLPatternSet& set1,
+                                   const URLPatternSet& set2);
+
+  // Returns the union of all sets in |sets|.
+  static URLPatternSet CreateUnion(const std::vector<URLPatternSet>& sets);
+
+  URLPatternSet();
+  URLPatternSet(URLPatternSet&& rhs);
+  explicit URLPatternSet(const std::set<URLPattern>& patterns);
+  ~URLPatternSet();
+
+  URLPatternSet& operator=(URLPatternSet&& rhs);
+  bool operator==(const URLPatternSet& rhs) const;
+
+  bool is_empty() const;
+  size_t size() const;
+  const std::set<URLPattern>& patterns() const { return patterns_; }
+  const_iterator begin() const { return patterns_.begin(); }
+  const_iterator end() const { return patterns_.end(); }
+  iterator erase(iterator iter) { return patterns_.erase(iter); }
+
+  // Returns a copy of this URLPatternSet; not instrumented as a copy
+  // constructor to avoid accidental/unnecessary copies.
+  URLPatternSet Clone() const;
+
+  // Adds a pattern to the set. Returns true if a new pattern was inserted,
+  // false if the pattern was already in the set.
+  bool AddPattern(const URLPattern& pattern);
+
+  // Adds all patterns from |set| into this.
+  void AddPatterns(const URLPatternSet& set);
+
+  void ClearPatterns();
+
+  // Adds a pattern based on |origin| to the set.
+  bool AddOrigin(int valid_schemes, const GURL& origin);
+
+  // Returns true if every URL that matches |set| is matched by this. In other
+  // words, if every pattern in |set| is encompassed by a pattern in this.
+  bool Contains(const URLPatternSet& set) const;
+
+  // Returns true if any pattern in this set encompasses |pattern|.
+  bool ContainsPattern(const URLPattern& pattern) const;
+
+  // Test if the extent contains a URL.
+  bool MatchesURL(const GURL& url) const;
+
+  // Test if the extent matches all URLs (for example, <all_urls>).
+  bool MatchesAllURLs() const;
+
+  bool MatchesSecurityOrigin(const GURL& origin) const;
+
+  // Returns true if there is a single URL that would be in two extents.
+  bool OverlapsWith(const URLPatternSet& other) const;
+
+  // Converts to and from Value for serialization to preferences.
+  std::unique_ptr<base::ListValue> ToValue() const;
+  bool Populate(const base::ListValue& value,
+                int valid_schemes,
+                bool allow_file_access,
+                std::string* error);
+
+  // Converts to and from a vector of strings.
+  std::unique_ptr<std::vector<std::string>> ToStringVector() const;
+  bool Populate(const std::vector<std::string>& patterns,
+                int valid_schemes,
+                bool allow_file_access,
+                std::string* error);
+
+ private:
+  // The list of URL patterns that comprise the extent.
+  std::set<URLPattern> patterns_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLPatternSet);
+};
+
+std::ostream& operator<<(std::ostream& out,
+                         const URLPatternSet& url_pattern_set);
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_COMMON_URL_PATTERN_SET_H_
diff --git a/components/user_scripts/content/common/user_script.cc b/components/user_scripts/content/common/user_script.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/user_script.cc
@@ -0,0 +1,337 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "user_script.h"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <memory>
+#include <utility>
+
+#include "base/atomic_sequence_num.h"
+#include "base/command_line.h"
+#include "base/pickle.h"
+#include "base/strings/pattern.h"
+#include "base/strings/string_util.h"
+//#include "switches.h"
+
+namespace {
+
+// This cannot be a plain int or int64_t because we need to generate unique IDs
+// from multiple threads.
+base::AtomicSequenceNumber g_user_script_id_generator;
+
+bool UrlMatchesGlobs(const std::vector<std::string>* globs,
+                     const GURL& url) {
+  for (auto glob = globs->cbegin(); glob != globs->cend(); ++glob) {
+    if (base::MatchPattern(url.spec(), *glob))
+      return true;
+  }
+
+  return false;
+}
+
+}  // namespace
+
+namespace user_scripts {
+
+// The bitmask for valid user script injectable schemes used by URLPattern.
+enum {
+  kValidUserScriptSchemes = URLPattern::SCHEME_CHROMEUI |
+                            URLPattern::SCHEME_HTTP |
+                            URLPattern::SCHEME_HTTPS |
+                            URLPattern::SCHEME_FILE |
+                            URLPattern::SCHEME_FTP
+};
+
+// static
+const char UserScript::kFileExtension[] = ".user.js";
+
+// static
+int UserScript::GenerateUserScriptID() {
+  return g_user_script_id_generator.GetNext();
+}
+
+bool UserScript::IsURLUserScript(const GURL& url,
+                                 const std::string& mime_type) {
+  return base::EndsWith(url.ExtractFileName(), kFileExtension,
+                        base::CompareCase::INSENSITIVE_ASCII) &&
+         mime_type != "text/html";
+}
+
+// static
+int UserScript::ValidUserScriptSchemes(bool canExecuteScriptEverywhere) {
+  if (canExecuteScriptEverywhere)
+    return URLPattern::SCHEME_ALL;
+  int valid_schemes = kValidUserScriptSchemes;
+  // if (!base::CommandLine::ForCurrentProcess()->HasSwitch(
+  //         switches::kExtensionsOnChromeURLs)) {
+  //   valid_schemes &= ~URLPattern::SCHEME_CHROMEUI;
+  // }
+  return valid_schemes;
+}
+
+UserScript::File::File(const base::FilePath& extension_root,
+                       const base::FilePath& relative_path,
+                       const GURL& url)
+    : extension_root_(extension_root),
+      relative_path_(relative_path),
+      url_(url) {
+}
+
+UserScript::File::File() {}
+
+// File content is not copied.
+UserScript::File::File(const File& other)
+    : extension_root_(other.extension_root_),
+      relative_path_(other.relative_path_),
+      url_(other.url_) {}
+
+UserScript::File::~File() {}
+
+UserScript::UserScript() = default;
+UserScript::~UserScript() = default;
+
+// static.
+std::unique_ptr<UserScript> UserScript::CopyMetadataFrom(
+    const UserScript& other) {
+  std::unique_ptr<UserScript> script(new UserScript());
+  script->run_location_ = other.run_location_;
+  script->name_space_ = other.name_space_;
+  script->name_ = other.name_;
+  script->description_ = other.description_;
+  script->version_ = other.version_;
+  script->globs_ = other.globs_;
+  script->exclude_globs_ = other.exclude_globs_;
+  script->url_set_ = other.url_set_.Clone();
+  script->exclude_url_set_ = other.exclude_url_set_.Clone();
+
+  // Note: File content is not copied.
+  for (const std::unique_ptr<File>& file : other.js_scripts()) {
+    std::unique_ptr<File> file_copy(new File(*file));
+    script->js_scripts_.push_back(std::move(file_copy));
+  }
+  for (const std::unique_ptr<File>& file : other.css_scripts()) {
+    std::unique_ptr<File> file_copy(new File(*file));
+    script->css_scripts_.push_back(std::move(file_copy));
+  }
+  script->host_id_ = other.host_id_;
+  script->consumer_instance_type_ = other.consumer_instance_type_;
+  script->user_script_id_ = other.user_script_id_;
+  script->emulate_greasemonkey_ = other.emulate_greasemonkey_;
+  script->match_all_frames_ = other.match_all_frames_;
+  script->match_origin_as_fallback_ = other.match_origin_as_fallback_;
+  script->incognito_enabled_ = other.incognito_enabled_;
+
+  return script;
+}
+
+void UserScript::add_url_pattern(const URLPattern& pattern) {
+  url_set_.AddPattern(pattern);
+}
+
+void UserScript::add_exclude_url_pattern(const URLPattern& pattern) {
+  exclude_url_set_.AddPattern(pattern);
+}
+
+bool UserScript::MatchesURL(const GURL& url) const {
+  if (!url_set_.is_empty()) {
+    if (!url_set_.MatchesURL(url))
+      return false;
+  }
+
+  if (!exclude_url_set_.is_empty()) {
+    if (exclude_url_set_.MatchesURL(url))
+      return false;
+  }
+
+  if (!globs_.empty()) {
+    if (!UrlMatchesGlobs(&globs_, url))
+      return false;
+  }
+
+  if (!exclude_globs_.empty()) {
+    if (UrlMatchesGlobs(&exclude_globs_, url))
+      return false;
+  }
+
+  return true;
+}
+
+bool UserScript::MatchesDocument(const GURL& effective_document_url,
+                                 bool is_subframe) const {
+  if (is_subframe && !match_all_frames())
+    return false;
+
+  return MatchesURL(effective_document_url);
+}
+
+void UserScript::File::Pickle(base::Pickle* pickle) const {
+  pickle->WriteString(url_.spec());
+  // Do not write path. It's not needed in the renderer.
+  // Do not write content. It will be serialized by other means.
+}
+
+void UserScript::File::Unpickle(const base::Pickle& pickle,
+                                base::PickleIterator* iter) {
+  // Read the url from the pickle.
+  std::string url;
+  CHECK(iter->ReadString(&url));
+  set_url(GURL(url));
+}
+
+void UserScript::Pickle(base::Pickle* pickle) const {
+  // Write the simple types to the pickle.
+  pickle->WriteInt(run_location());
+  pickle->WriteInt(user_script_id_);
+  pickle->WriteBool(emulate_greasemonkey());
+  pickle->WriteBool(match_all_frames());
+  pickle->WriteInt(static_cast<int>(match_origin_as_fallback()));
+  pickle->WriteBool(is_incognito_enabled());
+
+  PickleHostID(pickle, host_id_);
+  pickle->WriteInt(consumer_instance_type());
+  PickleGlobs(pickle, globs_);
+  PickleGlobs(pickle, exclude_globs_);
+  PickleURLPatternSet(pickle, url_set_);
+  PickleURLPatternSet(pickle, exclude_url_set_);
+  PickleScripts(pickle, js_scripts_);
+  PickleScripts(pickle, css_scripts_);
+}
+
+void UserScript::PickleGlobs(base::Pickle* pickle,
+                             const std::vector<std::string>& globs) const {
+  pickle->WriteUInt32(globs.size());
+  for (auto glob = globs.cbegin(); glob != globs.cend(); ++glob) {
+    pickle->WriteString(*glob);
+  }
+}
+
+void UserScript::PickleHostID(base::Pickle* pickle,
+                              const HostID& host_id) const {
+  pickle->WriteInt(host_id.type());
+  pickle->WriteString(host_id.id());
+}
+
+void UserScript::PickleURLPatternSet(base::Pickle* pickle,
+                                     const URLPatternSet& pattern_list) const {
+  pickle->WriteUInt32(pattern_list.patterns().size());
+  for (auto pattern = pattern_list.begin(); pattern != pattern_list.end();
+       ++pattern) {
+    pickle->WriteInt(pattern->valid_schemes());
+    pickle->WriteString(pattern->GetAsString());
+  }
+}
+
+void UserScript::PickleScripts(base::Pickle* pickle,
+                               const FileList& scripts) const {
+  pickle->WriteUInt32(scripts.size());
+  for (const std::unique_ptr<File>& file : scripts)
+    file->Pickle(pickle);
+}
+
+void UserScript::Unpickle(const base::Pickle& pickle,
+                          base::PickleIterator* iter) {
+  // Read the run location.
+  int run_location = 0;
+  CHECK(iter->ReadInt(&run_location));
+  CHECK(run_location >= 0 && run_location < RUN_LOCATION_LAST);
+  run_location_ = static_cast<RunLocation>(run_location);
+
+  CHECK(iter->ReadInt(&user_script_id_));
+  CHECK(iter->ReadBool(&emulate_greasemonkey_));
+  CHECK(iter->ReadBool(&match_all_frames_));
+  int match_origin_as_fallback_int = 0;
+  CHECK(iter->ReadInt(&match_origin_as_fallback_int));
+  match_origin_as_fallback_ =
+      static_cast<MatchOriginAsFallbackBehavior>(match_origin_as_fallback_int);
+  CHECK(iter->ReadBool(&incognito_enabled_));
+
+  UnpickleHostID(pickle, iter, &host_id_);
+
+  int consumer_instance_type = 0;
+  CHECK(iter->ReadInt(&consumer_instance_type));
+  consumer_instance_type_ =
+      static_cast<ConsumerInstanceType>(consumer_instance_type);
+
+  UnpickleGlobs(pickle, iter, &globs_);
+  UnpickleGlobs(pickle, iter, &exclude_globs_);
+  UnpickleURLPatternSet(pickle, iter, &url_set_);
+  UnpickleURLPatternSet(pickle, iter, &exclude_url_set_);
+  UnpickleScripts(pickle, iter, &js_scripts_);
+  UnpickleScripts(pickle, iter, &css_scripts_);
+}
+
+void UserScript::UnpickleGlobs(const base::Pickle& pickle,
+                               base::PickleIterator* iter,
+                               std::vector<std::string>* globs) {
+  uint32_t num_globs = 0;
+  CHECK(iter->ReadUInt32(&num_globs));
+  globs->clear();
+  for (uint32_t i = 0; i < num_globs; ++i) {
+    std::string glob;
+    CHECK(iter->ReadString(&glob));
+    globs->push_back(glob);
+  }
+}
+
+void UserScript::UnpickleHostID(const base::Pickle& pickle,
+                                base::PickleIterator* iter,
+                                HostID* host_id) {
+  int type = 0;
+  std::string id;
+  CHECK(iter->ReadInt(&type));
+  CHECK(iter->ReadString(&id));
+  *host_id = HostID(static_cast<HostID::HostType>(type), id);
+}
+
+void UserScript::UnpickleURLPatternSet(const base::Pickle& pickle,
+                                       base::PickleIterator* iter,
+                                       URLPatternSet* pattern_list) {
+  uint32_t num_patterns = 0;
+  CHECK(iter->ReadUInt32(&num_patterns));
+
+  pattern_list->ClearPatterns();
+  for (uint32_t i = 0; i < num_patterns; ++i) {
+    int valid_schemes;
+    CHECK(iter->ReadInt(&valid_schemes));
+
+    std::string pattern_str;
+    CHECK(iter->ReadString(&pattern_str));
+
+    URLPattern pattern(kValidUserScriptSchemes);
+    URLPattern::ParseResult result = pattern.Parse(pattern_str);
+    CHECK(URLPattern::ParseResult::kSuccess == result)
+        << URLPattern::GetParseResultString(result) << " "
+        << pattern_str.c_str();
+
+    pattern.SetValidSchemes(valid_schemes);
+    pattern_list->AddPattern(pattern);
+  }
+}
+
+void UserScript::UnpickleScripts(const base::Pickle& pickle,
+                                 base::PickleIterator* iter,
+                                 FileList* scripts) {
+  uint32_t num_files = 0;
+  CHECK(iter->ReadUInt32(&num_files));
+  scripts->clear();
+  for (uint32_t i = 0; i < num_files; ++i) {
+    std::unique_ptr<File> file(new File());
+    file->Unpickle(pickle, iter);
+    scripts->push_back(std::move(file));
+  }
+}
+
+UserScriptIDPair::UserScriptIDPair(int id, const HostID& host_id)
+    : id(id), host_id(host_id) {}
+
+UserScriptIDPair::UserScriptIDPair(int id) : id(id), host_id(HostID()) {}
+
+bool operator<(const UserScriptIDPair& a, const UserScriptIDPair& b) {
+  return a.id < b.id;
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/content/common/user_script.h b/components/user_scripts/content/common/user_script.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/user_script.h
@@ -0,0 +1,357 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_COMMON_USER_SCRIPT_H_
+#define EXTENSIONS_COMMON_USER_SCRIPT_H_
+
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/files/file_path.h"
+#include "base/strings/string_piece.h"
+#include "script_constants.h"
+#include "host_id.h"
+#include "url_pattern.h"
+#include "url_pattern_set.h"
+#include "url/gurl.h"
+
+namespace base {
+class Pickle;
+class PickleIterator;
+}
+
+namespace user_scripts {
+
+// Represents a user script, either a standalone one, or one that is part of an
+// extension.
+class UserScript {
+ public:
+  // The file extension for standalone user scripts.
+  static const char kFileExtension[];
+
+  static int GenerateUserScriptID();
+
+  // Check if a URL should be treated as a user script and converted to an
+  // extension.
+  static bool IsURLUserScript(const GURL& url, const std::string& mime_type);
+
+  // Get the valid user script schemes for the current process. If
+  // canExecuteScriptEverywhere is true, this will return ALL_SCHEMES.
+  static int ValidUserScriptSchemes(bool canExecuteScriptEverywhere = false);
+
+  // TODO(rdevlin.cronin) This and RunLocation don't really belong here, since
+  // they are used for more than UserScripts (e.g., tabs.executeScript()).
+  // The type of injected script.
+  enum InjectionType {
+    // A content script specified in the extension's manifest.
+    CONTENT_SCRIPT,
+    // A script injected via, e.g. tabs.executeScript().
+    //PROGRAMMATIC_SCRIPT
+  };
+  // The last type of injected script; used for enum verification in IPC.
+  // Update this if you add more injected script types!
+  static const InjectionType INJECTION_TYPE_LAST = CONTENT_SCRIPT/*PROGRAMMATIC_SCRIPT*/;
+
+  // Locations that user scripts can be run inside the document.
+  // The three run locations must strictly follow each other in both load order
+  // (i.e., start *always* comes before end) and numerically, as we use
+  // arithmetic checking (e.g., curr == last + 1). So, no bitmasks here!!
+  enum RunLocation {
+    UNDEFINED,
+    DOCUMENT_START,  // After the documentElement is created, but before
+                     // anything else happens.
+    DOCUMENT_END,  // After the entire document is parsed. Same as
+                   // DOMContentLoaded.
+    DOCUMENT_IDLE,  // Sometime after DOMContentLoaded, as soon as the document
+                    // is "idle". Currently this uses the simple heuristic of:
+                    // min(DOM_CONTENT_LOADED + TIMEOUT, ONLOAD), but no
+                    // particular injection point is guaranteed.
+    RUN_DEFERRED,  // The user script's injection was deferred for permissions
+                   // reasons, and was executed at a later time.
+    BROWSER_DRIVEN,  // The user script will be injected when triggered by an
+                     // IPC in the browser process.
+    RUN_LOCATION_LAST  // Leave this as the last item.
+  };
+
+  // Holds script file info.
+  class File {
+   public:
+    File(const base::FilePath& extension_root,
+         const base::FilePath& relative_path,
+         const GURL& url);
+    File();
+    File(const File& other);
+    ~File();
+
+    const base::FilePath& extension_root() const { return extension_root_; }
+    const base::FilePath& relative_path() const { return relative_path_; }
+
+    const GURL& url() const { return url_; }
+    void set_url(const GURL& url) { url_ = url; }
+
+    // If external_content_ is set returns it as content otherwise it returns
+    // content_
+    const base::StringPiece GetContent() const {
+      if (external_content_.data())
+        return external_content_;
+      else
+        return content_;
+    }
+    void set_external_content(const base::StringPiece& content) {
+      external_content_ = content;
+    }
+    void set_content(const base::StringPiece& content) {
+      content_.assign(content.begin(), content.end());
+    }
+
+    // Serialization support. The content and FilePath members will not be
+    // serialized!
+    void Pickle(base::Pickle* pickle) const;
+    void Unpickle(const base::Pickle& pickle, base::PickleIterator* iter);
+
+   private:
+    // Where the script file lives on the disk. We keep the path split so that
+    // it can be localized at will.
+    base::FilePath extension_root_;
+    base::FilePath relative_path_;
+
+    // The url to this script file.
+    GURL url_;
+
+    // The script content. It can be set to either loaded_content_ or
+    // externally allocated string.
+    base::StringPiece external_content_;
+
+    // Set when the content is loaded by LoadContent
+    std::string content_;
+  };
+
+  using FileList = std::vector<std::unique_ptr<File>>;
+
+  // Type of a API consumer instance that user scripts will be injected on.
+  enum ConsumerInstanceType { TAB, WEBVIEW };
+
+  // Constructor. Default the run location to document end, which is like
+  // Greasemonkey and probably more useful for typical scripts.
+  UserScript();
+  ~UserScript();
+
+  // Performs a copy of all fields except file contents.
+  static std::unique_ptr<UserScript> CopyMetadataFrom(const UserScript& other);
+
+  const std::string& name_space() const { return name_space_; }
+  void set_name_space(const std::string& name_space) {
+    name_space_ = name_space;
+  }
+
+  const std::string& name() const { return name_; }
+  void set_name(const std::string& name) { name_ = name; }
+
+  const std::string& version() const { return version_; }
+  void set_version(const std::string& version) {
+    version_ = version;
+  }
+
+  const std::string& description() const { return description_; }
+  void set_description(const std::string& description) {
+    description_ = description;
+  }
+
+  // The place in the document to run the script.
+  RunLocation run_location() const { return run_location_; }
+  void set_run_location(RunLocation location) { run_location_ = location; }
+
+  // Whether to emulate greasemonkey when running this script.
+  bool emulate_greasemonkey() const { return emulate_greasemonkey_; }
+  void set_emulate_greasemonkey(bool val) { emulate_greasemonkey_ = val; }
+
+  // Whether to match all frames, or only the top one.
+  bool match_all_frames() const { return match_all_frames_; }
+  void set_match_all_frames(bool val) { match_all_frames_ = val; }
+
+  // Whether to match the origin as a fallback if the URL cannot be used
+  // directly.
+  MatchOriginAsFallbackBehavior match_origin_as_fallback() const {
+    return match_origin_as_fallback_;
+  }
+  void set_match_origin_as_fallback(MatchOriginAsFallbackBehavior val) {
+    match_origin_as_fallback_ = val;
+  }
+
+  // The globs, if any, that determine which pages this script runs against.
+  // These are only used with "standalone" Greasemonkey-like user scripts.
+  const std::vector<std::string>& globs() const { return globs_; }
+  void add_glob(const std::string& glob) { globs_.push_back(glob); }
+  void clear_globs() { globs_.clear(); }
+  const std::vector<std::string>& exclude_globs() const {
+    return exclude_globs_;
+  }
+  void add_exclude_glob(const std::string& glob) {
+    exclude_globs_.push_back(glob);
+  }
+  void clear_exclude_globs() { exclude_globs_.clear(); }
+
+  // The URLPatterns, if any, that determine which pages this script runs
+  // against.
+  const URLPatternSet& url_patterns() const { return url_set_; }
+  void add_url_pattern(const URLPattern& pattern);
+  const URLPatternSet& exclude_url_patterns() const {
+    return exclude_url_set_;
+  }
+  void add_exclude_url_pattern(const URLPattern& pattern);
+
+  // List of js scripts for this user script
+  FileList& js_scripts() { return js_scripts_; }
+  const FileList& js_scripts() const { return js_scripts_; }
+
+  // List of css scripts for this user script
+  FileList& css_scripts() { return css_scripts_; }
+  const FileList& css_scripts() const { return css_scripts_; }
+
+  const std::string& extension_id() const { return host_id_.id(); }
+
+  const HostID& host_id() const { return host_id_; }
+  void set_host_id(const HostID& host_id) { host_id_ = host_id; }
+
+  const ConsumerInstanceType& consumer_instance_type() const {
+    return consumer_instance_type_;
+  }
+  void set_consumer_instance_type(
+      const ConsumerInstanceType& consumer_instance_type) {
+    consumer_instance_type_ = consumer_instance_type;
+  }
+
+  int id() const { return user_script_id_; }
+  void set_id(int id) { user_script_id_ = id; }
+
+  // TODO(lazyboy): Incognito information is extension specific, it doesn't
+  // belong here. We should be able to determine this in the renderer/ where it
+  // is used.
+  bool is_incognito_enabled() const { return incognito_enabled_; }
+  void set_incognito_enabled(bool enabled) { incognito_enabled_ = enabled; }
+
+  // Returns true if the script should be applied to the specified URL, false
+  // otherwise.
+  bool MatchesURL(const GURL& url) const;
+
+  // Returns true if the script should be applied to the given
+  // |effective_document_url|. It is the caller's responsibility to calculate
+  // |effective_document_url| based on match_origin_as_fallback().
+  bool MatchesDocument(const GURL& effective_document_url,
+                       bool is_subframe) const;
+
+  // Serializes the UserScript into a pickle. The content of the scripts and
+  // paths to UserScript::Files will not be serialized!
+  void Pickle(base::Pickle* pickle) const;
+
+  // Deserializes the script from a pickle. Note that this always succeeds
+  // because presumably we were the one that pickled it, and we did it
+  // correctly.
+  void Unpickle(const base::Pickle& pickle, base::PickleIterator* iter);
+
+ private:
+  // base::Pickle helper functions used to pickle the individual types of
+  // components.
+  void PickleGlobs(base::Pickle* pickle,
+                   const std::vector<std::string>& globs) const;
+  void PickleHostID(base::Pickle* pickle, const HostID& host_id) const;
+  void PickleURLPatternSet(base::Pickle* pickle,
+                           const URLPatternSet& pattern_list) const;
+  void PickleScripts(base::Pickle* pickle, const FileList& scripts) const;
+
+  // Unpickle helper functions used to unpickle individual types of components.
+  void UnpickleGlobs(const base::Pickle& pickle,
+                     base::PickleIterator* iter,
+                     std::vector<std::string>* globs);
+  void UnpickleHostID(const base::Pickle& pickle,
+                      base::PickleIterator* iter,
+                      HostID* host_id);
+  void UnpickleURLPatternSet(const base::Pickle& pickle,
+                             base::PickleIterator* iter,
+                             URLPatternSet* pattern_list);
+  void UnpickleScripts(const base::Pickle& pickle,
+                       base::PickleIterator* iter,
+                       FileList* scripts);
+
+  // The location to run the script inside the document.
+  RunLocation run_location_ = DOCUMENT_IDLE;
+
+  // The namespace of the script. This is used by Greasemonkey in the same way
+  // as XML namespaces. Only used when parsing Greasemonkey-style scripts.
+  std::string name_space_;
+
+  // The script's name. Only used when parsing Greasemonkey-style scripts.
+  std::string name_;
+
+  // A longer description. Only used when parsing Greasemonkey-style scripts.
+  std::string description_;
+
+  // A version number of the script. Only used when parsing Greasemonkey-style
+  // scripts.
+  std::string version_;
+
+  // Greasemonkey-style globs that determine pages to inject the script into.
+  // These are only used with standalone scripts.
+  std::vector<std::string> globs_;
+  std::vector<std::string> exclude_globs_;
+
+  // URLPatterns that determine pages to inject the script into. These are
+  // only used with scripts that are part of extensions.
+  URLPatternSet url_set_;
+  URLPatternSet exclude_url_set_;
+
+  // List of js scripts defined in content_scripts
+  FileList js_scripts_;
+
+  // List of css scripts defined in content_scripts
+  FileList css_scripts_;
+
+  // The ID of the host this script is a part of. The |ID| of the
+  // |host_id| can be empty if the script is a "standlone" user script.
+  HostID host_id_;
+
+  // The type of the consumer instance that the script will be injected.
+  ConsumerInstanceType consumer_instance_type_ = TAB;
+
+  // The globally-unique id associated with this user script. -1 indicates
+  // "invalid".
+  int user_script_id_ = -1;
+
+  // Whether we should try to emulate Greasemonkey's APIs when running this
+  // script.
+  bool emulate_greasemonkey_ = false;
+
+  // Whether the user script should run in all frames, or only just the top one.
+  bool match_all_frames_ = false;
+
+  // Whether the user script should run in frames whose initiator / precursor
+  // origin matches a match pattern, if an appropriate URL cannot be found for
+  // the frame for matching purposes, such as in the case of about:, data:, and
+  // other schemes.
+  MatchOriginAsFallbackBehavior match_origin_as_fallback_ =
+      MatchOriginAsFallbackBehavior::kNever;
+
+  // True if the script should be injected into an incognito tab.
+  bool incognito_enabled_ = false;
+
+  DISALLOW_COPY_AND_ASSIGN(UserScript);
+};
+
+// Information we need while removing scripts from a UserScriptLoader.
+struct UserScriptIDPair {
+  UserScriptIDPair(int id, const HostID& host_id);
+  explicit UserScriptIDPair(int id);
+
+  int id;
+  HostID host_id;
+};
+
+bool operator<(const UserScriptIDPair& a, const UserScriptIDPair& b);
+
+using UserScriptList = std::vector<std::unique_ptr<UserScript>>;
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_COMMON_USER_SCRIPT_H_
diff --git a/components/user_scripts/content/common/view_type.cc b/components/user_scripts/content/common/view_type.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/view_type.cc
@@ -0,0 +1,39 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "view_type.h"
+
+#include "base/strings/string_piece.h"
+
+namespace user_scripts {
+
+bool GetViewTypeFromString(const std::string& view_type,
+                           ViewType* view_type_out) {
+  // TODO(devlin): This map doesn't contain the following values:
+  // - VIEW_TYPE_BACKGROUND_CONTENTS
+  // - VIEW_TYPE_COMPONENT
+  // - VIEW_TYPE_EXTENSION_GUEST
+  // Why? Is it just because we don't expose those types to JS?
+  static const struct {
+    ViewType type;
+    base::StringPiece name;
+  } constexpr kTypeMap[] = {
+      // {VIEW_TYPE_APP_WINDOW, "APP_WINDOW"},
+      // {VIEW_TYPE_EXTENSION_BACKGROUND_PAGE, "BACKGROUND"},
+      // {VIEW_TYPE_EXTENSION_DIALOG, "EXTENSION_DIALOG"},
+      // {VIEW_TYPE_EXTENSION_POPUP, "POPUP"},
+      {VIEW_TYPE_TAB_CONTENTS, "TAB"},
+  };
+
+  for (const auto& entry : kTypeMap) {
+    if (entry.name == view_type) {
+      *view_type_out = entry.type;
+      return true;
+    }
+  }
+
+  return false;
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/content/common/view_type.h b/components/user_scripts/content/common/view_type.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/common/view_type.h
@@ -0,0 +1,48 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_COMMON_VIEW_TYPE_H_
+#define EXTENSIONS_COMMON_VIEW_TYPE_H_
+
+#include <string>
+
+namespace user_scripts {
+
+// Icky RTTI used by a few systems to distinguish the host type of a given
+// WebContents.
+//
+// Do not change or reuse the the entry values in this list as this is used in
+// ExtensionViewType enum in tools/metrics/histograms/enums.xml.
+//
+// TODO(aa): Remove this and teach those systems to keep track of their own
+// data.
+enum ViewType {
+  VIEW_TYPE_INVALID = 0,
+  // VIEW_TYPE_APP_WINDOW = 1,
+  // VIEW_TYPE_BACKGROUND_CONTENTS = 2,
+
+  // // For custom parts of Chrome if no other type applies.
+  // VIEW_TYPE_COMPONENT = 3,
+
+  // VIEW_TYPE_EXTENSION_BACKGROUND_PAGE = 4,
+  // VIEW_TYPE_EXTENSION_DIALOG = 5,
+  // VIEW_TYPE_EXTENSION_GUEST = 6,
+  // VIEW_TYPE_EXTENSION_POPUP = 7,
+
+  // Panels were removed in https://crbug.com/571511.
+  // DEPRECATED_VIEW_TYPE_PANEL = 8,
+
+  VIEW_TYPE_TAB_CONTENTS = 9,
+
+  VIEW_TYPE_LAST = VIEW_TYPE_TAB_CONTENTS
+};
+
+// Matches the |view_type| to the corresponding ViewType, and populates
+// |view_type_out|. Returns true if a match is found.
+bool GetViewTypeFromString(const std::string& view_type,
+                           ViewType* view_type_out);
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_COMMON_VIEW_TYPE_H_
diff --git a/components/user_scripts/content/renderer/BUILD.gn b/components/user_scripts/content/renderer/BUILD.gn
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/BUILD.gn
@@ -0,0 +1,97 @@
+# Copyright 2015 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//tools/grit/grit_rule.gni")
+import("//tools/grit/repack.gni")
+
+group("user_scripts_resources") {
+  public_deps = [
+    ":user_scripts_renderer_resources",
+  ]
+}
+
+grit("user_scripts_renderer_resources") {
+  source = "resources/user_scripts_renderer_resources.grd"
+  outputs = [
+    "grit/user_scripts_renderer_resources.h",
+    "user_scripts_renderer_resources.pak",
+  ]
+  grit_flags = [
+    "-E",
+    "mojom_root=" + rebase_path(root_gen_dir, root_build_dir),
+  ]
+}
+
+static_library("renderer") {
+  sources = [
+    "../common/constants.cc",
+    "../common/constants.h",
+    "../common/extension_id.h",
+    "../common/host_id.cc",
+    "../common/host_id.h",
+    "../common/script_constants.h",
+    "../common/url_pattern_set.cc",
+    "../common/url_pattern_set.h",
+    "../common/url_pattern.cc",
+    "../common/url_pattern.h",
+    "../common/user_script.cc",
+    "../common/user_script.h",
+    "../common/view_type.cc",
+    "../common/view_type.h",
+    "../common/extension_messages.cc",
+    "../common/extension_messages.h",
+    "../common/extension_message_generator.cc",
+    "../common/extension_message_generator.h",
+#    "dispatcher_delegate.cc",
+#    "dispatcher_delegate.h",
+    "extension_frame_helper.cc",
+    "extension_frame_helper.h",
+    "injection_host.cc",
+    "injection_host.h",
+#    "programmatic_script_injector.cc",
+#    "programmatic_script_injector.h",
+    "script_injection_manager.cc",
+    "script_injection_manager.h",
+    "script_injection_callback.cc",
+    "script_injection_callback.h",
+    "script_injection.cc",
+    "script_injection.h",
+    "script_injector.h",
+    "script_context.cc",
+    "script_context.h",
+    "scripts_run_info.cc",
+    "scripts_run_info.h",
+    "user_script_injector.cc",
+    "user_script_injector.h",
+    "user_script_set_manager.cc",
+    "user_script_set_manager.h",
+    "user_script_set.cc",
+    "user_script_set.h",
+#    "user_scripts_dispatcher_delegate.cc",
+#    "user_scripts_dispatcher_delegate.h",
+    "user_scripts_dispatcher.cc",
+    "user_scripts_dispatcher.h",
+    "user_scripts_renderer_client.cc",
+    "user_scripts_renderer_client.h",
+    "web_ui_injection_host.cc",
+    "web_ui_injection_host.h",
+  ]
+
+  #public_deps = [ "//components/user_scripts/core/proto" ]
+  deps = [
+    ":user_scripts_resources",
+    "//base",
+    #"//components/dom_distiller/content/common/mojom",
+    #"//components/dom_distiller/core",
+    #"//components/dom_distiller/core/mojom",
+    "//content/public/common",
+    "//content/public/renderer",
+    #"//gin",
+    "//mojo/public/cpp/bindings",
+    #"//services/service_manager/public/cpp",
+    #"//skia",
+    "//third_party/blink/public:blink_headers",
+    "//v8",
+  ]
+}
diff --git a/components/user_scripts/content/renderer/extension_frame_helper.cc b/components/user_scripts/content/renderer/extension_frame_helper.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/extension_frame_helper.cc
@@ -0,0 +1,531 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "extension_frame_helper.h"
+
+#include <set>
+
+#include "base/metrics/histogram_macros.h"
+#include "base/strings/string_util.h"
+#include "base/timer/elapsed_timer.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/renderer/render_view.h"
+//#include "extensions/common/api/messaging/message.h"
+//#include "extensions/common/api/messaging/port_id.h"
+#include "../common/constants.h"
+//#include "extensions/common/extension_messages.h"
+//#include "extensions/common/manifest_handlers/background_info.h"
+//#include "extensions/renderer/api/automation/automation_api_helper.h"
+//#include "extensions/renderer/console.h"
+//#include "extensions/renderer/dispatcher.h"
+//#include "extensions/renderer/native_extension_bindings_system.h"
+//#include "extensions/renderer/native_renderer_messaging_service.h"
+//#include "extensions/renderer/script_context.h"
+//#include "extensions/renderer/script_context_set.h"
+#include "third_party/blink/public/platform/web_security_origin.h"
+#include "third_party/blink/public/web/web_console_message.h"
+#include "third_party/blink/public/web/web_document.h"
+#include "third_party/blink/public/web/web_document_loader.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "third_party/blink/public/web/web_settings.h"
+#include "third_party/blink/public/web/web_view.h"
+
+namespace user_scripts {
+
+namespace {
+
+// constexpr int kMainWorldId = 0;
+
+base::LazyInstance<std::set<const ExtensionFrameHelper*>>::DestructorAtExit
+    g_frame_helpers = LAZY_INSTANCE_INITIALIZER;
+
+// // Returns true if the render frame corresponding with |frame_helper| matches
+// // the given criteria.
+// bool RenderFrameMatches(const ExtensionFrameHelper* frame_helper,
+//                         ViewType match_view_type,
+//                         int match_window_id,
+//                         int match_tab_id,
+//                         const std::string& match_extension_id) {
+//   if (match_view_type != VIEW_TYPE_INVALID &&
+//       frame_helper->view_type() != match_view_type)
+//     return false;
+
+//   // Not all frames have a valid ViewType, e.g. devtools, most GuestViews, and
+//   // unclassified detached WebContents.
+//   if (frame_helper->view_type() == VIEW_TYPE_INVALID)
+//     return false;
+
+//   // This logic matches ExtensionWebContentsObserver::GetExtensionFromFrame.
+//   blink::WebSecurityOrigin origin =
+//       frame_helper->render_frame()->GetWebFrame()->GetSecurityOrigin();
+//   if (origin.IsOpaque() ||
+//       !base::EqualsASCII(origin.Protocol().Utf16(), kExtensionScheme) ||
+//       !base::EqualsASCII(origin.Host().Utf16(), match_extension_id.c_str()))
+//     return false;
+
+//   if (match_window_id != extension_misc::kUnknownWindowId &&
+//       frame_helper->browser_window_id() != match_window_id)
+//     return false;
+
+//   if (match_tab_id != extension_misc::kUnknownTabId &&
+//       frame_helper->tab_id() != match_tab_id)
+//     return false;
+
+//   return true;
+// }
+
+// Runs every callback in |callbacks_to_be_run_and_cleared| while |frame_helper|
+// is valid, and clears |callbacks_to_be_run_and_cleared|.
+void RunCallbacksWhileFrameIsValid(
+    base::WeakPtr<ExtensionFrameHelper> frame_helper,
+    std::vector<base::Closure>* callbacks_to_be_run_and_cleared) {
+  // The JavaScript code can cause re-entrancy. To avoid a deadlock, don't run
+  // callbacks that are added during the iteration.
+  std::vector<base::Closure> callbacks;
+  callbacks_to_be_run_and_cleared->swap(callbacks);
+  for (auto& callback : callbacks) {
+    callback.Run();
+    if (!frame_helper.get())
+      return;  // Frame and ExtensionFrameHelper invalidated by callback.
+  }
+}
+
+// enum class PortType {
+//   EXTENSION,
+//   TAB,
+//   NATIVE_APP,
+// };
+
+// // Returns an extension hosted in the |render_frame| (or nullptr if the frame
+// // doesn't host an extension).
+// const Extension* GetExtensionFromFrame(content::RenderFrame* render_frame) {
+//   DCHECK(render_frame);
+//   ScriptContext* context =
+//       ScriptContextSet::GetMainWorldContextForFrame(render_frame);
+//   return context ? context->effective_extension() : nullptr;
+// }
+
+}  // namespace
+
+ExtensionFrameHelper::ExtensionFrameHelper(content::RenderFrame* render_frame /*,
+                                           Dispatcher* extension_dispatcher*/)
+    : content::RenderFrameObserver(render_frame),
+      content::RenderFrameObserverTracker<ExtensionFrameHelper>(render_frame),
+      //view_type_(VIEW_TYPE_INVALID),
+      tab_id_(-1) //,
+      //browser_window_id_(-1),
+      //extension_dispatcher_(extension_dispatcher),
+      /*did_create_current_document_element_(false)*/ {
+  g_frame_helpers.Get().insert(this);
+  // if (render_frame->IsMainFrame()) {
+  //   // Manages its own lifetime.
+  //   new AutomationApiHelper(render_frame);
+  // }
+}
+
+ExtensionFrameHelper::~ExtensionFrameHelper() {
+  g_frame_helpers.Get().erase(this);
+}
+
+void ExtensionFrameHelper::ScheduleAtDocumentStart(
+    const base::Closure& callback) {
+  document_element_created_callbacks_.push_back(callback);
+}
+
+void ExtensionFrameHelper::ScheduleAtDocumentEnd(
+    const base::Closure& callback) {
+  document_load_finished_callbacks_.push_back(callback);
+}
+
+void ExtensionFrameHelper::ScheduleAtDocumentIdle(
+    const base::Closure& callback) {
+  document_idle_callbacks_.push_back(callback);
+}
+
+void ExtensionFrameHelper::RunScriptsAtDocumentStart() {
+  //DCHECK(did_create_current_document_element_);
+  RunCallbacksWhileFrameIsValid(weak_ptr_factory_.GetWeakPtr(),
+                                &document_element_created_callbacks_);
+  // |this| might be dead by now.
+}
+
+void ExtensionFrameHelper::RunScriptsAtDocumentEnd() {
+  RunCallbacksWhileFrameIsValid(weak_ptr_factory_.GetWeakPtr(),
+                                &document_load_finished_callbacks_);
+  // |this| might be dead by now.
+}
+
+void ExtensionFrameHelper::RunScriptsAtDocumentIdle() {
+  RunCallbacksWhileFrameIsValid(weak_ptr_factory_.GetWeakPtr(),
+                                &document_idle_callbacks_);
+  // |this| might be dead by now.
+}
+
+void ExtensionFrameHelper::OnDestruct() {
+  delete this;
+}
+
+
+// // static
+// std::vector<content::RenderFrame*> ExtensionFrameHelper::GetExtensionFrames(
+//     const std::string& extension_id,
+//     int browser_window_id,
+//     int tab_id,
+//     ViewType view_type) {
+//   std::vector<content::RenderFrame*> render_frames;
+//   for (const ExtensionFrameHelper* helper : g_frame_helpers.Get()) {
+//     if (RenderFrameMatches(helper, view_type, browser_window_id, tab_id,
+//                            extension_id))
+//       render_frames.push_back(helper->render_frame());
+//   }
+//   return render_frames;
+// }
+
+// // static
+// v8::Local<v8::Array> ExtensionFrameHelper::GetV8MainFrames(
+//     v8::Local<v8::Context> context,
+//     const std::string& extension_id,
+//     int browser_window_id,
+//     int tab_id,
+//     ViewType view_type) {
+//   // WebFrame::ScriptCanAccess uses the isolate's current context. We need to
+//   // make sure that the current context is the one we're expecting.
+//   DCHECK(context == context->GetIsolate()->GetCurrentContext());
+//   std::vector<content::RenderFrame*> render_frames =
+//       GetExtensionFrames(extension_id, browser_window_id, tab_id, view_type);
+//   v8::Local<v8::Array> v8_frames = v8::Array::New(context->GetIsolate());
+
+//   int v8_index = 0;
+//   for (content::RenderFrame* frame : render_frames) {
+//     if (!frame->IsMainFrame())
+//       continue;
+
+//     blink::WebLocalFrame* web_frame = frame->GetWebFrame();
+//     if (!blink::WebFrame::ScriptCanAccess(web_frame))
+//       continue;
+
+//     v8::Local<v8::Context> frame_context = web_frame->MainWorldScriptContext();
+//     if (!frame_context.IsEmpty()) {
+//       v8::Local<v8::Value> window = frame_context->Global();
+//       CHECK(!window.IsEmpty());
+//       v8::Maybe<bool> maybe =
+//           v8_frames->CreateDataProperty(context, v8_index++, window);
+//       CHECK(maybe.IsJust() && maybe.FromJust());
+//     }
+//   }
+
+//   return v8_frames;
+// }
+
+// // static
+// content::RenderFrame* ExtensionFrameHelper::GetBackgroundPageFrame(
+//     const std::string& extension_id) {
+//   for (const ExtensionFrameHelper* helper : g_frame_helpers.Get()) {
+//     if (RenderFrameMatches(helper, VIEW_TYPE_EXTENSION_BACKGROUND_PAGE,
+//                            extension_misc::kUnknownWindowId,
+//                            extension_misc::kUnknownTabId, extension_id)) {
+//       blink::WebLocalFrame* web_frame = helper->render_frame()->GetWebFrame();
+//       // Check if this is the top frame.
+//       if (web_frame->Top() == web_frame)
+//         return helper->render_frame();
+//     }
+//   }
+//   return nullptr;
+// }
+
+// v8::Local<v8::Value> ExtensionFrameHelper::GetV8BackgroundPageMainFrame(
+//     v8::Isolate* isolate,
+//     const std::string& extension_id) {
+//   content::RenderFrame* main_frame = GetBackgroundPageFrame(extension_id);
+
+//   v8::Local<v8::Value> background_page;
+//   blink::WebLocalFrame* web_frame =
+//       main_frame ? main_frame->GetWebFrame() : nullptr;
+//   if (web_frame && blink::WebFrame::ScriptCanAccess(web_frame))
+//     background_page = web_frame->MainWorldScriptContext()->Global();
+//   else
+//     background_page = v8::Undefined(isolate);
+
+//   return background_page;
+// }
+
+// // static
+// content::RenderFrame* ExtensionFrameHelper::FindFrame(
+//     content::RenderFrame* relative_to_frame,
+//     const std::string& name) {
+//   // Only pierce browsing instance boundaries if |relative_to_frame| is an
+//   // extension.
+//   const Extension* extension = GetExtensionFromFrame(relative_to_frame);
+//   if (!extension)
+//     return nullptr;
+
+//   for (const ExtensionFrameHelper* target : g_frame_helpers.Get()) {
+//     // Skip frames with a mismatched name.
+//     if (target->render_frame()->GetWebFrame()->AssignedName().Utf8() != name)
+//       continue;
+
+//     // Only pierce browsing instance boundaries if the target frame is from the
+//     // same extension (but not when another extension shares the same renderer
+//     // process because of reuse trigerred by process limit).
+//     if (extension != GetExtensionFromFrame(target->render_frame()))
+//       continue;
+
+//     return target->render_frame();
+//   }
+
+//   return nullptr;
+// }
+
+// // static
+// bool ExtensionFrameHelper::IsContextForEventPage(const ScriptContext* context) {
+//   content::RenderFrame* render_frame = context->GetRenderFrame();
+//   return context->extension() && render_frame &&
+//          BackgroundInfo::HasLazyBackgroundPage(context->extension()) &&
+//          ExtensionFrameHelper::Get(render_frame)->view_type() ==
+//               VIEW_TYPE_EXTENSION_BACKGROUND_PAGE;
+// }
+
+// void ExtensionFrameHelper::DidCreateDocumentElement() {
+//   did_create_current_document_element_ = true;
+//   extension_dispatcher_->DidCreateDocumentElement(
+//       render_frame()->GetWebFrame());
+// }
+
+// void ExtensionFrameHelper::DidCreateNewDocument() {
+//   did_create_current_document_element_ = false;
+// }
+
+// void ExtensionFrameHelper::ReadyToCommitNavigation(
+//     blink::WebDocumentLoader* document_loader) {
+//   // New window created by chrome.app.window.create() must not start parsing the
+//   // document immediately. The chrome.app.window.create() callback (if any)
+//   // needs to be called prior to the new window's 'load' event. The parser will
+//   // be resumed when it happens. It doesn't apply to sandboxed pages.
+//   if (view_type_ == VIEW_TYPE_APP_WINDOW && render_frame()->IsMainFrame() &&
+//       !has_started_first_navigation_ &&
+//       GURL(document_loader->GetUrl()).SchemeIs(kExtensionScheme) &&
+//       !ScriptContext::IsSandboxedPage(document_loader->GetUrl())) {
+//     document_loader->BlockParser();
+//   }
+
+//   has_started_first_navigation_ = true;
+
+//   if (!delayed_main_world_script_initialization_)
+//     return;
+
+//   delayed_main_world_script_initialization_ = false;
+//   v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
+//   v8::Local<v8::Context> context =
+//       render_frame()->GetWebFrame()->MainWorldScriptContext();
+//   v8::Context::Scope context_scope(context);
+//   // Normally we would use Document's URL for all kinds of checks, e.g. whether
+//   // to inject a content script. However, when committing a navigation, we
+//   // should use the URL of a Document being committed instead. This URL is
+//   // accessible through WebDocumentLoader::GetURL().
+//   // The scope below temporary maps a frame to a document loader, so that places
+//   // which retrieve URL can use the right one. Ideally, we would plumb the
+//   // correct URL (or maybe WebDocumentLoader) through the callchain, but there
+//   // are many callers which will have to pass nullptr.
+//   ScriptContext::ScopedFrameDocumentLoader scoped_document_loader(
+//       render_frame()->GetWebFrame(), document_loader);
+//   extension_dispatcher_->DidCreateScriptContext(render_frame()->GetWebFrame(),
+//                                                 context, kMainWorldId);
+//   // TODO(devlin): Add constants for main world id, no extension group.
+// }
+
+// void ExtensionFrameHelper::DidCommitProvisionalLoad(
+//     ui::PageTransition transition) {
+//   // Grant cross browsing instance frame lookup if we are an extension. This
+//   // should match the conditions in FindFrame.
+//   content::RenderFrame* frame = render_frame();
+//   if (GetExtensionFromFrame(frame))
+//     frame->SetAllowsCrossBrowsingInstanceFrameLookup();
+// }
+
+// void ExtensionFrameHelper::DidCreateScriptContext(
+//     v8::Local<v8::Context> context,
+//     int32_t world_id) {
+//   if (world_id == kMainWorldId) {
+//     if (render_frame()->IsBrowserSideNavigationPending()) {
+//       // Defer initializing the extensions script context now because it depends
+//       // on having the URL of the provisional load which isn't available at this
+//       // point.
+//       // We can come here twice in the case of window.open(url): first for
+//       // about:blank empty document, then possibly for the actual url load
+//       // (depends on whoever triggers window proxy init), before getting
+//       // ReadyToCommitNavigation.
+//       delayed_main_world_script_initialization_ = true;
+//       return;
+//     }
+//     // Sometimes DidCreateScriptContext comes before ReadyToCommitNavigation.
+//     // In this case we don't have to wait until ReadyToCommitNavigation.
+//     // TODO(dgozman): ensure consistent call order between
+//     // DidCreateScriptContext and ReadyToCommitNavigation.
+//     delayed_main_world_script_initialization_ = false;
+//   }
+//   extension_dispatcher_->DidCreateScriptContext(render_frame()->GetWebFrame(),
+//                                                 context, world_id);
+// }
+
+// void ExtensionFrameHelper::WillReleaseScriptContext(
+//     v8::Local<v8::Context> context,
+//     int32_t world_id) {
+//   extension_dispatcher_->WillReleaseScriptContext(
+//       render_frame()->GetWebFrame(), context, world_id);
+// }
+
+// bool ExtensionFrameHelper::OnMessageReceived(const IPC::Message& message) {
+//   bool handled = true;
+//   IPC_BEGIN_MESSAGE_MAP(ExtensionFrameHelper, message)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_ValidateMessagePort,
+//                         OnExtensionValidateMessagePort)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_DispatchOnConnect,
+//                         OnExtensionDispatchOnConnect)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_DeliverMessage, OnExtensionDeliverMessage)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_DispatchOnDisconnect,
+//                         OnExtensionDispatchOnDisconnect)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_SetTabId, OnExtensionSetTabId)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_UpdateBrowserWindowId,
+//                         OnUpdateBrowserWindowId)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_NotifyRenderViewType,
+//                         OnNotifyRendererViewType)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_Response, OnExtensionResponse)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_MessageInvoke, OnExtensionMessageInvoke)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_SetFrameName, OnSetFrameName)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_AppWindowClosed, OnAppWindowClosed)
+//     IPC_MESSAGE_HANDLER(ExtensionMsg_SetSpatialNavigationEnabled,
+//                         OnSetSpatialNavigationEnabled)
+//     IPC_MESSAGE_UNHANDLED(handled = false)
+//   IPC_END_MESSAGE_MAP()
+//   return handled;
+// }
+
+// void ExtensionFrameHelper::OnExtensionValidateMessagePort(int worker_thread_id,
+//                                                           const PortId& id) {
+//   DCHECK_EQ(kMainThreadId, worker_thread_id);
+//   extension_dispatcher_->bindings_system()
+//       ->messaging_service()
+//       ->ValidateMessagePort(
+//           extension_dispatcher_->script_context_set_iterator(), id,
+//           render_frame());
+// }
+
+// void ExtensionFrameHelper::OnExtensionDispatchOnConnect(
+//     int worker_thread_id,
+//     const PortId& target_port_id,
+//     const std::string& channel_name,
+//     const ExtensionMsg_TabConnectionInfo& source,
+//     const ExtensionMsg_ExternalConnectionInfo& info) {
+//   DCHECK_EQ(kMainThreadId, worker_thread_id);
+//   extension_dispatcher_->bindings_system()
+//       ->messaging_service()
+//       ->DispatchOnConnect(extension_dispatcher_->script_context_set_iterator(),
+//                           target_port_id, channel_name, source, info,
+//                           render_frame());
+// }
+
+// void ExtensionFrameHelper::OnExtensionDeliverMessage(int worker_thread_id,
+//                                                      const PortId& target_id,
+//                                                      const Message& message) {
+//   DCHECK_EQ(kMainThreadId, worker_thread_id);
+//   extension_dispatcher_->bindings_system()->messaging_service()->DeliverMessage(
+//       extension_dispatcher_->script_context_set_iterator(), target_id, message,
+//       render_frame());
+// }
+
+// void ExtensionFrameHelper::OnExtensionDispatchOnDisconnect(
+//     int worker_thread_id,
+//     const PortId& id,
+//     const std::string& error_message) {
+//   DCHECK_EQ(kMainThreadId, worker_thread_id);
+//   extension_dispatcher_->bindings_system()
+//       ->messaging_service()
+//       ->DispatchOnDisconnect(
+//           extension_dispatcher_->script_context_set_iterator(), id,
+//           error_message, render_frame());
+// }
+
+// void ExtensionFrameHelper::OnExtensionSetTabId(int tab_id) {
+//   CHECK_EQ(tab_id_, -1);
+//   CHECK_GE(tab_id, 0);
+//   tab_id_ = tab_id;
+// }
+
+// void ExtensionFrameHelper::OnUpdateBrowserWindowId(int browser_window_id) {
+//   browser_window_id_ = browser_window_id;
+// }
+
+// void ExtensionFrameHelper::OnNotifyRendererViewType(ViewType type) {
+//   // TODO(devlin): It'd be really nice to be able to
+//   // DCHECK_EQ(VIEW_TYPE_INVALID, view_type_) here.
+//   view_type_ = type;
+// }
+
+// void ExtensionFrameHelper::OnExtensionResponse(int request_id,
+//                                                bool success,
+//                                                const base::ListValue& response,
+//                                                const std::string& error) {
+//   extension_dispatcher_->OnExtensionResponse(request_id,
+//                                              success,
+//                                              response,
+//                                              error);
+// }
+
+// void ExtensionFrameHelper::OnExtensionMessageInvoke(
+//     const std::string& extension_id,
+//     const std::string& module_name,
+//     const std::string& function_name,
+//     const base::ListValue& args) {
+//   extension_dispatcher_->InvokeModuleSystemMethod(
+//       render_frame(), extension_id, module_name, function_name, args);
+// }
+
+// void ExtensionFrameHelper::OnSetFrameName(const std::string& name) {
+//   render_frame()->GetWebFrame()->SetName(blink::WebString::FromUTF8(name));
+// }
+
+// void ExtensionFrameHelper::OnAppWindowClosed(bool send_onclosed) {
+//   DCHECK(render_frame()->IsMainFrame());
+
+//   if (!send_onclosed)
+//     return;
+
+//   v8::HandleScope scope(v8::Isolate::GetCurrent());
+//   v8::Local<v8::Context> v8_context =
+//       render_frame()->GetWebFrame()->MainWorldScriptContext();
+//   ScriptContext* script_context =
+//       ScriptContextSet::GetContextByV8Context(v8_context);
+//   if (!script_context)
+//     return;
+//   script_context->module_system()->CallModuleMethodSafe("app.window",
+//                                                         "onAppWindowClosed");
+// }
+
+// void ExtensionFrameHelper::OnSetSpatialNavigationEnabled(bool enabled) {
+//   render_frame()
+//       ->GetRenderView()
+//       ->GetWebView()
+//       ->GetSettings()
+//       ->SetSpatialNavigationEnabled(enabled);
+// }
+
+// void ExtensionFrameHelper::DraggableRegionsChanged() {
+//   if (!render_frame()->IsMainFrame())
+//     return;
+
+//   blink::WebVector<blink::WebDraggableRegion> webregions =
+//       render_frame()->GetWebFrame()->GetDocument().DraggableRegions();
+//   std::vector<DraggableRegion> regions;
+//   for (blink::WebDraggableRegion& webregion : webregions) {
+//     render_frame()->ConvertViewportToWindow(&webregion.bounds);
+
+//     regions.push_back(DraggableRegion());
+//     DraggableRegion& region = regions.back();
+//     region.bounds = webregion.bounds;
+//     region.draggable = webregion.draggable;
+//   }
+//   Send(new ExtensionHostMsg_UpdateDraggableRegions(routing_id(), regions));
+// }
+
+}  // namespace extensions
diff --git a/components/user_scripts/content/renderer/extension_frame_helper.h b/components/user_scripts/content/renderer/extension_frame_helper.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/extension_frame_helper.h
@@ -0,0 +1,204 @@
+// Copyright 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_EXTENSION_FRAME_HELPER_H_
+#define EXTENSIONS_RENDERER_EXTENSION_FRAME_HELPER_H_
+
+#include <string>
+#include <vector>
+
+#include "base/callback_forward.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "content/public/renderer/render_frame_observer.h"
+#include "content/public/renderer/render_frame_observer_tracker.h"
+#include "../common/view_type.h"
+#include "third_party/blink/public/mojom/devtools/console_message.mojom.h"
+#include "v8/include/v8.h"
+
+struct ExtensionMsg_ExternalConnectionInfo;
+struct ExtensionMsg_TabConnectionInfo;
+
+namespace base {
+class ListValue;
+}
+
+namespace user_scripts {
+
+class Dispatcher;
+struct Message;
+struct PortId;
+class ScriptContext;
+
+// RenderFrame-level plumbing for extension features.
+class ExtensionFrameHelper
+    : public content::RenderFrameObserver,
+      public content::RenderFrameObserverTracker<ExtensionFrameHelper> {
+ public:
+  ExtensionFrameHelper(content::RenderFrame* render_frame /*,
+                       Dispatcher* extension_dispatcher*/);
+  ~ExtensionFrameHelper() override;
+
+//   // Returns a list of extension RenderFrames that match the given filter
+//   // criteria. A |browser_window_id| of extension_misc::kUnknownWindowId
+//   // specifies "all", as does a |view_type| of VIEW_TYPE_INVALID.
+//   static std::vector<content::RenderFrame*> GetExtensionFrames(
+//       const std::string& extension_id,
+//       int browser_window_id,
+//       int tab_id,
+//       ViewType view_type);
+//   // Same as above, but returns a v8::Array of the v8 global objects for those
+//   // frames, and only includes main frames. Note: This only returns contexts
+//   // that are accessible by |context|, and |context| must be the current
+//   // context.
+//   // Returns an empty v8::Array if no frames are found.
+//   static v8::Local<v8::Array> GetV8MainFrames(v8::Local<v8::Context> context,
+//                                               const std::string& extension_id,
+//                                               int browser_window_id,
+//                                               int tab_id,
+//                                               ViewType view_type);
+
+//   // Returns the main frame of the extension's background page, or null if there
+//   // isn't one in this process.
+//   static content::RenderFrame* GetBackgroundPageFrame(
+//       const std::string& extension_id);
+//   // Same as above, but returns the background page's main frame, or
+//   // v8::Undefined if there is none. Note: This will assert that the
+//   // isolate's current context can access the returned object; callers should
+//   // ensure that the current context is correct.
+//   static v8::Local<v8::Value> GetV8BackgroundPageMainFrame(
+//       v8::Isolate* isolate,
+//       const std::string& extension_id);
+
+//   // Finds a neighboring extension frame with the same extension as the one
+//   // owning |relative_to_frame| (if |relative_to_frame| is not an extension
+//   // frame, returns nullptr). Pierces the browsing instance boundary because
+//   // certain extensions rely on this behavior.
+//   // TODO(devlin, lukasza): https://crbug.com/786411: Remove this behavior, and
+//   // make extensions follow the web standard for finding frames or use an
+//   // explicit API.
+//   static content::RenderFrame* FindFrame(
+//       content::RenderFrame* relative_to_frame,
+//       const std::string& name);
+
+//   // Returns true if the given |context| is for any frame in the extension's
+//   // event page.
+//   // TODO(devlin): This isn't really used properly, and should probably be
+//   // deleted.
+//   static bool IsContextForEventPage(const ScriptContext* context);
+
+//   ViewType view_type() const { return view_type_; }
+   int tab_id() const { return tab_id_; }
+//   int browser_window_id() const { return browser_window_id_; }
+//   bool did_create_current_document_element() const {
+//     return did_create_current_document_element_;
+//   }
+
+  // Called when the document element has been inserted in this frame. This
+  // method may invoke untrusted JavaScript code that invalidate the frame and
+  // this ExtensionFrameHelper.
+  void RunScriptsAtDocumentStart();
+
+  // Called after the DOMContentLoaded event has fired.
+  void RunScriptsAtDocumentEnd();
+
+  // Called before the window.onload event is fired.
+  void RunScriptsAtDocumentIdle();
+
+  // Schedule a callback, to be run at the next RunScriptsAtDocumentStart
+  // notification. Only call this when you are certain that there will be such a
+  // notification, e.g. from RenderFrameObserver::DidCreateDocumentElement.
+  // Otherwise the callback is never invoked, or invoked for a document that you
+  // were not expecting.
+  void ScheduleAtDocumentStart(const base::Closure& callback);
+
+  // Schedule a callback, to be run at the next RunScriptsAtDocumentEnd call.
+  void ScheduleAtDocumentEnd(const base::Closure& callback);
+
+  // Schedule a callback, to be run at the next RunScriptsAtDocumentIdle call.
+  void ScheduleAtDocumentIdle(const base::Closure& callback);
+
+ private:
+  // RenderFrameObserver implementation.
+//   void DidCreateDocumentElement() override;
+//   void DidCreateNewDocument() override;
+//   void ReadyToCommitNavigation(
+//       blink::WebDocumentLoader* document_loader) override;
+//   void DidCommitProvisionalLoad(ui::PageTransition transition) override;
+//   void DidCreateScriptContext(v8::Local<v8::Context>,
+//                               int32_t world_id) override;
+//   void WillReleaseScriptContext(v8::Local<v8::Context>,
+//                                 int32_t world_id) override;
+//   bool OnMessageReceived(const IPC::Message& message) override;
+  void OnDestruct() override;
+//   void DraggableRegionsChanged() override;
+
+  // IPC handlers.
+//   void OnExtensionValidateMessagePort(int worker_thread_id, const PortId& id);
+//   void OnExtensionDispatchOnConnect(
+//       int worker_thread_id,
+//       const PortId& target_port_id,
+//       const std::string& channel_name,
+//       const ExtensionMsg_TabConnectionInfo& source,
+//       const ExtensionMsg_ExternalConnectionInfo& info);
+//   void OnExtensionDeliverMessage(int worker_thread_id,
+//                                  const PortId& target_port_id,
+//                                  const Message& message);
+//   void OnExtensionDispatchOnDisconnect(int worker_thread_id,
+//                                        const PortId& id,
+//                                        const std::string& error_message);
+//   void OnExtensionSetTabId(int tab_id);
+//   void OnUpdateBrowserWindowId(int browser_window_id);
+//   void OnNotifyRendererViewType(ViewType view_type);
+//   void OnExtensionResponse(int request_id,
+//                            bool success,
+//                            const base::ListValue& response,
+//                            const std::string& error);
+//   void OnExtensionMessageInvoke(const std::string& extension_id,
+//                                 const std::string& module_name,
+//                                 const std::string& function_name,
+//                                 const base::ListValue& args);
+//   void OnSetFrameName(const std::string& name);
+//   void OnAppWindowClosed(bool send_onclosed);
+//   void OnSetSpatialNavigationEnabled(bool enabled);
+
+  // Type of view associated with the RenderFrame.
+  //ViewType view_type_;
+
+  // The id of the tab the render frame is attached to.
+  int tab_id_;
+
+  // The id of the browser window the render frame is attached to.
+  //int browser_window_id_;
+
+  //Dispatcher* extension_dispatcher_;
+
+  // Whether or not the current document element has been created.
+  //bool did_create_current_document_element_;
+
+  // Callbacks to be run at the next RunScriptsAtDocumentStart notification.
+  std::vector<base::Closure> document_element_created_callbacks_;
+
+  // Callbacks to be run at the next RunScriptsAtDocumentEnd notification.
+  std::vector<base::Closure> document_load_finished_callbacks_;
+
+  // Callbacks to be run at the next RunScriptsAtDocumentIdle notification.
+  std::vector<base::Closure> document_idle_callbacks_;
+
+  //bool delayed_main_world_script_initialization_ = false;
+
+  // Whether or not a DocumentLoader has been created at least once for this
+  // RenderFrame.
+  // Note: Chrome Apps intentionally do not support new navigations. When a
+  // navigation happens, it is either the initial one or a reload.
+  //bool has_started_first_navigation_ = false;
+
+  base::WeakPtrFactory<ExtensionFrameHelper> weak_ptr_factory_{this};
+
+  DISALLOW_COPY_AND_ASSIGN(ExtensionFrameHelper);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_EXTENSION_FRAME_HELPER_H_
diff --git a/components/user_scripts/content/renderer/injection_host.cc b/components/user_scripts/content/renderer/injection_host.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/injection_host.cc
@@ -0,0 +1,12 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "injection_host.h"
+
+InjectionHost::InjectionHost(const HostID& host_id) :
+    id_(host_id) {
+}
+
+InjectionHost::~InjectionHost() {
+}
diff --git a/components/user_scripts/content/renderer/injection_host.h b/components/user_scripts/content/renderer/injection_host.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/injection_host.h
@@ -0,0 +1,50 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_INJECTION_HOST_H_
+#define EXTENSIONS_RENDERER_INJECTION_HOST_H_
+
+#include "base/macros.h"
+#include "../common/host_id.h"
+//#include "../common/permissions/permissions_data.h"
+#include "url/gurl.h"
+
+namespace content {
+class RenderFrame;
+}
+
+// An interface for all kinds of hosts who own user scripts.
+class InjectionHost {
+ public:
+  InjectionHost(const HostID& host_id);
+  virtual ~InjectionHost();
+
+  // Returns the CSP to be used for the isolated world. Currently this only
+  // bypasses the main world CSP. If null is returned, the main world CSP is not
+  // bypassed.
+  virtual const std::string* GetContentSecurityPolicy() const = 0;
+
+  // The base url for the host.
+  virtual const GURL& url() const = 0;
+
+  // The human-readable name of the host.
+  virtual const std::string& name() const = 0;
+
+  // Returns true if the script should execute.
+//  virtual extensions::PermissionsData::PageAccess CanExecuteOnFrame(
+//      const GURL& document_url,
+//      content::RenderFrame* render_frame,
+//      int tab_id,
+//      bool is_declarative) const = 0;
+
+  const HostID& id() const { return id_; }
+
+ private:
+  // The ID of the host.
+  HostID id_;
+
+  DISALLOW_COPY_AND_ASSIGN(InjectionHost);
+};
+
+#endif  // EXTENSIONS_RENDERER_INJECTION_HOST_H_
diff --git a/components/user_scripts/content/renderer/resources/greasemonkey_api.js b/components/user_scripts/content/renderer/resources/greasemonkey_api.js
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/resources/greasemonkey_api.js
@@ -0,0 +1,82 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// -----------------------------------------------------------------------------
+// NOTE: If you change this file you need to touch renderer_resources.grd to
+// have your change take effect.
+// -----------------------------------------------------------------------------
+
+// Partial implementation of the Greasemonkey API, see:
+// http://wiki.greasespot.net/Greasemonkey_Manual:APIs
+
+function GM_addStyle(css) {
+  var parent = document.getElementsByTagName("head")[0];
+  if (!parent) {
+    parent = document.documentElement;
+  }
+  var style = document.createElement("style");
+  style.type = "text/css";
+  var textNode = document.createTextNode(css);
+  style.appendChild(textNode);
+  parent.appendChild(style);
+}
+
+function GM_xmlhttpRequest(details) {
+  function setupEvent(xhr, url, eventName, callback) {
+    xhr[eventName] = function () {
+      var isComplete = xhr.readyState == 4;
+      var responseState = {
+        responseText: xhr.responseText,
+        readyState: xhr.readyState,
+        responseHeaders: isComplete ? xhr.getAllResponseHeaders() : "",
+        status: isComplete ? xhr.status : 0,
+        statusText: isComplete ? xhr.statusText : "",
+        finalUrl: isComplete ? url : ""
+      };
+      callback(responseState);
+    };
+  }
+
+  var xhr = new XMLHttpRequest();
+  var eventNames = ["onload", "onerror", "onreadystatechange"];
+  for (var i = 0; i < eventNames.length; i++ ) {
+    var eventName = eventNames[i];
+    if (eventName in details) {
+      setupEvent(xhr, details.url, eventName, details[eventName]);
+    }
+  }
+
+  xhr.open(details.method, details.url);
+
+  if (details.overrideMimeType) {
+    xhr.overrideMimeType(details.overrideMimeType);
+  }
+  if (details.headers) {
+    for (var header in details.headers) {
+      xhr.setRequestHeader(header, details.headers[header]);
+    }
+  }
+  xhr.send(details.data ? details.data : null);
+}
+
+function GM_openInTab(url) {
+  window.open(url, "");
+}
+
+function GM_log(message) {
+  window.console.log(message);
+}
+
+(function() {
+  function generateGreasemonkeyStub(name) {
+    return function() {
+      console.log("%s is not supported.", name);
+    };
+  }
+
+  var apis = ["GM_getValue", "GM_setValue", "GM_registerMenuCommand"];
+  for (var i = 0, api; api = apis[i]; i++) {
+    window[api] = generateGreasemonkeyStub(api);
+  }
+})();
diff --git a/components/user_scripts/content/renderer/resources/user_scripts_renderer_resources.grd b/components/user_scripts/content/renderer/resources/user_scripts_renderer_resources.grd
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/resources/user_scripts_renderer_resources.grd
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<grit latest_public_release="0" current_release="1" output_all_resource_defines="false">
+  <outputs>
+    <output filename="grit/user_scripts_renderer_resources.h" type="rc_header">
+      <emit emit_type='prepend'></emit>
+    </output>
+    <output filename="user_scripts_renderer_resources.pak" type="data_package" />
+  </outputs>
+  <release seq="1">
+    <includes>
+      <include name="IDR_GREASEMONKEY_API_JS" file="greasemonkey_api.js" type="BINDATA" />
+    </includes>
+  </release>
+</grit>
diff --git a/components/user_scripts/content/renderer/script_context.cc b/components/user_scripts/content/renderer/script_context.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/script_context.cc
@@ -0,0 +1,665 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "script_context.h"
+
+#include "base/command_line.h"
+#include "base/containers/flat_set.h"
+#include "base/logging.h"
+#include "base/stl_util.h"
+#include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/values.h"
+#include "content/public/common/content_switches.h"
+#include "content/public/common/url_constants.h"
+#include "content/public/renderer/render_frame.h"
+#include "../common/constants.h"
+//#include "extensions/common/extension.h"
+//#include "extensions/common/extension_api.h"
+//#include "extensions/common/extension_urls.h"
+//#include "extensions/common/manifest_handlers/sandboxed_page_info.h"
+//#include "extensions/common/permissions/permissions_data.h"
+//#include "extensions/renderer/renderer_extension_registry.h"
+//#include "extensions/renderer/v8_helpers.h"
+#include "third_party/blink/public/mojom/service_worker/service_worker_registration.mojom.h"
+#include "third_party/blink/public/platform/web_security_origin.h"
+#include "third_party/blink/public/web/web_document.h"
+#include "third_party/blink/public/web/web_document_loader.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "third_party/blink/public/web/web_navigation_params.h"
+#include "v8/include/v8.h"
+
+namespace user_scripts {
+
+namespace {
+
+GURL GetEffectiveDocumentURL(
+    blink::WebLocalFrame* frame,
+    const GURL& document_url,
+    MatchOriginAsFallbackBehavior match_origin_as_fallback,
+    bool allow_inaccessible_parents) {
+  auto should_consider_origin = [document_url, match_origin_as_fallback]() {
+    switch (match_origin_as_fallback) {
+      case MatchOriginAsFallbackBehavior::kNever:
+        return false;
+      case MatchOriginAsFallbackBehavior::kMatchForAboutSchemeAndClimbTree:
+        return document_url.SchemeIs(url::kAboutScheme);
+      case MatchOriginAsFallbackBehavior::kAlways:
+        // TODO(devlin): Add more schemes here - blob, filesystem, etc.
+        return document_url.SchemeIs(url::kAboutScheme) ||
+               document_url.SchemeIs(url::kDataScheme);
+    }
+
+    NOTREACHED();
+  };
+
+  // If we don't need to consider the origin, we're done.
+  if (!should_consider_origin())
+    return document_url;
+
+  // Get the "security origin" for the frame. For about: frames, this is the
+  // origin of that of the controlling frame - e.g., an about:blank frame on
+  // https://example.com will have the security origin of https://example.com.
+  // Other frames, like data: frames, will have an opaque origin. For these,
+  // we can get the precursor origin.
+  const blink::WebSecurityOrigin web_frame_origin = frame->GetSecurityOrigin();
+  const url::Origin frame_origin = web_frame_origin;
+  const url::SchemeHostPort& tuple_or_precursor_tuple =
+      frame_origin.GetTupleOrPrecursorTupleIfOpaque();
+
+  // When there's no valid tuple (which can happen in the case of e.g. a
+  // browser-initiated navigation to an opaque URL), there's no origin to
+  // fallback to. Bail.
+  if (!tuple_or_precursor_tuple.IsValid())
+    return document_url;
+
+  const url::Origin origin_or_precursor_origin =
+      url::Origin::Create(tuple_or_precursor_tuple.GetURL());
+
+  if (!allow_inaccessible_parents &&
+      !web_frame_origin.CanAccess(
+          blink::WebSecurityOrigin(origin_or_precursor_origin))) {
+    // The frame can't access its precursor. Bail.
+    return document_url;
+  }
+
+  // Looks like the initiator origin is an appropriate fallback!
+
+  if (match_origin_as_fallback == MatchOriginAsFallbackBehavior::kAlways) {
+    // The easy case! We use the origin directly. We're done.
+    return origin_or_precursor_origin.GetURL();
+  }
+
+  DCHECK_EQ(MatchOriginAsFallbackBehavior::kMatchForAboutSchemeAndClimbTree,
+            match_origin_as_fallback);
+
+  // Unfortunately, in this case, we have to climb the frame tree. This is for
+  // match patterns that are associated with paths as well, not just origins.
+  // For instance, if an extension wants to run on google.com/maps/* with
+  // match_about_blank true, then it should run on about:-scheme frames created
+  // by google.com/maps, but not about:-scheme frames created by google.com
+  // (which is what the precursor tuple origin would be).
+
+  // Traverse the frame/window hierarchy to find the closest non-about:-page
+  // with the same origin as the precursor and return its URL.
+  // Note: This can return the incorrect result, e.g. if a parent frame
+  // navigates a grandchild frame.
+  blink::WebFrame* parent = frame;
+  GURL parent_url;
+  blink::WebDocument parent_document;
+  base::flat_set<blink::WebFrame*> already_visited_frames;
+  do {
+    already_visited_frames.insert(parent);
+    if (parent->Parent())
+      parent = parent->Parent();
+    else
+      parent = parent->Opener();
+
+    // Avoid an infinite loop - see https://crbug.com/568432 and
+    // https://crbug.com/883526.
+    if (base::Contains(already_visited_frames, parent))
+      return document_url;
+
+    parent_document = parent && parent->IsWebLocalFrame()
+                          ? parent->ToWebLocalFrame()->GetDocument()
+                          : blink::WebDocument();
+
+    // We reached the end of the ancestral chain without finding a valid parent,
+    // or found a remote web frame (in which case, it's a different origin).
+    // Bail and use the original URL.
+    if (parent_document.IsNull())
+      return document_url;
+
+    url::SchemeHostPort parent_tuple_or_precursor_tuple =
+        url::Origin(parent->GetSecurityOrigin())
+            .GetTupleOrPrecursorTupleIfOpaque();
+    if (!parent_tuple_or_precursor_tuple.IsValid() ||
+        parent_tuple_or_precursor_tuple != tuple_or_precursor_tuple) {
+      // The parent has a different tuple origin than frame; this could happen
+      // in edge cases where a parent navigates an iframe or popup of a child
+      // frame at a different origin. [1] In this case, bail, since we can't
+      // find a full URL (i.e., one including the path) with the same security
+      // origin to use for the frame in question.
+      // [1] Consider a frame tree like:
+      // <html> <!--example.com-->
+      //   <iframe id="a" src="a.com">
+      //     <iframe id="b" src="b.com"></iframe>
+      //   </iframe>
+      // </html>
+      // Frame "a" is cross-origin from the top-level frame, and so the
+      // example.com top-level frame can't directly access frame "b". However,
+      // it can navigate it through
+      // window.frames[0].frames[0].location.href = 'about:blank';
+      // In that case, the precursor origin tuple origin of frame "b" would be
+      // example.com, but the parent tuple origin is a.com.
+      // Note that usually, this would have bailed earlier with a remote frame,
+      // but it may not if we're at the process limit.
+      return document_url;
+    }
+
+    parent_url = GURL(parent_document.Url());
+  } while (parent_url.SchemeIs(url::kAboutScheme));
+
+  DCHECK(!parent_url.is_empty());
+  DCHECK(!parent_document.IsNull());
+
+  // We should know that the frame can access the parent document (unless we
+  // explicitly allow it not to), since it has the same tuple origin as the
+  // frame, and we checked the frame access above.
+  DCHECK(allow_inaccessible_parents ||
+         web_frame_origin.CanAccess(parent_document.GetSecurityOrigin()));
+  return parent_url;
+}
+
+// std::string GetContextTypeDescriptionString(Feature::Context context_type) {
+//   switch (context_type) {
+//     case Feature::UNSPECIFIED_CONTEXT:
+//       return "UNSPECIFIED";
+//     case Feature::BLESSED_EXTENSION_CONTEXT:
+//       return "BLESSED_EXTENSION";
+//     case Feature::UNBLESSED_EXTENSION_CONTEXT:
+//       return "UNBLESSED_EXTENSION";
+//     case Feature::CONTENT_SCRIPT_CONTEXT:
+//       return "CONTENT_SCRIPT";
+//     case Feature::WEB_PAGE_CONTEXT:
+//       return "WEB_PAGE";
+//     case Feature::BLESSED_WEB_PAGE_CONTEXT:
+//       return "BLESSED_WEB_PAGE";
+//     case Feature::WEBUI_CONTEXT:
+//       return "WEBUI";
+//     case Feature::WEBUI_UNTRUSTED_CONTEXT:
+//       return "WEBUI_UNTRUSTED";
+//     case Feature::LOCK_SCREEN_EXTENSION_CONTEXT:
+//       return "LOCK_SCREEN_EXTENSION";
+//   }
+//   NOTREACHED();
+//   return std::string();
+// }
+
+// static std::string ToStringOrDefault(v8::Isolate* isolate,
+//                                      const v8::Local<v8::String>& v8_string,
+//                                      const std::string& dflt) {
+//   if (v8_string.IsEmpty())
+//     return dflt;
+//   std::string ascii_value = *v8::String::Utf8Value(isolate, v8_string);
+//   return ascii_value.empty() ? dflt : ascii_value;
+// }
+
+using FrameToDocumentLoader =
+    base::flat_map<blink::WebLocalFrame*, blink::WebDocumentLoader*>;
+
+FrameToDocumentLoader& FrameDocumentLoaderMap() {
+  static base::NoDestructor<FrameToDocumentLoader> map;
+  return *map;
+}
+
+blink::WebDocumentLoader* CurrentDocumentLoader(
+    const blink::WebLocalFrame* frame) {
+  auto& map = FrameDocumentLoaderMap();
+  auto it = map.find(frame);
+  return it == map.end() ? frame->GetDocumentLoader() : it->second;
+}
+
+}  // namespace
+
+// ScriptContext::ScopedFrameDocumentLoader::ScopedFrameDocumentLoader(
+//     blink::WebLocalFrame* frame,
+//     blink::WebDocumentLoader* document_loader)
+//     : frame_(frame), document_loader_(document_loader) {
+//   auto& map = FrameDocumentLoaderMap();
+//   DCHECK(map.find(frame_) == map.end());
+//   map[frame_] = document_loader_;
+// }
+
+// ScriptContext::ScopedFrameDocumentLoader::~ScopedFrameDocumentLoader() {
+//   auto& map = FrameDocumentLoaderMap();
+//   DCHECK_EQ(document_loader_, map.find(frame_)->second);
+//   map.erase(frame_);
+// }
+
+// ScriptContext::ScriptContext(const v8::Local<v8::Context>& v8_context,
+//                              blink::WebLocalFrame* web_frame,
+//                              const Extension* extension,
+//                              Feature::Context context_type,
+//                              const Extension* effective_extension,
+//                              Feature::Context effective_context_type)
+//     : is_valid_(true),
+//       v8_context_(v8_context->GetIsolate(), v8_context),
+//       web_frame_(web_frame),
+//       extension_(extension),
+//       context_type_(context_type),
+//       effective_extension_(effective_extension),
+//       effective_context_type_(effective_context_type),
+//       context_id_(base::UnguessableToken::Create()),
+//       safe_builtins_(this),
+//       isolate_(v8_context->GetIsolate()),
+//       service_worker_version_id_(blink::mojom::kInvalidServiceWorkerVersionId) {
+//   VLOG(1) << "Created context:\n" << GetDebugString();
+//   v8_context_.AnnotateStrongRetainer("extensions::ScriptContext::v8_context_");
+//   if (web_frame_)
+//     url_ = GetAccessCheckedFrameURL(web_frame_);
+// }
+
+// ScriptContext::~ScriptContext() {
+//   VLOG(1) << "Destroyed context for extension\n"
+//           << "  extension id: " << GetExtensionID() << "\n"
+//           << "  effective extension id: "
+//           << (effective_extension_.get() ? effective_extension_->id() : "");
+//   CHECK(!is_valid_) << "ScriptContexts must be invalidated before destruction";
+// }
+
+// // static
+// bool ScriptContext::IsSandboxedPage(const GURL& url) {
+//   // TODO(kalman): This is checking the wrong thing. See comment in
+//   // HasAccessOrThrowError.
+//   if (url.SchemeIs(kExtensionScheme)) {
+//     const Extension* extension =
+//         RendererExtensionRegistry::Get()->GetByID(url.host());
+//     if (extension) {
+//       return SandboxedPageInfo::IsSandboxedPage(extension, url.path());
+//     }
+//   }
+//   return false;
+// }
+
+// void ScriptContext::SetModuleSystem(
+//     std::unique_ptr<ModuleSystem> module_system) {
+//   module_system_ = std::move(module_system);
+//   module_system_->Initialize();
+// }
+
+// void ScriptContext::Invalidate() {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   CHECK(is_valid_);
+//   is_valid_ = false;
+
+//   // TODO(kalman): Make ModuleSystem use AddInvalidationObserver.
+//   // Ownership graph is a bit weird here.
+//   if (module_system_)
+//     module_system_->Invalidate();
+
+//   // Swap |invalidate_observers_| to a local variable to clear it, and to make
+//   // sure it's not mutated as we iterate.
+//   std::vector<base::OnceClosure> observers;
+//   observers.swap(invalidate_observers_);
+//   for (base::OnceClosure& observer : observers) {
+//     std::move(observer).Run();
+//   }
+//   DCHECK(invalidate_observers_.empty())
+//       << "Invalidation observers cannot be added during invalidation";
+
+//   v8_context_.Reset();
+// }
+
+// void ScriptContext::AddInvalidationObserver(base::OnceClosure observer) {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   invalidate_observers_.push_back(std::move(observer));
+// }
+
+// const std::string& ScriptContext::GetExtensionID() const {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   return extension_.get() ? extension_->id() : base::EmptyString();
+// }
+
+// content::RenderFrame* ScriptContext::GetRenderFrame() const {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   if (web_frame_)
+//     return content::RenderFrame::FromWebFrame(web_frame_);
+//   return NULL;
+// }
+
+// void ScriptContext::SafeCallFunction(const v8::Local<v8::Function>& function,
+//                                      int argc,
+//                                      v8::Local<v8::Value> argv[]) {
+//   SafeCallFunction(function, argc, argv,
+//                    ScriptInjectionCallback::CompleteCallback());
+// }
+
+// void ScriptContext::SafeCallFunction(
+//     const v8::Local<v8::Function>& function,
+//     int argc,
+//     v8::Local<v8::Value> argv[],
+//     const ScriptInjectionCallback::CompleteCallback& callback) {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   v8::HandleScope handle_scope(isolate());
+//   v8::Context::Scope scope(v8_context());
+//   v8::MicrotasksScope microtasks(isolate(),
+//                                  v8::MicrotasksScope::kDoNotRunMicrotasks);
+//   v8::Local<v8::Object> global = v8_context()->Global();
+//   if (web_frame_) {
+//     ScriptInjectionCallback* wrapper_callback = nullptr;
+//     if (!callback.is_null()) {
+//       // ScriptInjectionCallback manages its own lifetime.
+//       wrapper_callback = new ScriptInjectionCallback(callback);
+//     }
+//     web_frame_->RequestExecuteV8Function(v8_context(), function, global, argc,
+//                                          argv, wrapper_callback);
+//   } else {
+//     v8::MaybeLocal<v8::Value> maybe_result =
+//         function->Call(v8_context(), global, argc, argv);
+//     v8::Local<v8::Value> result;
+//     if (!callback.is_null() && maybe_result.ToLocal(&result)) {
+//       std::vector<v8::Local<v8::Value>> results(1, result);
+//       callback.Run(results);
+//     }
+//   }
+// }
+
+// Feature::Availability ScriptContext::GetAvailability(
+//     const std::string& api_name) {
+//   return GetAvailability(api_name, CheckAliasStatus::ALLOWED);
+// }
+
+// Feature::Availability ScriptContext::GetAvailability(
+//     const std::string& api_name,
+//     CheckAliasStatus check_alias) {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   if (base::StartsWith(api_name, "test", base::CompareCase::SENSITIVE)) {
+//     bool allowed = base::CommandLine::ForCurrentProcess()->
+//                        HasSwitch(::switches::kTestType);
+//     Feature::AvailabilityResult result =
+//         allowed ? Feature::IS_AVAILABLE : Feature::MISSING_COMMAND_LINE_SWITCH;
+//     return Feature::Availability(result,
+//                                  allowed ? "" : "Only allowed in tests");
+//   }
+//   // Hack: Hosted apps should have the availability of messaging APIs based on
+//   // the URL of the page (which might have access depending on some extension
+//   // with externally_connectable), not whether the app has access to messaging
+//   // (which it won't).
+//   const Extension* extension = extension_.get();
+//   if (extension && extension->is_hosted_app() &&
+//       (api_name == "runtime.connect" || api_name == "runtime.sendMessage")) {
+//     extension = NULL;
+//   }
+//   return ExtensionAPI::GetSharedInstance()->IsAvailable(
+//       api_name, extension, context_type_, url(), check_alias);
+// }
+
+// std::string ScriptContext::GetContextTypeDescription() const {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   return GetContextTypeDescriptionString(context_type_);
+// }
+
+// std::string ScriptContext::GetEffectiveContextTypeDescription() const {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   return GetContextTypeDescriptionString(effective_context_type_);
+// }
+
+// const GURL& ScriptContext::service_worker_scope() const {
+//   DCHECK(IsForServiceWorker());
+//   return service_worker_scope_;
+// }
+
+// bool ScriptContext::IsForServiceWorker() const {
+//   return service_worker_version_id_ !=
+//          blink::mojom::kInvalidServiceWorkerVersionId;
+// }
+
+// bool ScriptContext::IsAnyFeatureAvailableToContext(
+//     const Feature& api,
+//     CheckAliasStatus check_alias) {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   // TODO(lazyboy): Decide what we should do for service workers, where
+//   // web_frame() is null.
+//   GURL url = web_frame() ? GetDocumentLoaderURLForFrame(web_frame()) : url_;
+//   return ExtensionAPI::GetSharedInstance()->IsAnyFeatureAvailableToContext(
+//       api, extension(), context_type(), url, check_alias);
+// }
+
+// static
+GURL ScriptContext::GetDocumentLoaderURLForFrame(
+    const blink::WebLocalFrame* frame) {
+  // Normally we would use frame->document().url() to determine the document's
+  // URL, but to decide whether to inject a content script, we use the URL from
+  // the data source. This "quirk" helps prevents content scripts from
+  // inadvertently adding DOM elements to the compose iframe in Gmail because
+  // the compose iframe's dataSource URL is about:blank, but the document URL
+  // changes to match the parent document after Gmail document.writes into
+  // it to create the editor.
+  // http://code.google.com/p/chromium/issues/detail?id=86742
+  blink::WebDocumentLoader* document_loader = CurrentDocumentLoader(frame);
+  return document_loader ? GURL(document_loader->GetUrl()) : GURL();
+}
+
+// // static
+// GURL ScriptContext::GetAccessCheckedFrameURL(
+//     const blink::WebLocalFrame* frame) {
+//   const blink::WebURL& weburl = frame->GetDocument().Url();
+//   if (weburl.IsEmpty()) {
+//     blink::WebDocumentLoader* document_loader = CurrentDocumentLoader(frame);
+//     if (document_loader &&
+//         frame->GetSecurityOrigin().CanAccess(
+//             blink::WebSecurityOrigin::Create(document_loader->GetUrl()))) {
+//       return GURL(document_loader->GetUrl());
+//     }
+//   }
+//   return GURL(weburl);
+// }
+
+// // static
+// GURL ScriptContext::GetEffectiveDocumentURLForContext(
+//     blink::WebLocalFrame* frame,
+//     const GURL& document_url,
+//     bool match_about_blank) {
+//   // Note: Do not allow matching inaccessible parent frames here; frames like
+//   // sandboxed frames should not inherit the privilege of their parents.
+//   constexpr bool allow_inaccessible_parents = false;
+//   // TODO(devlin): Determine if this could use kAlways instead of
+//   // kMatchForAboutSchemeAndClimbTree.
+//   auto match_origin_as_fallback =
+//       match_about_blank
+//           ? MatchOriginAsFallbackBehavior::kMatchForAboutSchemeAndClimbTree
+//           : MatchOriginAsFallbackBehavior::kNever;
+//   return GetEffectiveDocumentURL(frame, document_url, match_origin_as_fallback,
+//                                  allow_inaccessible_parents);
+// }
+
+// static
+GURL ScriptContext::GetEffectiveDocumentURLForInjection(
+    blink::WebLocalFrame* frame,
+    const GURL& document_url,
+    MatchOriginAsFallbackBehavior match_origin_as_fallback) {
+  // We explicitly allow inaccessible parents here. Extensions should still be
+  // able to inject into a sandboxed iframe if it has access to the embedding
+  // origin.
+  constexpr bool allow_inaccessible_parents = true;
+  return GetEffectiveDocumentURL(frame, document_url, match_origin_as_fallback,
+                                 allow_inaccessible_parents);
+}
+
+// // Grants a set of content capabilities to this context.
+
+// bool ScriptContext::HasAPIPermission(APIPermission::ID permission) const {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   if (effective_extension_.get()) {
+//     return effective_extension_->permissions_data()->HasAPIPermission(
+//         permission);
+//   }
+//   if (context_type() == Feature::WEB_PAGE_CONTEXT) {
+//     // Only web page contexts may be granted content capabilities. Other
+//     // contexts are either privileged WebUI or extensions with their own set of
+//     // permissions.
+//     if (content_capabilities_.find(permission) != content_capabilities_.end())
+//       return true;
+//   }
+//   return false;
+// }
+
+// bool ScriptContext::HasAccessOrThrowError(const std::string& name) {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   // Theoretically[1] we could end up with bindings being injected into
+//   // sandboxed frames, for example content scripts. Don't let them execute API
+//   // functions.
+//   //
+//   // In any case, this check is silly. The frame's document's security origin
+//   // already tells us if it's sandboxed. The only problem is that until
+//   // crbug.com/466373 is fixed, we don't know the security origin up-front and
+//   // may not know it here, either.
+//   //
+//   // [1] citation needed. This ScriptContext should already be in a state that
+//   // doesn't allow this, from ScriptContextSet::ClassifyJavaScriptContext.
+//   if (extension() &&
+//       SandboxedPageInfo::IsSandboxedPage(extension(), url_.path())) {
+//     static const char kMessage[] =
+//         "%s cannot be used within a sandboxed frame.";
+//     std::string error_msg = base::StringPrintf(kMessage, name.c_str());
+//     isolate()->ThrowException(v8::Exception::Error(
+//         v8::String::NewFromUtf8(isolate(), error_msg.c_str(),
+//                                 v8::NewStringType::kNormal)
+//             .ToLocalChecked()));
+//     return false;
+//   }
+
+//   Feature::Availability availability = GetAvailability(name);
+//   if (!availability.is_available()) {
+//     isolate()->ThrowException(v8::Exception::Error(
+//         v8::String::NewFromUtf8(isolate(), availability.message().c_str(),
+//                                 v8::NewStringType::kNormal)
+//             .ToLocalChecked()));
+//     return false;
+//   }
+
+//   return true;
+// }
+
+// std::string ScriptContext::GetDebugString() const {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   return base::StringPrintf(
+//       "  extension id:           %s\n"
+//       "  frame:                  %p\n"
+//       "  URL:                    %s\n"
+//       "  context_type:           %s\n"
+//       "  effective extension id: %s\n"
+//       "  effective context type: %s",
+//       extension_.get() ? extension_->id().c_str() : "(none)", web_frame_,
+//       url_.spec().c_str(), GetContextTypeDescription().c_str(),
+//       effective_extension_.get() ? effective_extension_->id().c_str()
+//                                  : "(none)",
+//       GetEffectiveContextTypeDescription().c_str());
+// }
+
+// std::string ScriptContext::GetStackTraceAsString() const {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   v8::Local<v8::StackTrace> stack_trace =
+//       v8::StackTrace::CurrentStackTrace(isolate(), 10);
+//   if (stack_trace.IsEmpty() || stack_trace->GetFrameCount() <= 0) {
+//     return "    <no stack trace>";
+//   }
+//   std::string result;
+//   for (int i = 0; i < stack_trace->GetFrameCount(); ++i) {
+//     v8::Local<v8::StackFrame> frame = stack_trace->GetFrame(isolate(), i);
+//     CHECK(!frame.IsEmpty());
+//     result += base::StringPrintf(
+//         "\n    at %s (%s:%d:%d)",
+//         ToStringOrDefault(isolate(), frame->GetFunctionName(), "<anonymous>")
+//             .c_str(),
+//         ToStringOrDefault(isolate(), frame->GetScriptName(), "<anonymous>")
+//             .c_str(),
+//         frame->GetLineNumber(), frame->GetColumn());
+//   }
+//   return result;
+// }
+
+// v8::Local<v8::Value> ScriptContext::RunScript(
+//     v8::Local<v8::String> name,
+//     v8::Local<v8::String> code,
+//     const RunScriptExceptionHandler& exception_handler,
+//     v8::ScriptCompiler::NoCacheReason no_cache_reason) {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   v8::EscapableHandleScope handle_scope(isolate());
+//   v8::Context::Scope context_scope(v8_context());
+
+//   // Prepend extensions:: to |name| so that internal code can be differentiated
+//   // from external code in stack traces. This has no effect on behaviour.
+//   std::string internal_name = base::StringPrintf(
+//       "extensions::%s", *v8::String::Utf8Value(isolate(), name));
+
+//   if (internal_name.size() >= v8::String::kMaxLength) {
+//     NOTREACHED() << "internal_name is too long.";
+//     return v8::Undefined(isolate());
+//   }
+
+//   v8::MicrotasksScope microtasks(
+//       isolate(), v8::MicrotasksScope::kDoNotRunMicrotasks);
+//   v8::TryCatch try_catch(isolate());
+//   try_catch.SetCaptureMessage(true);
+//   v8::ScriptOrigin origin(
+//       v8_helpers::ToV8StringUnsafe(isolate(), internal_name.c_str()));
+//   v8::ScriptCompiler::Source script_source(code, origin);
+//   v8::Local<v8::Script> script;
+//   if (!v8::ScriptCompiler::Compile(v8_context(), &script_source,
+//                                    v8::ScriptCompiler::kNoCompileOptions,
+//                                    no_cache_reason)
+//            .ToLocal(&script)) {
+//     exception_handler.Run(try_catch);
+//     return v8::Undefined(isolate());
+//   }
+
+//   v8::Local<v8::Value> result;
+//   if (!script->Run(v8_context()).ToLocal(&result)) {
+//     exception_handler.Run(try_catch);
+//     return v8::Undefined(isolate());
+//   }
+
+//   return handle_scope.Escape(result);
+// }
+
+// v8::Local<v8::Value> ScriptContext::CallFunction(
+//     const v8::Local<v8::Function>& function,
+//     int argc,
+//     v8::Local<v8::Value> argv[]) const {
+//   DCHECK(thread_checker_.CalledOnValidThread());
+//   v8::EscapableHandleScope handle_scope(isolate());
+//   v8::Context::Scope scope(v8_context());
+
+//   v8::MicrotasksScope microtasks(isolate(),
+//                                  v8::MicrotasksScope::kDoNotRunMicrotasks);
+//   if (!is_valid_) {
+//     return handle_scope.Escape(
+//         v8::Local<v8::Primitive>(v8::Undefined(isolate())));
+//   }
+
+//   v8::Local<v8::Object> global = v8_context()->Global();
+//   if (!web_frame_) {
+//     v8::MaybeLocal<v8::Value> maybe_result =
+//         function->Call(v8_context(), global, argc, argv);
+//     v8::Local<v8::Value> result;
+//     if (!maybe_result.ToLocal(&result)) {
+//       return handle_scope.Escape(
+//           v8::Local<v8::Primitive>(v8::Undefined(isolate())));
+//     }
+//     return handle_scope.Escape(result);
+//   }
+
+//   v8::MaybeLocal<v8::Value> result =
+//       web_frame_->CallFunctionEvenIfScriptDisabled(function, global, argc,
+//                                                    argv);
+
+//   // TODO(devlin): Stop coercing this to a v8::Local.
+//   v8::Local<v8::Value> coerced_result;
+//   ignore_result(result.ToLocal(&coerced_result));
+//   return handle_scope.Escape(coerced_result);
+// }
+
+}  // namespace extensions
diff --git a/components/user_scripts/content/renderer/script_context.h b/components/user_scripts/content/renderer/script_context.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/script_context.h
@@ -0,0 +1,332 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_SCRIPT_CONTEXT_H_
+#define EXTENSIONS_RENDERER_SCRIPT_CONTEXT_H_
+
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/callback.h"
+#include "base/compiler_specific.h"
+#include "base/macros.h"
+#include "base/threading/thread_checker.h"
+#include "base/unguessable_token.h"
+//#include "extensions/common/features/feature.h"
+//#include "extensions/common/permissions/api_permission_set.h"
+#include "../common/script_constants.h"
+//#include "extensions/renderer/module_system.h"
+//#include "extensions/renderer/safe_builtins.h"
+#include "script_injection_callback.h"
+#include "url/gurl.h"
+#include "v8/include/v8.h"
+
+namespace blink {
+class WebDocumentLoader;
+class WebLocalFrame;
+}
+
+namespace content {
+class RenderFrame;
+}
+
+namespace user_scripts {
+// enum class CheckAliasStatus;
+// class Extension;
+
+// Extensions wrapper for a v8::Context.
+//
+// v8::Contexts can be constructed on any thread, and must only be accessed or
+// destroyed that thread.
+//
+// Note that ScriptContexts bound to worker threads will not have the full
+// functionality as those bound to the main RenderThread.
+class ScriptContext {
+ public:
+  // using RunScriptExceptionHandler = base::Callback<void(const v8::TryCatch&)>;
+
+  // ScriptContext(const v8::Local<v8::Context>& context,
+  //               blink::WebLocalFrame* frame,
+  //               const Extension* extension,
+  //               Feature::Context context_type,
+  //               const Extension* effective_extension,
+  //               Feature::Context effective_context_type);
+  // ~ScriptContext();
+
+  // // Returns whether |url| from any Extension in |extension_set| is sandboxed,
+  // // as declared in each Extension's manifest.
+  // // TODO(kalman): Delete this when crbug.com/466373 is fixed.
+  // // See comment in HasAccessOrThrowError.
+  // static bool IsSandboxedPage(const GURL& url);
+
+  // // Initializes |module_system| and associates it with this context.
+  // void SetModuleSystem(std::unique_ptr<ModuleSystem> module_system);
+
+  // // Clears the WebLocalFrame for this contexts and invalidates the associated
+  // // ModuleSystem.
+  // void Invalidate();
+
+  // // Registers |observer| to be run when this context is invalidated. Closures
+  // // are run immediately when Invalidate() is called, not in a message loop.
+  // void AddInvalidationObserver(base::OnceClosure observer);
+
+  // // Returns true if this context is still valid, false if it isn't.
+  // // A context becomes invalid via Invalidate().
+  // bool is_valid() const { return is_valid_; }
+
+  // v8::Local<v8::Context> v8_context() const {
+  //   return v8::Local<v8::Context>::New(isolate_, v8_context_);
+  // }
+
+  // const Extension* extension() const { return extension_.get(); }
+
+  // const Extension* effective_extension() const {
+  //   return effective_extension_.get();
+  // }
+
+  // blink::WebLocalFrame* web_frame() const { return web_frame_; }
+
+  // Feature::Context context_type() const { return context_type_; }
+
+  // Feature::Context effective_context_type() const {
+  //   return effective_context_type_;
+  // }
+
+  // const base::UnguessableToken& context_id() const { return context_id_; }
+
+  // ModuleSystem* module_system() { return module_system_.get(); }
+
+  // SafeBuiltins* safe_builtins() { return &safe_builtins_; }
+
+  // const SafeBuiltins* safe_builtins() const { return &safe_builtins_; }
+
+  // // Returns the ID of the extension associated with this context, or empty
+  // // string if there is no such extension.
+  // const std::string& GetExtensionID() const;
+
+  // // Returns the RenderFrame associated with this context. Can return NULL if
+  // // the context is in the process of being destroyed.
+  // content::RenderFrame* GetRenderFrame() const;
+
+  // // Safely calls the v8::Function, respecting the page load deferrer and
+  // // possibly executing asynchronously.
+  // // Doesn't catch exceptions; callers must do that if they want.
+  // // USE THESE METHODS RATHER THAN v8::Function::Call WHEREVER POSSIBLE.
+  // void SafeCallFunction(const v8::Local<v8::Function>& function,
+  //                       int argc,
+  //                       v8::Local<v8::Value> argv[]);
+  // void SafeCallFunction(
+  //     const v8::Local<v8::Function>& function,
+  //     int argc,
+  //     v8::Local<v8::Value> argv[],
+  //     const ScriptInjectionCallback::CompleteCallback& callback);
+
+  // // Returns the availability of the API |api_name|.
+  // Feature::Availability GetAvailability(const std::string& api_name);
+  // // Returns the availability of the API |api_name|.
+  // // |check_alias| Whether API that has an alias that is available should be
+  // // considered available (even if the API itself is not available).
+  // Feature::Availability GetAvailability(const std::string& api_name,
+  //                                       CheckAliasStatus check_alias);
+
+  // // Returns a string description of the type of context this is.
+  // std::string GetContextTypeDescription() const;
+
+  // // Returns a string description of the effective type of context this is.
+  // std::string GetEffectiveContextTypeDescription() const;
+
+  // v8::Isolate* isolate() const { return isolate_; }
+
+  // // Get the URL of this context's web frame.
+  // //
+  // // TODO(kalman): Remove this and replace with a GetOrigin() call which reads
+  // // of WebDocument::getSecurityOrigin():
+  // //  - The URL can change (e.g. pushState) but the origin cannot. Luckily it
+  // //    appears as though callers don't make security decisions based on the
+  // //    result of url() so it's not a problem... yet.
+  // //  - Origin is the correct check to be making.
+  // //  - It might let us remove the about:blank resolving?
+  // const GURL& url() const { return url_; }
+
+  // const GURL& service_worker_scope() const;
+
+  // int64_t service_worker_version_id() const {
+  //   return service_worker_version_id_;
+  // }
+
+  // bool IsForServiceWorker() const;
+
+  // // Sets the URL of this ScriptContext. Usually this will automatically be set
+  // // on construction, unless this isn't constructed with enough information to
+  // // determine the URL (e.g. frame was null).
+  // // TODO(kalman): Make this a constructor parameter (as an origin).
+  // void set_url(const GURL& url) { url_ = url; }
+  // void set_service_worker_scope(const GURL& scope) {
+  //   service_worker_scope_ = scope;
+  // }
+  // void set_service_worker_version_id(int64_t service_worker_version_id) {
+  //   service_worker_version_id_ = service_worker_version_id;
+  // }
+
+  // // Returns whether the API |api| or any part of the API could be available in
+  // // this context without taking into account the context's extension.
+  // // |check_alias| Whether the API should be considered available if it has an
+  // // alias that is available.
+  // bool IsAnyFeatureAvailableToContext(const extensions::Feature& api,
+  //                                     CheckAliasStatus check_alias);
+
+  // // Scope which maps a frame to a document loader. This is used by various
+  // // static methods below, which need to account for "just about to load"
+  // // document when retrieving URL.
+  // class ScopedFrameDocumentLoader {
+  //  public:
+  //   ScopedFrameDocumentLoader(blink::WebLocalFrame* frame,
+  //                             blink::WebDocumentLoader* document_loader);
+  //   ~ScopedFrameDocumentLoader();
+
+  //  private:
+  //   blink::WebLocalFrame* frame_;
+  //   blink::WebDocumentLoader* document_loader_;
+  //   DISALLOW_COPY_AND_ASSIGN(ScopedFrameDocumentLoader);
+  // };
+
+  // TODO(devlin): Move all these Get*URL*() methods out of here? While they are
+  // vaguely ScriptContext related, there's enough here that they probably
+  // warrant another class or utility file.
+
+  // Utility to get the URL we will match against for a frame. If the frame has
+  // committed, this is the commited URL. Otherwise it is the provisional URL.
+  // The returned URL may be invalid.
+  static GURL GetDocumentLoaderURLForFrame(const blink::WebLocalFrame* frame);
+
+//   // Similar to GetDocumentLoaderURLForFrame, but only returns the data source
+//   // URL if the frame's document url is empty and the frame has a security
+//   // origin that allows access to the data source url.
+//   // TODO(asargent/devlin) - there may be places that should switch to using
+//   // this instead of GetDocumentLoaderURLForFrame.
+//   static GURL GetAccessCheckedFrameURL(const blink::WebLocalFrame* frame);
+
+//   // Used to determine the "effective" URL in context classification, such as to
+//   // associate an about:blank frame in an extension context with its extension.
+//   // If |document_url| is an about: or data: URL, returns the URL of the first
+//   // frame without an about: or data: URL that matches the initiator origin.
+//   // This may not be the immediate parent. Returns |document_url| if it is not
+//   // an about: URL, if |match_about_blank| is false, or if a suitable parent
+//   // cannot be found.
+//   // Will not check parent contexts that cannot be accessed (as is the case
+//   // for sandboxed frames).
+//   static GURL GetEffectiveDocumentURLForContext(blink::WebLocalFrame* frame,
+//                                                 const GURL& document_url,
+//                                                 bool match_about_blank);
+
+  // Used to determine the "effective" URL for extension script injection.
+  // If |document_url| is an about: or data: URL, returns the URL of the first
+  // frame without an about: or data: URL that matches the initiator origin.
+  // This may not be the immediate parent. Returns |document_url| if it is not
+  // an about: or data: URL, if |match_origin_as_fallback| is set to not match,
+  // or if a suitable parent cannot be found.
+  // Considers parent contexts that cannot be accessed (as is the case for
+  // sandboxed frames).
+  static GURL GetEffectiveDocumentURLForInjection(
+      blink::WebLocalFrame* frame,
+      const GURL& document_url,
+      MatchOriginAsFallbackBehavior match_origin_as_fallback);
+
+//   // Grants a set of content capabilities to this context.
+//   void set_content_capabilities(APIPermissionSet capabilities) {
+//     content_capabilities_ = std::move(capabilities);
+//   }
+
+//   // Indicates if this context has an effective API permission either by being
+//   // a context for an extension which has that permission, or by being a web
+//   // context which has been granted the corresponding capability by an
+//   // extension.
+//   bool HasAPIPermission(APIPermission::ID permission) const;
+
+//   // Throws an Error in this context's JavaScript context, if this context does
+//   // not have access to |name|. Returns true if this context has access (i.e.
+//   // no exception thrown), false if it does not (i.e. an exception was thrown).
+//   bool HasAccessOrThrowError(const std::string& name);
+
+//   // Returns a string representation of this ScriptContext, for debugging.
+//   std::string GetDebugString() const;
+
+//   // Gets the current stack trace as a multi-line string to be logged.
+//   std::string GetStackTraceAsString() const;
+
+//   // Runs |code|, labelling the script that gets created as |name| (the name is
+//   // used in the devtools and stack traces). |exception_handler| will be called
+//   // re-entrantly if an exception is thrown during the script's execution.
+//   v8::Local<v8::Value> RunScript(
+//       v8::Local<v8::String> name,
+//       v8::Local<v8::String> code,
+//       const RunScriptExceptionHandler& exception_handler,
+//       v8::ScriptCompiler::NoCacheReason no_cache_reason =
+//           v8::ScriptCompiler::NoCacheReason::kNoCacheNoReason);
+
+//  private:
+//   // DEPRECATED.
+//   v8::Local<v8::Value> CallFunction(const v8::Local<v8::Function>& function,
+//                                     int argc,
+//                                     v8::Local<v8::Value> argv[]) const;
+
+//   // Whether this context is valid.
+//   bool is_valid_;
+
+//   // The v8 context the bindings are accessible to.
+//   v8::Global<v8::Context> v8_context_;
+
+//   // The WebLocalFrame associated with this context. This can be NULL because
+//   // this object can outlive is destroyed asynchronously.
+//   blink::WebLocalFrame* web_frame_;
+
+//   // The extension associated with this context, or NULL if there is none. This
+//   // might be a hosted app in the case that this context is hosting a web URL.
+//   scoped_refptr<const Extension> extension_;
+
+//   // The type of context.
+//   Feature::Context context_type_;
+
+//   // The effective extension associated with this context, or NULL if there is
+//   // none. This is different from the above extension if this context is in an
+//   // about:blank iframe for example.
+//   scoped_refptr<const Extension> effective_extension_;
+
+//   // The type of context.
+//   Feature::Context effective_context_type_;
+
+//   // A globally-unique ID for the script context.
+//   base::UnguessableToken context_id_;
+
+//   // Owns and structures the JS that is injected to set up extension bindings.
+//   std::unique_ptr<ModuleSystem> module_system_;
+
+//   // Contains safe copies of builtin objects like Function.prototype.
+//   SafeBuiltins safe_builtins_;
+
+//   // The set of capabilities granted to this context by extensions.
+//   APIPermissionSet content_capabilities_;
+
+//   // A list of base::OnceClosure instances as an observer interface for
+//   // invalidation.
+//   std::vector<base::OnceClosure> invalidate_observers_;
+
+//   v8::Isolate* isolate_;
+
+//   GURL url_;
+
+//   GURL service_worker_scope_;
+
+//   int64_t service_worker_version_id_;
+
+//   base::ThreadChecker thread_checker_;
+
+//   DISALLOW_COPY_AND_ASSIGN(ScriptContext);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_SCRIPT_CONTEXT_H_
diff --git a/components/user_scripts/content/renderer/script_injection.cc b/components/user_scripts/content/renderer/script_injection.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/script_injection.cc
@@ -0,0 +1,412 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "script_injection.h"
+
+#include <map>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/feature_list.h"
+#include "base/lazy_instance.h"
+#include "base/macros.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/timer/elapsed_timer.h"
+#include "base/values.h"
+#include "base/logging.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/renderer/render_frame_observer.h"
+#include "content/public/renderer/v8_value_converter.h"
+//#include "extensions/common/extension_features.h"
+//#include "extensions/common/extension_messages.h"
+#include "../common/host_id.h"
+//#include "extensions/common/identifiability_metrics.h"
+//#include "extensions/renderer/dom_activity_logger.h"
+//#include "extensions/renderer/extension_frame_helper.h"
+//#include "extensions/renderer/extensions_renderer_client.h"
+#include "script_injection_callback.h"
+#include "scripts_run_info.h"
+#include "third_party/blink/public/platform/web_isolated_world_info.h"
+#include "third_party/blink/public/platform/web_security_origin.h"
+#include "third_party/blink/public/platform/web_string.h"
+#include "third_party/blink/public/web/web_document.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "third_party/blink/public/web/web_script_source.h"
+#include "url/gurl.h"
+
+namespace user_scripts {
+
+namespace {
+
+using IsolatedWorldMap = std::map<std::string, int>;
+base::LazyInstance<IsolatedWorldMap>::DestructorAtExit g_isolated_worlds =
+    LAZY_INSTANCE_INITIALIZER;
+
+const int64_t kInvalidRequestId = -1;
+
+// The id of the next pending injection.
+//int64_t g_next_pending_id = 0;
+
+// Gets the isolated world ID to use for the given |injection_host|. If no
+// isolated world has been created for that |injection_host| one will be created
+// and initialized.
+int GetIsolatedWorldIdForInstance(const InjectionHost* injection_host) {
+  static int g_next_isolated_world_id = 1; // Embedder isolated worlds can use IDs in [1, 1<<29).
+      //ExtensionsRendererClient::Get()->GetLowestIsolatedWorldId(); aka ChromeIsolatedWorldIDs.ISOLATED_WORLD_ID_EXTENSIONS
+
+  IsolatedWorldMap& isolated_worlds = g_isolated_worlds.Get();
+
+  int id = 0;
+  const std::string& key = injection_host->id().id();
+  auto iter = isolated_worlds.find(key);
+  if (iter != isolated_worlds.end()) {
+    id = iter->second;
+  } else {
+    id = g_next_isolated_world_id++;
+    // This map will tend to pile up over time, but realistically, you're never
+    // going to have enough injection hosts for it to matter.
+    isolated_worlds[key] = id;
+  }
+
+  blink::WebIsolatedWorldInfo info;
+  info.security_origin =
+      blink::WebSecurityOrigin::Create(injection_host->url());
+  info.human_readable_name = blink::WebString::FromUTF8(injection_host->name());
+  info.stable_id = blink::WebString::FromUTF8(key);
+
+  const std::string* csp = injection_host->GetContentSecurityPolicy();
+  if (csp)
+    info.content_security_policy = blink::WebString::FromUTF8(*csp);
+
+  // Even though there may be an existing world for this |injection_host|'s key,
+  // the properties may have changed (e.g. due to an extension update).
+  // Overwrite any existing entries.
+  blink::SetIsolatedWorldInfo(id, info);
+
+  return id;
+}
+
+// This class manages its own lifetime.
+class TimedScriptInjectionCallback : public ScriptInjectionCallback {
+ public:
+  TimedScriptInjectionCallback(base::WeakPtr<ScriptInjection> injection)
+      : ScriptInjectionCallback(
+            base::Bind(&TimedScriptInjectionCallback::OnCompleted,
+                       base::Unretained(this))),
+        injection_(injection) {}
+  ~TimedScriptInjectionCallback() override {}
+
+  void OnCompleted(const std::vector<v8::Local<v8::Value>>& result) {
+    if (injection_) {
+      base::TimeTicks timestamp(base::TimeTicks::Now());
+      base::Optional<base::TimeDelta> elapsed;
+      // If the script will never execute (such as if the context is destroyed),
+      // willExecute() will not be called, but OnCompleted() will. Only log a
+      // time for execution if the script, in fact, executed.
+      if (!start_time_.is_null())
+        elapsed = timestamp - start_time_;
+      injection_->OnJsInjectionCompleted(result, elapsed);
+    }
+  }
+
+  void WillExecute() override {
+    start_time_ = base::TimeTicks::Now();
+  }
+
+ private:
+  base::WeakPtr<ScriptInjection> injection_;
+  base::TimeTicks start_time_;
+};
+
+}  // namespace
+
+// Watches for the deletion of a RenderFrame, after which is_valid will return
+// false.
+class ScriptInjection::FrameWatcher : public content::RenderFrameObserver {
+ public:
+  FrameWatcher(content::RenderFrame* render_frame,
+               ScriptInjection* injection)
+      : content::RenderFrameObserver(render_frame),
+        injection_(injection) {}
+  ~FrameWatcher() override {}
+
+ private:
+  void WillDetach() override { injection_->invalidate_render_frame(); }
+  void OnDestruct() override { injection_->invalidate_render_frame(); }
+
+  ScriptInjection* injection_;
+
+  DISALLOW_COPY_AND_ASSIGN(FrameWatcher);
+};
+
+// static
+std::string ScriptInjection::GetHostIdForIsolatedWorld(int isolated_world_id) {
+  const IsolatedWorldMap& isolated_worlds = g_isolated_worlds.Get();
+
+  for (const auto& iter : isolated_worlds) {
+    if (iter.second == isolated_world_id)
+      return iter.first;
+  }
+  return std::string();
+}
+
+// static
+void ScriptInjection::RemoveIsolatedWorld(const std::string& host_id) {
+  g_isolated_worlds.Get().erase(host_id);
+}
+
+ScriptInjection::ScriptInjection(
+    std::unique_ptr<ScriptInjector> injector,
+    content::RenderFrame* render_frame,
+    std::unique_ptr<const InjectionHost> injection_host,
+    UserScript::RunLocation run_location,
+    bool log_activity)
+    : injector_(std::move(injector)),
+      render_frame_(render_frame),
+      injection_host_(std::move(injection_host)),
+      run_location_(run_location),
+      request_id_(kInvalidRequestId),
+      ukm_source_id_(base::UkmSourceId::FromInt64(
+          render_frame_->GetWebFrame()->GetDocument().GetUkmSourceId())),
+      complete_(false),
+      did_inject_js_(false),
+      log_activity_(log_activity),
+      frame_watcher_(new FrameWatcher(render_frame, this)) {
+  CHECK(injection_host_.get());
+}
+
+ScriptInjection::~ScriptInjection() {
+  if (!complete_)
+    NotifyWillNotInject(ScriptInjector::WONT_INJECT);
+}
+
+ScriptInjection::InjectionResult ScriptInjection::TryToInject(
+    UserScript::RunLocation current_location,
+    ScriptsRunInfo* scripts_run_info,
+    const CompletionCallback& async_completion_callback) {
+  if (current_location < run_location_)
+    return INJECTION_WAITING;  // Wait for the right location.
+
+  if (request_id_ != kInvalidRequestId) {
+    // We're waiting for permission right now, try again later.
+    return INJECTION_WAITING;
+  }
+
+  if (!injection_host_) {
+    NotifyWillNotInject(ScriptInjector::EXTENSION_REMOVED);
+    return INJECTION_FINISHED;  // We're done.
+  }
+
+  //blink::WebLocalFrame* web_frame = render_frame_->GetWebFrame();
+  // switch (injector_->CanExecuteOnFrame(
+  //     injection_host_.get(), web_frame,
+  //     ExtensionFrameHelper::Get(render_frame_)->tab_id())) {
+  //   case PermissionsData::PageAccess::kDenied:
+  //     NotifyWillNotInject(ScriptInjector::NOT_ALLOWED);
+  //     return INJECTION_FINISHED;  // We're done.
+  //   case PermissionsData::PageAccess::kWithheld:
+  //     RequestPermissionFromBrowser();
+  //     return INJECTION_WAITING;  // Wait around for permission.
+  //   case PermissionsData::PageAccess::kAllowed:
+      InjectionResult result = Inject(scripts_run_info);
+      // If the injection is blocked, we need to set the manager so we can
+      // notify it upon completion.
+      if (result == INJECTION_BLOCKED)
+        async_completion_callback_ = async_completion_callback;
+      return result;
+  //}
+
+  //NOTREACHED();
+  //return INJECTION_FINISHED;
+}
+
+ScriptInjection::InjectionResult ScriptInjection::OnPermissionGranted(
+    ScriptsRunInfo* scripts_run_info) {
+  if (!injection_host_) {
+    NotifyWillNotInject(ScriptInjector::EXTENSION_REMOVED);
+    return INJECTION_FINISHED;
+  }
+
+  return Inject(scripts_run_info);
+}
+
+void ScriptInjection::OnHostRemoved() {
+  injection_host_.reset(nullptr);
+}
+
+// void ScriptInjection::RequestPermissionFromBrowser() {
+//   // If we are just notifying the browser of the injection, then send an
+//   // invalid request (which is treated like a notification).
+//   request_id_ = g_next_pending_id++;
+//   render_frame_->Send(new ExtensionHostMsg_RequestScriptInjectionPermission(
+//       render_frame_->GetRoutingID(), host_id().id(), injector_->script_type(),
+//       run_location_, request_id_));
+// }
+
+void ScriptInjection::NotifyWillNotInject(
+    ScriptInjector::InjectFailureReason reason) {
+  complete_ = true;
+  injector_->OnWillNotInject(reason, render_frame_);
+}
+
+ScriptInjection::InjectionResult ScriptInjection::Inject(
+    ScriptsRunInfo* scripts_run_info) {
+  DCHECK(injection_host_);
+  //DCHECK(scripts_run_info);
+  DCHECK(!complete_);
+  bool should_inject_js = injector_->ShouldInjectJs(
+      run_location_, scripts_run_info->executing_scripts[host_id().id()]);
+  bool should_inject_css = injector_->ShouldInjectCss(
+      run_location_, scripts_run_info->injected_stylesheets[host_id().id()]);
+
+  // This can happen if the extension specified a script to
+  // be run in multiple rules, and the script has already run.
+  // See crbug.com/631247.
+  if (!should_inject_js && !should_inject_css) {
+    return INJECTION_FINISHED;
+  }
+
+  if (should_inject_js)
+    InjectJs(&(scripts_run_info->executing_scripts[host_id().id()]),
+             &(scripts_run_info->num_js));
+  if (should_inject_css)
+    InjectCss(&(scripts_run_info->injected_stylesheets[host_id().id()]),
+              &(scripts_run_info->num_css));
+
+  complete_ = did_inject_js_ || !should_inject_js;
+
+  if (complete_) {
+    LOG(INFO) << "---ScriptInjection::Inject complete";
+//    if (host_id().type() == HostID::EXTENSIONS)
+//      RecordContentScriptInjection(ukm_source_id_, host_id().id());
+    injector_->OnInjectionComplete(std::move(execution_result_), run_location_,
+                                   render_frame_);
+  } else {
+    LOG(INFO) << "---ScriptInjection::Inject INcomplete";
+    ++scripts_run_info->num_blocking_js;
+  }
+
+  return complete_ ? INJECTION_FINISHED : INJECTION_BLOCKED;
+}
+
+void ScriptInjection::InjectJs(std::set<std::string>* executing_scripts,
+                               size_t* num_injected_js_scripts) {
+  LOG(INFO) << "---ScriptInjection::InjectJs";
+  DCHECK(!did_inject_js_);
+  std::vector<blink::WebScriptSource> sources = injector_->GetJsSources(
+      run_location_, executing_scripts, num_injected_js_scripts);
+  DCHECK(!sources.empty());
+  int world_id = GetIsolatedWorldIdForInstance(injection_host_.get());
+  bool is_user_gesture = injector_->IsUserGesture();
+
+  std::unique_ptr<blink::WebScriptExecutionCallback> callback(
+      new TimedScriptInjectionCallback(weak_ptr_factory_.GetWeakPtr()));
+
+  base::ElapsedTimer exec_timer;
+//  if (injection_host_->id().type() == HostID::EXTENSIONS && log_activity_)
+//    DOMActivityLogger::AttachToWorld(world_id, injection_host_->id().id());
+
+  // For content scripts executing during page load, we run them asynchronously
+  // in order to reduce UI jank experienced by the user. (We don't do this for
+  // DOCUMENT_START scripts, because there's no UI to jank until after those
+  // run, so we run them as soon as we can.)
+  // Note: We could potentially also run deferred and browser-driven scripts
+  // asynchronously; however, these are rare enough that there probably isn't
+  // UI jank. If this changes, we can update this.
+  bool should_execute_asynchronously =
+      injector_->script_type() == UserScript::CONTENT_SCRIPT &&
+      (run_location_ == UserScript::DOCUMENT_END ||
+       run_location_ == UserScript::DOCUMENT_IDLE);
+  blink::WebLocalFrame::ScriptExecutionType execution_option =
+      should_execute_asynchronously
+          ? blink::WebLocalFrame::kAsynchronousBlockingOnload
+          : blink::WebLocalFrame::kSynchronous;
+
+  // render_frame_->GetWebFrame()->RequestExecuteScriptAndReturnValue(
+  //      sources.front(), is_user_gesture, callback.release());
+  render_frame_->GetWebFrame()->RequestExecuteScriptInIsolatedWorld(
+      world_id, &sources.front(), sources.size(), is_user_gesture,
+      execution_option, callback.release());
+  LOG(INFO) << "---ScriptInjection::InjectJs end " << world_id;
+}
+
+void ScriptInjection::OnJsInjectionCompleted(
+    const std::vector<v8::Local<v8::Value>>& results,
+    base::Optional<base::TimeDelta> elapsed) {
+  LOG(INFO) << "---ScriptInjection::OnJsInjectionCompleted end";
+  DCHECK(!did_inject_js_);
+
+  // if (injection_host_->id().type() == HostID::EXTENSIONS && elapsed) {
+  //   UMA_HISTOGRAM_TIMES("Extensions.InjectedScriptExecutionTime", *elapsed);
+  //   switch (run_location_) {
+  //     case UserScript::DOCUMENT_START:
+  //       UMA_HISTOGRAM_TIMES(
+  //           "Extensions.InjectedScriptExecutionTime.DocumentStart", *elapsed);
+  //       break;
+  //     case UserScript::DOCUMENT_END:
+  //       UMA_HISTOGRAM_TIMES(
+  //           "Extensions.InjectedScriptExecutionTime.DocumentEnd", *elapsed);
+  //       break;
+  //     case UserScript::DOCUMENT_IDLE:
+  //       UMA_HISTOGRAM_TIMES(
+  //           "Extensions.InjectedScriptExecutionTime.DocumentIdle", *elapsed);
+  //       break;
+  //     default:
+  //       break;
+  //   }
+  // }
+
+  bool expects_results = injector_->ExpectsResults();
+  if (expects_results) {
+    if (!results.empty() && !results[0].IsEmpty()) {
+      // Right now, we only support returning single results (per frame).
+      // It's safe to always use the main world context when converting
+      // here. V8ValueConverterImpl shouldn't actually care about the
+      // context scope, and it switches to v8::Object's creation context
+      // when encountered.
+      v8::Local<v8::Context> context =
+          render_frame_->GetWebFrame()->MainWorldScriptContext();
+      execution_result_ =
+          content::V8ValueConverter::Create()->FromV8Value(results[0], context);
+    }
+    if (!execution_result_.get())
+      execution_result_ = std::make_unique<base::Value>();
+  }
+  did_inject_js_ = true;
+//  if (host_id().type() == HostID::EXTENSIONS)
+//    RecordContentScriptInjection(ukm_source_id_, host_id().id());
+
+  // If |async_completion_callback_| is set, it means the script finished
+  // asynchronously, and we should run it.
+  if (!async_completion_callback_.is_null()) {
+    complete_ = true;
+    injector_->OnInjectionComplete(std::move(execution_result_), run_location_,
+                                   render_frame_);
+    // Warning: this object can be destroyed after this line!
+    async_completion_callback_.Run(this);
+  }
+  LOG(INFO) << "---ScriptInjection::OnJsInjectionCompleted end "<< execution_result_;
+}
+
+void ScriptInjection::InjectCss(std::set<std::string>* injected_stylesheets,
+                                size_t* num_injected_stylesheets) {
+  std::vector<blink::WebString> css_sources = injector_->GetCssSources(
+      run_location_, injected_stylesheets, num_injected_stylesheets);
+  blink::WebLocalFrame* web_frame = render_frame_->GetWebFrame();
+  // Default CSS origin is "author", but can be overridden to "user" by scripts.
+  base::Optional<CSSOrigin> css_origin = injector_->GetCssOrigin();
+  blink::WebDocument::CSSOrigin blink_css_origin =
+      css_origin && *css_origin == CSS_ORIGIN_USER
+          ? blink::WebDocument::kUserOrigin
+          : blink::WebDocument::kAuthorOrigin;
+  blink::WebStyleSheetKey style_sheet_key;
+  if (const base::Optional<std::string>& injection_key =
+          injector_->GetInjectionKey())
+    style_sheet_key = blink::WebString::FromASCII(*injection_key);
+  for (const blink::WebString& css : css_sources)
+    web_frame->GetDocument().InsertStyleSheet(css, &style_sheet_key,
+                                              blink_css_origin);
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/content/renderer/script_injection.h b/components/user_scripts/content/renderer/script_injection.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/script_injection.h
@@ -0,0 +1,160 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_SCRIPT_INJECTION_H_
+#define EXTENSIONS_RENDERER_SCRIPT_INJECTION_H_
+
+#include <stdint.h>
+
+#include <memory>
+#include <vector>
+
+#include "base/callback.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "base/metrics/ukm_source_id.h"
+#include "base/optional.h"
+#include "../common/user_script.h"
+#include "injection_host.h"
+#include "script_injector.h"
+
+struct HostID;
+
+namespace content {
+class RenderFrame;
+}
+
+namespace v8 {
+class Value;
+template <class T> class Local;
+}
+
+namespace user_scripts {
+struct ScriptsRunInfo;
+
+// A script wrapper which is aware of whether or not it is allowed to execute,
+// and contains the implementation to do so.
+class ScriptInjection {
+ public:
+  enum InjectionResult {
+    INJECTION_FINISHED,
+    INJECTION_BLOCKED,
+    INJECTION_WAITING
+  };
+
+  using CompletionCallback = base::Callback<void(ScriptInjection*)>;
+
+  // Return the id of the injection host associated with the given world.
+  static std::string GetHostIdForIsolatedWorld(int world_id);
+
+  // Remove the isolated world associated with the given injection host.
+  static void RemoveIsolatedWorld(const std::string& host_id);
+
+  ScriptInjection(std::unique_ptr<ScriptInjector> injector,
+                  content::RenderFrame* render_frame,
+                  std::unique_ptr<const InjectionHost> injection_host,
+                  UserScript::RunLocation run_location,
+                  bool log_activity);
+  ~ScriptInjection();
+
+  // Try to inject the script at the |current_location|. This returns
+  // INJECTION_FINISHED if injection has injected or will never inject, returns
+  // INJECTION_BLOCKED if injection is running asynchronously and has not
+  // finished yet, returns INJECTION_WAITING if injections is delayed (either
+  // for permission purposes or because |current_location| is not the designated
+  // |run_location_|).
+  // If INJECTION_BLOCKED is returned, |async_completion_callback| will be
+  // called upon completion.
+  InjectionResult TryToInject(
+      UserScript::RunLocation current_location,
+      ScriptsRunInfo* scripts_run_info,
+      const CompletionCallback& async_completion_callback);
+
+  // Called when permission for the given injection has been granted.
+  // Returns INJECTION_FINISHED if injection has injected or will never inject,
+  // returns INJECTION_BLOCKED if injection is ran asynchronously.
+  InjectionResult OnPermissionGranted(ScriptsRunInfo* scripts_run_info);
+
+  // Resets the pointer of the injection host when the host is gone.
+  void OnHostRemoved();
+
+  void invalidate_render_frame() { render_frame_ = nullptr; }
+
+  // Accessors.
+  content::RenderFrame* render_frame() const { return render_frame_; }
+  const HostID& host_id() const { return injection_host_->id(); }
+  int64_t request_id() const { return request_id_; }
+
+  // Called when JS injection for the given frame has been completed or
+  // cancelled.
+  void OnJsInjectionCompleted(const std::vector<v8::Local<v8::Value>>& results,
+                              base::Optional<base::TimeDelta> elapsed);
+
+ private:
+  class FrameWatcher;
+
+  // Sends a message to the browser to request permission to inject.
+  void RequestPermissionFromBrowser();
+
+  // Injects the script. Returns INJECTION_FINISHED if injection has finished,
+  // otherwise INJECTION_BLOCKED.
+  InjectionResult Inject(ScriptsRunInfo* scripts_run_info);
+
+  // Inject any JS scripts into the frame for the injection.
+  void InjectJs(std::set<std::string>* executing_scripts,
+                size_t* num_injected_js_scripts);
+
+  // Inject any CSS source into the frame for the injection.
+  void InjectCss(std::set<std::string>* injected_stylesheets,
+                 size_t* num_injected_stylesheets);
+
+  // Notify that we will not inject, and mark it as acknowledged.
+  void NotifyWillNotInject(ScriptInjector::InjectFailureReason reason);
+
+  // The injector for this injection.
+  std::unique_ptr<ScriptInjector> injector_;
+
+  // The RenderFrame into which this should inject the script.
+  content::RenderFrame* render_frame_;
+
+  // The associated injection host.
+  std::unique_ptr<const InjectionHost> injection_host_;
+
+  // The location in the document load at which we inject the script.
+  UserScript::RunLocation run_location_;
+
+  // This injection's request id. This will be -1 unless the injection is
+  // currently waiting on permission.
+  int64_t request_id_;
+
+  // Identifies the frame we're injecting into.
+  base::UkmSourceId ukm_source_id_;
+
+  // Whether or not the injection is complete, either via injecting the script
+  // or because it will never complete.
+  bool complete_;
+
+  // Whether or not the injection successfully injected JS.
+  bool did_inject_js_;
+
+  // Whether or not we should log dom activity for this injection.
+  bool log_activity_;
+
+  // Results storage.
+  std::unique_ptr<base::Value> execution_result_;
+
+  // The callback to run upon completing asynchronously.
+  CompletionCallback async_completion_callback_;
+
+  // A helper class to hold the render frame and watch for its deletion.
+  std::unique_ptr<FrameWatcher> frame_watcher_;
+
+  base::WeakPtrFactory<ScriptInjection> weak_ptr_factory_{this};
+
+  DISALLOW_COPY_AND_ASSIGN(ScriptInjection);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_SCRIPT_INJECTION_H_
diff --git a/components/user_scripts/content/renderer/script_injection_callback.cc b/components/user_scripts/content/renderer/script_injection_callback.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/script_injection_callback.cc
@@ -0,0 +1,26 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "script_injection_callback.h"
+
+#include "third_party/blink/public/platform/web_vector.h"
+
+namespace user_scripts {
+
+ScriptInjectionCallback::ScriptInjectionCallback(
+    const CompleteCallback& injection_completed_callback)
+    : injection_completed_callback_(injection_completed_callback) {
+}
+
+ScriptInjectionCallback::~ScriptInjectionCallback() {
+}
+
+void ScriptInjectionCallback::Completed(
+    const blink::WebVector<v8::Local<v8::Value>>& result) {
+  std::vector<v8::Local<v8::Value>> stl_result(result.begin(), result.end());
+  injection_completed_callback_.Run(stl_result);
+  delete this;
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/content/renderer/script_injection_callback.h b/components/user_scripts/content/renderer/script_injection_callback.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/script_injection_callback.h
@@ -0,0 +1,38 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_SCRIPT_INJECTION_CALLBACK_H_
+#define EXTENSIONS_RENDERER_SCRIPT_INJECTION_CALLBACK_H_
+
+#include <vector>
+
+#include "base/callback.h"
+#include "base/macros.h"
+#include "third_party/blink/public/web/web_script_execution_callback.h"
+#include "v8/include/v8.h"
+
+namespace user_scripts {
+
+// A wrapper around a callback to notify a script injection when injection
+// completes.
+// This class manages its own lifetime.
+class ScriptInjectionCallback : public blink::WebScriptExecutionCallback {
+ public:
+  using CompleteCallback =
+      base::Callback<void(const std::vector<v8::Local<v8::Value>>& result)>;
+
+  ScriptInjectionCallback(const CompleteCallback& injection_completed_callback);
+  ~ScriptInjectionCallback() override;
+
+  void Completed(const blink::WebVector<v8::Local<v8::Value>>& result) override;
+
+ private:
+  CompleteCallback injection_completed_callback_;
+
+  DISALLOW_COPY_AND_ASSIGN(ScriptInjectionCallback);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_SCRIPT_INJECTION_CALLBACK_H_
diff --git a/components/user_scripts/content/renderer/script_injection_manager.cc b/components/user_scripts/content/renderer/script_injection_manager.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/script_injection_manager.cc
@@ -0,0 +1,550 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "script_injection_manager.h"
+
+#include <memory>
+#include <utility>
+
+#include "base/auto_reset.h"
+#include "base/bind.h"
+#include "base/feature_list.h"
+#include "base/memory/weak_ptr.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "base/values.h"
+#include "base/logging.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/renderer/render_frame_observer.h"
+#include "content/public/renderer/render_thread.h"
+//#include "../common/extension.h"
+//#include "../common/extension_features.h"
+//#include "../common/extension_messages.h"
+//#include "../common/extension_set.h"
+#include "extension_frame_helper.h"
+//#include "extension_injection_host.h"
+#include "../common/extension_id.h"
+//#include "programmatic_script_injector.h"
+//#include "renderer_extension_registry.h"
+#include "../common/host_id.h"
+#include "script_injection.h"
+#include "scripts_run_info.h"
+#include "web_ui_injection_host.h"
+#include "ipc/ipc_message_macros.h"
+#include "third_party/blink/public/platform/web_url_error.h"
+#include "third_party/blink/public/web/web_document.h"
+#include "third_party/blink/public/web/web_frame.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "third_party/blink/public/web/web_view.h"
+#include "url/gurl.h"
+
+namespace user_scripts {
+
+namespace {
+
+// The length of time to wait after the DOM is complete to try and run user
+// scripts.
+const int kScriptIdleTimeoutInMs = 200;
+
+// Returns the RunLocation that follows |run_location|.
+UserScript::RunLocation NextRunLocation(UserScript::RunLocation run_location) {
+  switch (run_location) {
+    case UserScript::DOCUMENT_START:
+      return UserScript::DOCUMENT_END;
+    case UserScript::DOCUMENT_END:
+      return UserScript::DOCUMENT_IDLE;
+    case UserScript::DOCUMENT_IDLE:
+      return UserScript::RUN_LOCATION_LAST;
+    case UserScript::UNDEFINED:
+    case UserScript::RUN_DEFERRED:
+    case UserScript::BROWSER_DRIVEN:
+    case UserScript::RUN_LOCATION_LAST:
+      break;
+  }
+  NOTREACHED();
+  return UserScript::RUN_LOCATION_LAST;
+}
+
+}  // namespace
+
+class ScriptInjectionManager::RFOHelper : public content::RenderFrameObserver {
+ public:
+  RFOHelper(content::RenderFrame* render_frame,
+            ScriptInjectionManager* manager);
+  ~RFOHelper() override;
+
+ private:
+  // RenderFrameObserver implementation.
+  //bool OnMessageReceived(const IPC::Message& message) override;
+  void DidCreateNewDocument() override;
+  void DidCreateDocumentElement() override;
+  void DidFailProvisionalLoad() override;
+  void DidFinishDocumentLoad() override;
+  void WillDetach() override;
+  void OnDestruct() override;
+  void OnStop() override;
+
+  //virtual void OnExecuteCode(/*const ExtensionMsg_ExecuteCode_Params& params*/);
+  // virtual void OnExecuteDeclarativeScript(int tab_id,
+  //                                         const ExtensionId& extension_id,
+  //                                         int script_id,
+  //                                         const GURL& url);
+  //virtual void OnPermitScriptInjection(int64_t request_id);
+
+  // Tells the ScriptInjectionManager to run tasks associated with
+  // document_idle.
+  void RunIdle();
+
+  void StartInjectScripts(UserScript::RunLocation run_location);
+
+  // Indicate that the frame is no longer valid because it is starting
+  // a new load or closing.
+  void InvalidateAndResetFrame(bool force_reset);
+
+  // The owning ScriptInjectionManager.
+  ScriptInjectionManager* manager_;
+
+  bool should_run_idle_;
+
+  base::WeakPtrFactory<RFOHelper> weak_factory_{this};
+};
+
+ScriptInjectionManager::RFOHelper::RFOHelper(content::RenderFrame* render_frame,
+                                             ScriptInjectionManager* manager)
+    : content::RenderFrameObserver(render_frame),
+      manager_(manager),
+      should_run_idle_(true) {}
+
+ScriptInjectionManager::RFOHelper::~RFOHelper() {
+}
+
+// bool ScriptInjectionManager::RFOHelper::OnMessageReceived(
+//     const IPC::Message& message) {
+//   bool handled = true;
+//  IPC_BEGIN_MESSAGE_MAP(ScriptInjectionManager::RFOHelper, message)
+//    IPC_MESSAGE_HANDLER(ExtensionMsg_ExecuteCode, OnExecuteCode)
+//    IPC_MESSAGE_HANDLER(ExtensionMsg_PermitScriptInjection,
+//                        OnPermitScriptInjection)
+//    IPC_MESSAGE_HANDLER(ExtensionMsg_ExecuteDeclarativeScript,
+//                        OnExecuteDeclarativeScript)
+//    IPC_MESSAGE_UNHANDLED(handled = false)
+//  IPC_END_MESSAGE_MAP()
+//   return handled;
+// }
+
+void ScriptInjectionManager::RFOHelper::DidCreateNewDocument() {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::DidCreateNewDocument";
+
+  // A new document is going to be shown, so invalidate the old document state.
+  // Don't force-reset the frame, because it is possible that a script injection
+  // was scheduled before the page was loaded, e.g. by navigating to a
+  // javascript: URL before the page has loaded.
+  constexpr bool kForceReset = false;
+  InvalidateAndResetFrame(kForceReset);
+
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::DidCreateNewDocument exit";
+}
+
+void ScriptInjectionManager::RFOHelper::DidCreateDocumentElement() {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::DidCreateDocumentElement";
+
+  ExtensionFrameHelper::Get(render_frame())
+      ->ScheduleAtDocumentStart(
+          base::Bind(&ScriptInjectionManager::RFOHelper::StartInjectScripts,
+                     weak_factory_.GetWeakPtr(), UserScript::DOCUMENT_START));
+
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::DidCreateDocumentElement exit";
+}
+
+void ScriptInjectionManager::RFOHelper::DidFailProvisionalLoad() {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::DidFailProvisionalLoad";
+  auto it = manager_->frame_statuses_.find(render_frame());
+  if (it != manager_->frame_statuses_.end() &&
+      it->second == UserScript::DOCUMENT_START) {
+    // Since the provisional load failed, the frame stays at its previous loaded
+    // state and origin (or the parent's origin for new/about:blank frames).
+    // Reset the frame to DOCUMENT_IDLE in order to reflect that the frame is
+    // done loading, and avoid any deadlock in the system.
+    //
+    // We skip injection of DOCUMENT_END and DOCUMENT_IDLE scripts, because the
+    // injections closely follow the DOMContentLoaded (and onload) events, which
+    // are not triggered after a failed provisional load.
+    // This assumption is verified in the checkDOMContentLoadedEvent subtest of
+    // ExecuteScriptApiTest.FrameWithHttp204 (browser_tests).
+    constexpr bool kForceReset = true;
+    InvalidateAndResetFrame(kForceReset);
+    should_run_idle_ = false;
+    manager_->frame_statuses_[render_frame()] = UserScript::DOCUMENT_IDLE;
+  }
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::DidFailProvisionalLoad exit";
+}
+
+void ScriptInjectionManager::RFOHelper::DidFinishDocumentLoad() {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::DidFinishDocumentLoad";
+  DCHECK(content::RenderThread::Get());
+  ExtensionFrameHelper::Get(render_frame())
+      ->ScheduleAtDocumentEnd(
+          base::Bind(&ScriptInjectionManager::RFOHelper::StartInjectScripts,
+                     weak_factory_.GetWeakPtr(), UserScript::DOCUMENT_END));
+
+  // We try to run idle in two places: a delayed task here and in response to
+  // ContentRendererClient::RunScriptsAtDocumentIdle(). DidFinishDocumentLoad()
+  // corresponds to completing the document's load, whereas
+  // RunScriptsAtDocumentIdle() corresponds to completing the document and all
+  // subresources' load (but before the window.onload event). We don't want to
+  // hold up script injection for a particularly slow subresource, so we set a
+  // delayed task from here - but if we finish everything before that point
+  // (i.e., RunScriptsAtDocumentIdle() is triggered), then there's no reason to
+  // keep waiting.
+  render_frame()
+      ->GetTaskRunner(blink::TaskType::kInternalDefault)
+      ->PostDelayedTask(
+          FROM_HERE,
+          base::BindOnce(&ScriptInjectionManager::RFOHelper::RunIdle,
+                         weak_factory_.GetWeakPtr()),
+          base::TimeDelta::FromMilliseconds(kScriptIdleTimeoutInMs));
+
+  ExtensionFrameHelper::Get(render_frame())
+      ->ScheduleAtDocumentIdle(
+          base::Bind(&ScriptInjectionManager::RFOHelper::RunIdle,
+                     weak_factory_.GetWeakPtr()));
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::DidFinishDocumentLoad exit";
+}
+
+void ScriptInjectionManager::RFOHelper::WillDetach() {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::WillDetach";
+  // The frame is closing - invalidate.
+  constexpr bool kForceReset = true;
+  InvalidateAndResetFrame(kForceReset);
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::WillDetach exit";
+}
+
+void ScriptInjectionManager::RFOHelper::OnDestruct() {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::OnDestruct";
+  manager_->RemoveObserver(this);
+}
+
+void ScriptInjectionManager::RFOHelper::OnStop() {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::OnStop";
+  // If the navigation request fails (e.g. 204/205/downloads), notify the
+  // extension to avoid keeping the frame in a START state indefinitely which
+  // leads to deadlocks.
+  DidFailProvisionalLoad();
+}
+
+//void ScriptInjectionManager::RFOHelper::OnExecuteCode(
+//    /*const ExtensionMsg_ExecuteCode_Params& params*/) {
+//  manager_->HandleExecuteCode(/*params,*/ render_frame());
+//}
+
+// void ScriptInjectionManager::RFOHelper::OnExecuteDeclarativeScript(
+//     int tab_id,
+//     const ExtensionId& extension_id,
+//     int script_id,
+//     const GURL& url) {
+//   // TODO(markdittmer): URL-checking isn't the best security measure.
+//   // Begin script injection workflow only if the current URL is identical to
+//   // the one that matched declarative conditions in the browser.
+//   if (GURL(render_frame()->GetWebFrame()->GetDocument().Url()) == url) {
+//     manager_->HandleExecuteDeclarativeScript(render_frame(),
+//                                              tab_id,
+//                                              extension_id,
+//                                              script_id,
+//                                              url);
+//   }
+// }
+
+// void ScriptInjectionManager::RFOHelper::OnPermitScriptInjection(
+//     int64_t request_id) {
+//   manager_->HandlePermitScriptInjection(request_id);
+// }
+
+void ScriptInjectionManager::RFOHelper::RunIdle() {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::RunIdle";
+  // Only notify the manager if the frame hasn't already had idle run since the
+  // task to RunIdle() was posted.
+  if (should_run_idle_) {
+    should_run_idle_ = false;
+    manager_->StartInjectScripts(render_frame(), UserScript::DOCUMENT_IDLE);
+  }
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::RunIdle exit";
+}
+
+void ScriptInjectionManager::RFOHelper::StartInjectScripts(
+    UserScript::RunLocation run_location) {
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::StartInjectScripts";
+  manager_->StartInjectScripts(render_frame(), run_location);
+  LOG(INFO) << "---ScriptInjectionManager::RFOHelper::StartInjectScripts exit";
+}
+
+void ScriptInjectionManager::RFOHelper::InvalidateAndResetFrame(
+    bool force_reset) {
+  // Invalidate any pending idle injections, and reset the frame inject on idle.
+  weak_factory_.InvalidateWeakPtrs();
+  // We reset to inject on idle, because the frame can be reused (in the case of
+  // navigation).
+  should_run_idle_ = true;
+
+  // Reset the frame if either |force_reset| is true, or if the manager is
+  // keeping track of the state of the frame (in which case we need to clean it
+  // up).
+  if (force_reset || manager_->frame_statuses_.count(render_frame()) != 0)
+    manager_->InvalidateForFrame(render_frame());
+}
+
+ScriptInjectionManager::ScriptInjectionManager(
+    UserScriptSetManager* user_script_set_manager)
+    : user_script_set_manager_(user_script_set_manager),
+      user_script_set_manager_observer_(this) {
+  user_script_set_manager_observer_.Add(user_script_set_manager_);
+  LOG(INFO) << "---ScriptInjectionManager::ScriptInjectionManager";
+}
+
+ScriptInjectionManager::~ScriptInjectionManager() {
+  for (const auto& injection : pending_injections_)
+    injection->invalidate_render_frame();
+  for (const auto& injection : running_injections_)
+    injection->invalidate_render_frame();
+}
+
+void ScriptInjectionManager::OnRenderFrameCreated(
+    content::RenderFrame* render_frame) {
+  rfo_helpers_.push_back(std::make_unique<RFOHelper>(render_frame, this));
+  LOG(INFO) << "---ScriptInjectionManager::OnRenderFrameCreated";
+}
+
+// void ScriptInjectionManager::OnExtensionUnloaded(
+//     const std::string& extension_id) {
+//   for (auto iter = pending_injections_.begin();
+//       iter != pending_injections_.end();) {
+//     if ((*iter)->host_id().id() == extension_id) {
+//       (*iter)->OnHostRemoved();
+//       iter = pending_injections_.erase(iter);
+//     } else {
+//       ++iter;
+//     }
+//   }
+// }
+
+void ScriptInjectionManager::OnInjectionFinished(
+    ScriptInjection* injection) {
+  auto iter =
+      std::find_if(running_injections_.begin(), running_injections_.end(),
+                   [injection](const std::unique_ptr<ScriptInjection>& mode) {
+                     return injection == mode.get();
+                   });
+  if (iter != running_injections_.end())
+    running_injections_.erase(iter);
+}
+
+void ScriptInjectionManager::OnUserScriptsUpdated(
+    const std::set<HostID>& changed_hosts) {
+  for (auto iter = pending_injections_.begin();
+       iter != pending_injections_.end();) {
+    if (changed_hosts.count((*iter)->host_id()) > 0)
+      iter = pending_injections_.erase(iter);
+    else
+      ++iter;
+  }
+}
+
+void ScriptInjectionManager::RemoveObserver(RFOHelper* helper) {
+  for (auto iter = rfo_helpers_.begin(); iter != rfo_helpers_.end(); ++iter) {
+    if (iter->get() == helper) {
+      rfo_helpers_.erase(iter);
+      break;
+    }
+  }
+}
+
+void ScriptInjectionManager::InvalidateForFrame(content::RenderFrame* frame) {
+  // If the frame invalidated is the frame being injected into, we need to
+  // note it.
+  active_injection_frames_.erase(frame);
+
+  for (auto iter = pending_injections_.begin();
+       iter != pending_injections_.end();) {
+    if ((*iter)->render_frame() == frame)
+      iter = pending_injections_.erase(iter);
+    else
+      ++iter;
+  }
+
+  frame_statuses_.erase(frame);
+}
+
+void ScriptInjectionManager::StartInjectScripts(
+    content::RenderFrame* frame,
+    UserScript::RunLocation run_location) {
+  auto iter = frame_statuses_.find(frame);
+  // We also don't execute if we detect that the run location is somehow out of
+  // order. This can happen if:
+  // - The first run location reported for the frame isn't DOCUMENT_START, or
+  // - The run location reported doesn't immediately follow the previous
+  //   reported run location.
+  // We don't want to run because extensions may have requirements that scripts
+  // running in an earlier run location have run by the time a later script
+  // runs. Better to just not run.
+  // Note that we check run_location > NextRunLocation() in the second clause
+  // (as opposed to !=) because earlier signals (like DidCreateDocumentElement)
+  // can happen multiple times, so we can receive earlier/equal run locations.
+  if ((iter == frame_statuses_.end() &&
+           run_location != UserScript::DOCUMENT_START) ||
+      (iter != frame_statuses_.end() &&
+           run_location > NextRunLocation(iter->second))) {
+    // We also invalidate the frame, because the run order of pending injections
+    // may also be bad.
+    InvalidateForFrame(frame);
+    return;
+  } else if (iter != frame_statuses_.end() && iter->second >= run_location) {
+    // Certain run location signals (like DidCreateDocumentElement) can happen
+    // multiple times. Ignore the subsequent signals.
+    return;
+  }
+
+  // Otherwise, all is right in the world, and we can get on with the
+  // injections!
+  frame_statuses_[frame] = run_location;
+  InjectScripts(frame, run_location);
+}
+
+void ScriptInjectionManager::InjectScripts(
+    content::RenderFrame* frame,
+    UserScript::RunLocation run_location) {
+  LOG(INFO) << "---ScriptInjectionManager::InjectScripts";
+
+  // Find any injections that want to run on the given frame.
+  ScriptInjectionVector frame_injections;
+  for (auto iter = pending_injections_.begin();
+       iter != pending_injections_.end();) {
+    if ((*iter)->render_frame() == frame) {
+      frame_injections.push_back(std::move(*iter));
+      iter = pending_injections_.erase(iter);
+    } else {
+      ++iter;
+    }
+  }
+
+  // Add any injections for user scripts.
+  int tab_id = ExtensionFrameHelper::Get(frame)->tab_id();
+  user_script_set_manager_->GetAllInjections(&frame_injections, frame, tab_id,
+                                             run_location);
+
+  // Note that we are running in |frame|.
+  active_injection_frames_.insert(frame);
+
+  ScriptsRunInfo scripts_run_info(frame, run_location);
+
+  for (auto iter = frame_injections.begin(); iter != frame_injections.end();) {
+    // It's possible for thScriptsRunInfoe frame to be invalidated in the course of injection
+    // (if a script removes its own frame, for example). If this happens, abort.
+    if (!active_injection_frames_.count(frame))
+      break;
+    std::unique_ptr<ScriptInjection> injection(std::move(*iter));
+    iter = frame_injections.erase(iter);
+    TryToInject(std::move(injection), run_location, &scripts_run_info);
+  }
+
+  // We are done running in the frame.
+  active_injection_frames_.erase(frame);
+
+  scripts_run_info.LogRun(activity_logging_enabled_);
+}
+
+void ScriptInjectionManager::TryToInject(
+    std::unique_ptr<ScriptInjection> injection,
+    UserScript::RunLocation run_location,
+    ScriptsRunInfo* scripts_run_info) {
+  // Try to inject the script. If the injection is waiting (i.e., for
+  // permission), add it to the list of pending injections. If the injection
+  // has blocked, add it to the list of running injections.
+  // The Unretained below is safe because this object owns all the
+  // ScriptInjections, so is guaranteed to outlive them.
+  switch (injection->TryToInject(
+      run_location, scripts_run_info,
+      base::Bind(&ScriptInjectionManager::OnInjectionFinished,
+                 base::Unretained(this)))) {
+    case ScriptInjection::INJECTION_WAITING:
+      pending_injections_.push_back(std::move(injection));
+      break;
+    case ScriptInjection::INJECTION_BLOCKED:
+      running_injections_.push_back(std::move(injection));
+      break;
+    case ScriptInjection::INJECTION_FINISHED:
+      break;
+  }
+}
+
+//void ScriptInjectionManager::HandleExecuteCode(
+//    //const ExtensionMsg_ExecuteCode_Params& params,
+//    content::RenderFrame* render_frame) {
+//  std::unique_ptr<const InjectionHost> injection_host;
+  //if (params.host_id.type() == HostID::EXTENSIONS) {
+  //  injection_host = ExtensionInjectionHost::Create(params.host_id.id());
+  //  if (!injection_host)
+  //    return;
+  //} else if (params.host_id.type() == HostID::WEBUI) {
+//    injection_host.reset(
+//        new WebUIInjectionHost(params.host_id));
+  //}
+
+//  std::unique_ptr<ScriptInjection> injection(new ScriptInjection(
+//      std::unique_ptr<ScriptInjector>(new ProgrammaticScriptInjector(params)),
+//      render_frame, std::move(injection_host), params.run_at,
+//      activity_logging_enabled_));
+
+//  FrameStatusMap::const_iterator iter = frame_statuses_.find(render_frame);
+//  UserScript::RunLocation run_location =
+//      iter == frame_statuses_.end() ? UserScript::UNDEFINED : iter->second;
+
+//  ScriptsRunInfo scripts_run_info(render_frame, run_location);
+//  TryToInject(std::move(injection), run_location, &scripts_run_info);
+//}
+
+// void ScriptInjectionManager::HandleExecuteDeclarativeScript(
+//     content::RenderFrame* render_frame,
+//     int tab_id,
+//     const ExtensionId& extension_id,
+//     int script_id,
+//     const GURL& url) {
+//   std::unique_ptr<ScriptInjection> injection =
+//       user_script_set_manager_->GetInjectionForDeclarativeScript(
+//           script_id, render_frame, tab_id, url, extension_id);
+//   if (injection.get()) {
+//     ScriptsRunInfo scripts_run_info(render_frame, UserScript::BROWSER_DRIVEN);
+//     // TODO(markdittmer): Use return value of TryToInject for error handling.
+//     TryToInject(std::move(injection), UserScript::BROWSER_DRIVEN,
+//                 &scripts_run_info);
+
+//     scripts_run_info.LogRun(activity_logging_enabled_);
+//   }
+// }
+
+// void ScriptInjectionManager::HandlePermitScriptInjection(int64_t request_id) {
+//   auto iter = pending_injections_.begin();
+//   for (; iter != pending_injections_.end(); ++iter) {
+//     if ((*iter)->request_id() == request_id) {
+//       DCHECK((*iter)->host_id().type() == HostID::EXTENSIONS);
+//       break;
+//     }
+//   }
+//   if (iter == pending_injections_.end())
+//     return;
+
+//   // At this point, because the request is present in pending_injections_, we
+//   // know that this is the same page that issued the request (otherwise,
+//   // RFOHelper::InvalidateAndResetFrame would have caused it to be cleared out).
+
+//   std::unique_ptr<ScriptInjection> injection(std::move(*iter));
+//   pending_injections_.erase(iter);
+
+//   ScriptsRunInfo scripts_run_info(injection->render_frame(),
+//                                   UserScript::RUN_DEFERRED);
+//   ScriptInjection::InjectionResult res = injection->OnPermissionGranted(
+//       &scripts_run_info);
+//   if (res == ScriptInjection::INJECTION_BLOCKED)
+//     running_injections_.push_back(std::move(injection));
+//   scripts_run_info.LogRun(activity_logging_enabled_);
+// }
+
+}  // namespace extensions
diff --git a/components/user_scripts/content/renderer/script_injection_manager.h b/components/user_scripts/content/renderer/script_injection_manager.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/script_injection_manager.h
@@ -0,0 +1,119 @@
+#include <stdint.h>
+
+#include <map>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/callback.h"
+#include "base/macros.h"
+#include "base/scoped_observer.h"
+#include "../common/user_script.h"
+#include "../common/extension_id.h"
+#include "script_injection.h"
+#include "user_script_set_manager.h"
+
+//struct ExtensionMsg_ExecuteCode_Params;
+
+namespace user_scripts {
+
+// The ScriptInjectionManager manages extensions injecting scripts into frames
+// via both content/user scripts and tabs.executeScript(). It is responsible for
+// maintaining any pending injections awaiting permission or the appropriate
+// load point, and injecting them when ready.
+class ScriptInjectionManager : public UserScriptSetManager::Observer {
+ public:
+  explicit ScriptInjectionManager(
+      UserScriptSetManager* user_script_set_manager);
+  virtual ~ScriptInjectionManager();
+
+  // Notifies that a new render view has been created.
+  void OnRenderFrameCreated(content::RenderFrame* render_frame);
+
+  // Removes pending injections of the unloaded extension.
+  //void OnExtensionUnloaded(const std::string& extension_id);
+
+  void set_activity_logging_enabled(bool enabled) {
+    activity_logging_enabled_ = enabled;
+  }
+
+ private:
+  // A RenderFrameObserver implementation which watches the various render
+  // frames in order to notify the ScriptInjectionManager of different
+  // document load states and IPCs.
+  class RFOHelper;
+
+  using FrameStatusMap =
+      std::map<content::RenderFrame*, UserScript::RunLocation>;
+
+  using ScriptInjectionVector = std::vector<std::unique_ptr<ScriptInjection>>;
+
+  // Notifies that an injection has been finished.
+  void OnInjectionFinished(ScriptInjection* injection);
+
+  // UserScriptSetManager::Observer implementation.
+  void OnUserScriptsUpdated(const std::set<HostID>& changed_hosts) override;
+
+  // Notifies that an RFOHelper should be removed.
+  void RemoveObserver(RFOHelper* helper);
+
+  // Invalidate any pending tasks associated with |frame|.
+  void InvalidateForFrame(content::RenderFrame* frame);
+
+  // Starts the process to inject appropriate scripts into |frame|.
+  void StartInjectScripts(content::RenderFrame* frame,
+                          UserScript::RunLocation run_location);
+
+  // Actually injects the scripts into |frame|.
+  void InjectScripts(content::RenderFrame* frame,
+                     UserScript::RunLocation run_location);
+
+  // Try to inject and store injection if it has not finished.
+  void TryToInject(std::unique_ptr<ScriptInjection> injection,
+                   UserScript::RunLocation run_location,
+                   ScriptsRunInfo* scripts_run_info);
+
+  // Handle the ExecuteCode extension message.
+  //void HandleExecuteCode(/*const ExtensionMsg_ExecuteCode_Params& params,*/
+  //                       content::RenderFrame* render_frame);
+
+  // Handle the ExecuteDeclarativeScript extension message.
+  // void HandleExecuteDeclarativeScript(content::RenderFrame* web_frame,
+  //                                     int tab_id,
+  //                                     const ExtensionId& extension_id,
+  //                                     int script_id,
+  //                                     const GURL& url);
+
+  // Handle the GrantInjectionPermission extension message.
+  //void HandlePermitScriptInjection(int64_t request_id);
+
+  // The map of active web frames to their corresponding statuses. The
+  // RunLocation of the frame corresponds to the last location that has ran.
+  FrameStatusMap frame_statuses_;
+
+  // The frames currently being injected into, so long as that frame is valid.
+  std::set<content::RenderFrame*> active_injection_frames_;
+
+  // The collection of RFOHelpers.
+  std::vector<std::unique_ptr<RFOHelper>> rfo_helpers_;
+
+  // The set of UserScripts associated with extensions. Owned by the Dispatcher.
+  UserScriptSetManager* user_script_set_manager_;
+
+  // Pending injections which are waiting for either the proper run location or
+  // user consent.
+  ScriptInjectionVector pending_injections_;
+
+  // Running injections which are waiting for async callbacks from blink.
+  ScriptInjectionVector running_injections_;
+
+  // Whether or not dom activity should be logged for scripts injected.
+  bool activity_logging_enabled_ = false;
+
+  ScopedObserver<UserScriptSetManager, UserScriptSetManager::Observer>
+      user_script_set_manager_observer_;
+
+  DISALLOW_COPY_AND_ASSIGN(ScriptInjectionManager);
+};
+
+}
diff --git a/components/user_scripts/content/renderer/script_injector.h b/components/user_scripts/content/renderer/script_injector.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/script_injector.h
@@ -0,0 +1,103 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_SCRIPT_INJECTOR_H_
+#define EXTENSIONS_RENDERER_SCRIPT_INJECTOR_H_
+
+#include <memory>
+#include <vector>
+
+#include "../common/constants.h"
+//#include "../common/permissions/permissions_data.h"
+#include "../common/user_script.h"
+#include "third_party/blink/public/web/web_script_source.h"
+
+class InjectionHost;
+
+namespace blink {
+class WebLocalFrame;
+}
+
+namespace user_scripts {
+
+// The pseudo-delegate class for a ScriptInjection that provides all necessary
+// information about how to inject the script, including what code to inject and
+// when (run location), but without any injection logic.
+class ScriptInjector {
+ public:
+  // The possible reasons for not injecting the script.
+  enum InjectFailureReason {
+    EXTENSION_REMOVED,  // The extension was removed before injection.
+    NOT_ALLOWED,        // The script is not allowed to inject.
+    WONT_INJECT         // The injection won't inject because the user rejected
+                        // (or just did not accept) the injection.
+  };
+
+  virtual ~ScriptInjector() {}
+
+  // Returns the script type of this particular injection.
+  virtual UserScript::InjectionType script_type() const = 0;
+
+  // Returns true if the script is running inside a user gesture.
+  virtual bool IsUserGesture() const = 0;
+
+  // Returns the CSS origin of this injection.
+  virtual base::Optional<CSSOrigin> GetCssOrigin() const = 0;
+
+  // Returns the key for this injection, if it's a CSS injection.
+  virtual const base::Optional<std::string> GetInjectionKey() const = 0;
+
+  // Returns true if the script expects results.
+  virtual bool ExpectsResults() const = 0;
+
+  // Returns true if the script should inject JS source at the given
+  // |run_location|.
+  virtual bool ShouldInjectJs(
+      UserScript::RunLocation run_location,
+      const std::set<std::string>& executing_scripts) const = 0;
+
+  // Returns true if the script should inject CSS at the given |run_location|.
+  virtual bool ShouldInjectCss(
+      UserScript::RunLocation run_location,
+      const std::set<std::string>& injected_stylesheets) const = 0;
+
+  // Returns true if the script should execute on the given |frame|.
+//  virtual PermissionsData::PageAccess CanExecuteOnFrame(
+//      const InjectionHost* injection_host,
+//      blink::WebLocalFrame* web_frame,
+//      int tab_id) = 0;
+
+  // Returns the javascript sources to inject at the given |run_location|.
+  // Only called if ShouldInjectJs() is true.
+  virtual std::vector<blink::WebScriptSource> GetJsSources(
+      UserScript::RunLocation run_location,
+      std::set<std::string>* executing_scripts,
+      size_t* num_injected_js_scripts) const = 0;
+
+  // Returns the css to inject at the given |run_location|.
+  // Only called if ShouldInjectCss() is true.
+  virtual std::vector<blink::WebString> GetCssSources(
+      UserScript::RunLocation run_location,
+      std::set<std::string>* injected_stylesheets,
+      size_t* num_injected_stylesheets) const = 0;
+
+  // Notifies the script that injection has completed, with a possibly-populated
+  // list of results (depending on whether or not ExpectsResults() was true).
+  // |render_frame| contains the render frame, or null if the frame was
+  // invalidated.
+  virtual void OnInjectionComplete(
+      std::unique_ptr<base::Value> execution_result,
+      UserScript::RunLocation run_location,
+      content::RenderFrame* render_frame) = 0;
+
+  // Notifies the script that injection will never occur.
+  // |render_frame| contains the render frame, or null if the frame was
+  // invalidated.
+  virtual void OnWillNotInject(InjectFailureReason reason,
+                               content::RenderFrame* render_frame) = 0;
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_SCRIPT_INJECTOR_H_
diff --git a/components/user_scripts/content/renderer/scripts_run_info.cc b/components/user_scripts/content/renderer/scripts_run_info.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/scripts_run_info.cc
@@ -0,0 +1,78 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "scripts_run_info.h"
+
+#include "base/metrics/histogram_macros.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/renderer/render_thread.h"
+//#include "extensions/common/extension_messages.h"
+#include "script_context.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+
+namespace user_scripts {
+
+ScriptsRunInfo::ScriptsRunInfo(content::RenderFrame* render_frame,
+                               UserScript::RunLocation location)
+    : num_css(0u),
+      num_js(0u),
+      num_blocking_js(0u),
+      routing_id_(render_frame->GetRoutingID()),
+      run_location_(location),
+      frame_url_(ScriptContext::GetDocumentLoaderURLForFrame(
+          render_frame->GetWebFrame())) {}
+
+ScriptsRunInfo::~ScriptsRunInfo() {
+}
+
+void ScriptsRunInfo::LogRun(bool send_script_activity) {
+  // // Notify the browser if any extensions are now executing scripts.
+  // if (!executing_scripts.empty() && send_script_activity) {
+  //   content::RenderThread::Get()->Send(
+  //       new ExtensionHostMsg_ContentScriptsExecuting(
+  //           routing_id_, executing_scripts, frame_url_));
+  // }
+
+  // base::TimeDelta elapsed = timer.Elapsed();
+
+  // switch (run_location_) {
+  //   case UserScript::DOCUMENT_START:
+  //     UMA_HISTOGRAM_COUNTS_100("Extensions.InjectStart_CssCount", num_css);
+  //     UMA_HISTOGRAM_COUNTS_100("Extensions.InjectStart_ScriptCount", num_js);
+  //     if (num_blocking_js) {
+  //       UMA_HISTOGRAM_COUNTS_100("Extensions.InjectStart_BlockingScriptCount",
+  //                                num_blocking_js);
+  //     } else if (num_css || num_js) {
+  //       UMA_HISTOGRAM_TIMES("Extensions.InjectStart_Time", elapsed);
+  //     }
+  //     break;
+  //   case UserScript::DOCUMENT_END:
+  //     UMA_HISTOGRAM_COUNTS_100("Extensions.InjectEnd_ScriptCount", num_js);
+  //     if (num_blocking_js) {
+  //       UMA_HISTOGRAM_COUNTS_100("Extensions.InjectEnd_BlockingScriptCount",
+  //                                num_blocking_js);
+  //     } else if (num_js) {
+  //       UMA_HISTOGRAM_TIMES("Extensions.InjectEnd_Time", elapsed);
+  //     }
+  //     break;
+  //   case UserScript::DOCUMENT_IDLE:
+  //     UMA_HISTOGRAM_COUNTS_100("Extensions.InjectIdle_ScriptCount", num_js);
+  //     if (num_blocking_js) {
+  //       UMA_HISTOGRAM_COUNTS_100("Extensions.InjectIdle_BlockingScriptCount",
+  //                                num_blocking_js);
+  //     } else if (num_js) {
+  //       UMA_HISTOGRAM_TIMES("Extensions.InjectIdle_Time", elapsed);
+  //     }
+  //     break;
+  //   case UserScript::RUN_DEFERRED:
+  //   case UserScript::BROWSER_DRIVEN:
+  //     // TODO(rdevlin.cronin): Add histograms.
+  //     break;
+  //   case UserScript::UNDEFINED:
+  //   case UserScript::RUN_LOCATION_LAST:
+  //     NOTREACHED();
+  // }
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/content/renderer/scripts_run_info.h b/components/user_scripts/content/renderer/scripts_run_info.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/scripts_run_info.h
@@ -0,0 +1,70 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_SCRIPTS_RUN_INFO_H_
+#define EXTENSIONS_RENDERER_SCRIPTS_RUN_INFO_H_
+
+#include <stddef.h>
+
+#include <map>
+#include <set>
+#include <string>
+
+#include "base/macros.h"
+#include "base/timer/elapsed_timer.h"
+#include "../common/user_script.h"
+
+namespace content {
+class RenderFrame;
+}
+
+namespace user_scripts {
+
+// A struct containing information about a script run.
+struct ScriptsRunInfo {
+  // Map of extensions IDs to the executing script paths.
+  typedef std::map<std::string, std::set<std::string> > ExecutingScriptsMap;
+
+  ScriptsRunInfo(content::RenderFrame* render_frame,
+                 UserScript::RunLocation location);
+  ~ScriptsRunInfo();
+
+  // The number of CSS scripts injected.
+  size_t num_css;
+  // The number of JS scripts injected.
+  size_t num_js;
+  // The number of blocked JS scripts injected.
+  size_t num_blocking_js;
+  // A map of extension ids to executing script paths.
+  ExecutingScriptsMap executing_scripts;
+  // A map of extension ids to injected stylesheet paths.
+  ExecutingScriptsMap injected_stylesheets;
+  // The elapsed time since the ScriptsRunInfo was constructed.
+  base::ElapsedTimer timer;
+
+  // Log information about a given script run. If |send_script_activity| is
+  // true, this also informs the browser of the script run.
+  void LogRun(bool send_script_activity);
+
+  static void LogLongInjectionTaskTime(UserScript::RunLocation run_location,
+                                       const base::TimeDelta& elapsed);
+
+ private:
+  // The routinig id to use to notify the browser of any injections. Since the
+  // frame may be deleted in injection, we don't hold on to a reference to it
+  // directly.
+  int routing_id_;
+
+  // The run location at which injection is happening.
+  UserScript::RunLocation run_location_;
+
+  // The url of the frame, preserved for the same reason as the routing id.
+  GURL frame_url_;
+
+  DISALLOW_COPY_AND_ASSIGN(ScriptsRunInfo);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_SCRIPTS_RUN_INFO_H_
diff --git a/components/user_scripts/content/renderer/user_script_injector.cc b/components/user_scripts/content/renderer/user_script_injector.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/user_script_injector.cc
@@ -0,0 +1,284 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "user_script_injector.h"
+
+#include <tuple>
+#include <vector>
+
+#include "base/logging.h"
+#include "base/lazy_instance.h"
+#include "content/public/common/url_constants.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/renderer/render_thread.h"
+#include "content/public/renderer/render_view.h"
+//#include "extensions/common/extension.h"
+//#include "extensions/common/guest_view/extensions_guest_view_messages.h"
+//#include "extensions/common/permissions/permissions_data.h"
+#include "components/user_scripts/content/renderer/grit/user_scripts_renderer_resources.h"
+#include "injection_host.h"
+#include "script_context.h"
+#include "scripts_run_info.h"
+#include "third_party/blink/public/web/web_document.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "third_party/blink/public/web/web_script_source.h"
+#include "ui/base/resource/resource_bundle.h"
+#include "url/gurl.h"
+
+namespace user_scripts {
+
+namespace {
+
+struct RoutingInfoKey {
+  int routing_id;
+  int script_id;
+
+  RoutingInfoKey(int routing_id, int script_id)
+      : routing_id(routing_id), script_id(script_id) {}
+
+  bool operator<(const RoutingInfoKey& other) const {
+    return std::tie(routing_id, script_id) <
+           std::tie(other.routing_id, other.script_id);
+  }
+};
+
+using RoutingInfoMap = std::map<RoutingInfoKey, bool>;
+
+// A map records whether a given |script_id| from a webview-added user script
+// is allowed to inject on the render of given |routing_id|.
+// Once a script is added, the decision of whether or not allowed to inject
+// won't be changed.
+// After removed by the webview, the user scipt will also be removed
+// from the render. Therefore, there won't be any query from the same
+// |script_id| and |routing_id| pair.
+// base::LazyInstance<RoutingInfoMap>::DestructorAtExit g_routing_info_map =
+//    LAZY_INSTANCE_INITIALIZER;
+
+// Greasemonkey API source that is injected with the scripts.
+struct GreasemonkeyApiJsString {
+  GreasemonkeyApiJsString();
+  blink::WebScriptSource GetSource() const;
+
+ private:
+  blink::WebString source_;
+};
+
+// The below constructor, monstrous as it is, just makes a WebScriptSource from
+// the GreasemonkeyApiJs resource.
+GreasemonkeyApiJsString::GreasemonkeyApiJsString() {
+  std::string greasemonky_api_js(
+      ui::ResourceBundle::GetSharedInstance().LoadDataResourceString(
+          IDR_GREASEMONKEY_API_JS));
+  source_ = blink::WebString::FromUTF8(greasemonky_api_js);
+}
+
+blink::WebScriptSource GreasemonkeyApiJsString::GetSource() const {
+  return blink::WebScriptSource(source_);
+}
+
+base::LazyInstance<GreasemonkeyApiJsString>::Leaky g_greasemonkey_api =
+    LAZY_INSTANCE_INITIALIZER;
+
+bool ShouldInjectScripts(const UserScript::FileList& scripts,
+                         const std::set<std::string>& injected_files) {
+  for (const std::unique_ptr<UserScript::File>& file : scripts) {
+    // Check if the script is already injected.
+    if (injected_files.count(file->url().path()) == 0) {
+      return true;
+    }
+  }
+  return false;
+}
+
+}  // namespace
+
+UserScriptInjector::UserScriptInjector(const UserScript* script,
+                                       UserScriptSet* script_list /*,
+                                       bool is_declarative*/)
+    : script_(script),
+      user_script_set_(script_list),
+      script_id_(script_->id()),
+      //host_id_(script_->host_id()),
+      //is_declarative_(is_declarative),
+      user_script_set_observer_(this) {
+  LOG(INFO) << "---UserScriptInjector::UserScriptInjector";
+  user_script_set_observer_.Add(script_list);
+}
+
+UserScriptInjector::~UserScriptInjector() {
+}
+
+void UserScriptInjector::OnUserScriptsUpdated(
+    const std::set<HostID>& changed_hosts,
+    const UserScriptList& scripts) {
+  // When user scripts are updated, all the old script pointers are invalidated.
+  script_ = nullptr;
+  // If the host causing this injection changed, then this injection
+  // will be removed, and there's no guarantee the backing script still exists.
+  // if (changed_hosts.count(host_id_) > 0)
+  //   return;
+
+  for (const std::unique_ptr<UserScript>& script : scripts) {
+    if (script->id() == script_id_) {
+      script_ = script.get();
+      break;
+    }
+  }
+  // If |host_id_| wasn't in |changed_hosts|, then the script for this injection
+  // should be guaranteed to exist.
+  DCHECK(script_);
+}
+
+UserScript::InjectionType UserScriptInjector::script_type() const {
+  return UserScript::CONTENT_SCRIPT;
+}
+
+bool UserScriptInjector::IsUserGesture() const {
+  return false;
+}
+
+bool UserScriptInjector::ExpectsResults() const {
+  return false;
+}
+
+base::Optional<CSSOrigin> UserScriptInjector::GetCssOrigin() const {
+  return base::nullopt;
+}
+
+const base::Optional<std::string> UserScriptInjector::GetInjectionKey() const {
+  return base::nullopt;
+}
+
+bool UserScriptInjector::ShouldInjectJs(
+    UserScript::RunLocation run_location,
+    const std::set<std::string>& executing_scripts) const {
+  return script_ && script_->run_location() == run_location &&
+         !script_->js_scripts().empty() &&
+         ShouldInjectScripts(script_->js_scripts(), executing_scripts);
+}
+
+bool UserScriptInjector::ShouldInjectCss(
+    UserScript::RunLocation run_location,
+    const std::set<std::string>& injected_stylesheets) const {
+  return script_ && run_location == UserScript::DOCUMENT_START &&
+         !script_->css_scripts().empty() &&
+         ShouldInjectScripts(script_->css_scripts(), injected_stylesheets);
+}
+
+// PermissionsData::PageAccess UserScriptInjector::CanExecuteOnFrame(
+//     const InjectionHost* injection_host,
+//     blink::WebLocalFrame* web_frame,
+//     int tab_id) {
+//   // There is no harm in allowing the injection when the script is gone,
+//   // because there is nothing to inject.
+//   if (!script_)
+//     return PermissionsData::PageAccess::kAllowed;
+
+//   if (script_->consumer_instance_type() ==
+//           UserScript::ConsumerInstanceType::WEBVIEW) {
+//     int routing_id = content::RenderView::FromWebView(web_frame->Top()->View())
+//                          ->GetRoutingID();
+
+//     RoutingInfoKey key(routing_id, script_->id());
+
+//     RoutingInfoMap& map = g_routing_info_map.Get();
+//     auto iter = map.find(key);
+
+//     bool allowed = false;
+//     if (iter != map.end()) {
+//       allowed = iter->second;
+//     } else {
+//       // Send a SYNC IPC message to the browser to check if this is allowed.
+//       // This is not ideal, but is mitigated by the fact that this is only done
+//       // for webviews, and then only once per host.
+//       // TODO(hanxi): Find a more efficient way to do this.
+//       content::RenderThread::Get()->Send(
+//           new ExtensionsGuestViewHostMsg_CanExecuteContentScriptSync(
+//               routing_id, script_->id(), &allowed));
+//       map.insert(std::pair<RoutingInfoKey, bool>(key, allowed));
+//     }
+
+//     return allowed ? PermissionsData::PageAccess::kAllowed
+//                    : PermissionsData::PageAccess::kDenied;
+//   }
+
+//   GURL effective_document_url =
+//       ScriptContext::GetEffectiveDocumentURLForInjection(
+//           web_frame, web_frame->GetDocument().Url(),
+//           script_->match_origin_as_fallback());
+
+//   return injection_host->CanExecuteOnFrame(
+//       effective_document_url,
+//       content::RenderFrame::FromWebFrame(web_frame),
+//       tab_id,
+//       is_declarative_);
+// }
+
+std::vector<blink::WebScriptSource> UserScriptInjector::GetJsSources(
+    UserScript::RunLocation run_location,
+    std::set<std::string>* executing_scripts,
+    size_t* num_injected_js_scripts) const {
+  DCHECK(script_);
+  std::vector<blink::WebScriptSource> sources;
+
+  DCHECK_EQ(script_->run_location(), run_location);
+
+  const UserScript::FileList& js_scripts = script_->js_scripts();
+  sources.reserve(js_scripts.size() +
+                  (script_->emulate_greasemonkey() ? 1 : 0));
+  // Emulate Greasemonkey API for scripts that were converted to extension
+  // user scripts.
+  if (script_->emulate_greasemonkey())
+    sources.push_back(g_greasemonkey_api.Get().GetSource());
+  for (const std::unique_ptr<UserScript::File>& file : js_scripts) {
+    const GURL& script_url = file->url();
+    // Check if the script is already injected.
+    if (executing_scripts->count(script_url.path()) != 0)
+      continue;
+
+    sources.push_back(blink::WebScriptSource(
+        user_script_set_->GetJsSource(*file, script_->emulate_greasemonkey()),
+        script_url));
+
+    (*num_injected_js_scripts) += 1;
+    executing_scripts->insert(script_url.path());
+  }
+
+  return sources;
+}
+
+std::vector<blink::WebString> UserScriptInjector::GetCssSources(
+    UserScript::RunLocation run_location,
+    std::set<std::string>* injected_stylesheets,
+    size_t* num_injected_stylesheets) const {
+  DCHECK(script_);
+  DCHECK_EQ(UserScript::DOCUMENT_START, run_location);
+
+  std::vector<blink::WebString> sources;
+
+  const UserScript::FileList& css_scripts = script_->css_scripts();
+  sources.reserve(css_scripts.size());
+  for (const std::unique_ptr<UserScript::File>& file : script_->css_scripts()) {
+    const std::string& stylesheet_path = file->url().path();
+    // Check if the stylesheet is already injected.
+    if (injected_stylesheets->count(stylesheet_path) != 0)
+      continue;
+
+    sources.push_back(user_script_set_->GetCssSource(*file));
+    (*num_injected_stylesheets) += 1;
+    injected_stylesheets->insert(stylesheet_path);
+  }
+  return sources;
+}
+
+void UserScriptInjector::OnInjectionComplete(
+    std::unique_ptr<base::Value> execution_result,
+    UserScript::RunLocation run_location,
+    content::RenderFrame* render_frame) {}
+
+void UserScriptInjector::OnWillNotInject(InjectFailureReason reason,
+                                         content::RenderFrame* render_frame) {
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/content/renderer/user_script_injector.h b/components/user_scripts/content/renderer/user_script_injector.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/user_script_injector.h
@@ -0,0 +1,98 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_USER_SCRIPT_INJECTOR_H_
+#define EXTENSIONS_RENDERER_USER_SCRIPT_INJECTOR_H_
+
+#include <memory>
+#include <string>
+
+#include "base/macros.h"
+#include "base/scoped_observer.h"
+#include "../common/user_script.h"
+#include "script_injection.h"
+#include "user_script_set.h"
+
+class InjectionHost;
+
+namespace blink {
+class WebLocalFrame;
+}
+
+namespace user_scripts {
+
+// A ScriptInjector for UserScripts.
+class UserScriptInjector : public ScriptInjector,
+                           public UserScriptSet::Observer {
+ public:
+  UserScriptInjector(const UserScript* user_script,
+                     UserScriptSet* user_script_set /*,
+                     bool is_declarative*/);
+  ~UserScriptInjector() override;
+
+ private:
+  // UserScriptSet::Observer implementation.
+  void OnUserScriptsUpdated(const std::set<HostID>& changed_hosts,
+                            const UserScriptList& scripts) override;
+
+  // ScriptInjector implementation.
+  UserScript::InjectionType script_type() const override;
+  bool IsUserGesture() const override;
+  base::Optional<CSSOrigin> GetCssOrigin() const override;
+  const base::Optional<std::string> GetInjectionKey() const override;
+  bool ExpectsResults() const override;
+  bool ShouldInjectJs(
+      UserScript::RunLocation run_location,
+      const std::set<std::string>& executing_scripts) const override;
+  bool ShouldInjectCss(
+      UserScript::RunLocation run_location,
+      const std::set<std::string>& injected_stylesheets) const override;
+//   PermissionsData::PageAccess CanExecuteOnFrame(
+//       const InjectionHost* injection_host,
+//       blink::WebLocalFrame* web_frame,
+//       int tab_id) override;
+  std::vector<blink::WebScriptSource> GetJsSources(
+      UserScript::RunLocation run_location,
+      std::set<std::string>* executing_scripts,
+      size_t* num_injected_js_scripts) const override;
+  std::vector<blink::WebString> GetCssSources(
+      UserScript::RunLocation run_location,
+      std::set<std::string>* injected_stylesheets,
+      size_t* num_injected_stylesheets) const override;
+  void OnInjectionComplete(std::unique_ptr<base::Value> execution_result,
+                           UserScript::RunLocation run_location,
+                           content::RenderFrame* render_frame) override;
+  void OnWillNotInject(InjectFailureReason reason,
+                       content::RenderFrame* render_frame) override;
+
+  // The associated user script. Owned by the UserScriptInjector that created
+  // this object.
+  const UserScript* script_;
+
+  // The UserScriptSet that eventually owns the UserScript this
+  // UserScriptInjector points to.
+  // Outlives |this|.
+  UserScriptSet* const user_script_set_;
+
+  // The id of the associated user script. We cache this because when we update
+  // the |script_| associated with this injection, the old referance may be
+  // deleted.
+  int script_id_;
+
+  // The associated host id, preserved for the same reason as |script_id|.
+  //HostID host_id_;
+
+  // Indicates whether or not this script is declarative. This influences which
+  // script permissions are checked before injection.
+  //bool is_declarative_;
+
+  ScopedObserver<UserScriptSet, UserScriptSet::Observer>
+      user_script_set_observer_;
+
+  DISALLOW_COPY_AND_ASSIGN(UserScriptInjector);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_USER_SCRIPT_INJECTOR_H_
diff --git a/components/user_scripts/content/renderer/user_script_set.cc b/components/user_scripts/content/renderer/user_script_set.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/user_script_set.cc
@@ -0,0 +1,293 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "user_script_set.h"
+
+#include <stddef.h>
+
+#include <utility>
+
+#include "base/logging.h"
+#include "base/debug/alias.h"
+#include "base/memory/ref_counted.h"
+#include "base/strings/strcat.h"
+#include "content/public/common/url_constants.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/renderer/render_thread.h"
+//#include "extensions/common/extension.h"
+//#include "extensions/common/extensions_client.h"
+//#include "extensions/common/permissions/permissions_data.h"
+//#include "extension_injection_host.h"
+//#include "extensions_renderer_client.h"
+#include "injection_host.h"
+//#include "extensions/renderer/renderer_extension_registry.h"
+#include "script_context.h"
+#include "script_injection.h"
+#include "user_script_injector.h"
+#include "web_ui_injection_host.h"
+#include "third_party/blink/public/web/web_document.h"
+#include "third_party/blink/public/web/web_local_frame.h"
+#include "url/gurl.h"
+
+namespace user_scripts {
+
+namespace {
+
+// These two strings are injected before and after the Greasemonkey API and
+// user script to wrap it in an anonymous scope.
+const char kUserScriptHead[] = "(function (unsafeWindow) {\n";
+const char kUserScriptTail[] = "\n})(window);";
+// Maximum number of total content scripts we allow (across all extensions).
+// The limit exists to diagnose https://crbug.com/723381. The number is
+// arbitrarily chosen.
+// TODO(lazyboy): Remove when the bug is fixed.
+const uint32_t kNumScriptsArbitraryMax = 100000u;
+
+GURL GetDocumentUrlForFrame(blink::WebLocalFrame* frame) {
+  GURL data_source_url = ScriptContext::GetDocumentLoaderURLForFrame(frame);
+  if (!data_source_url.is_empty() && frame->IsViewSourceModeEnabled()) {
+    data_source_url = GURL(content::kViewSourceScheme + std::string(":") +
+                           data_source_url.spec());
+  }
+
+  return data_source_url;
+}
+
+}  // namespace
+
+UserScriptSet::UserScriptSet() {}
+
+UserScriptSet::~UserScriptSet() {
+}
+
+void UserScriptSet::AddObserver(Observer* observer) {
+  observers_.AddObserver(observer);
+}
+
+void UserScriptSet::RemoveObserver(Observer* observer) {
+  observers_.RemoveObserver(observer);
+}
+
+// void UserScriptSet::GetActiveExtensionIds(
+//     std::set<std::string>* ids) const {
+//   for (const std::unique_ptr<UserScript>& script : scripts_) {
+//     if (script->host_id().type() != HostID::EXTENSIONS)
+//       continue;
+//     DCHECK(!script->extension_id().empty());
+//     ids->insert(script->extension_id());
+//   }
+// }
+
+void UserScriptSet::GetInjections(
+    std::vector<std::unique_ptr<ScriptInjection>>* injections,
+    content::RenderFrame* render_frame,
+    int tab_id,
+    UserScript::RunLocation run_location,
+    bool log_activity) {
+  GURL document_url = GetDocumentUrlForFrame(render_frame->GetWebFrame());
+  for (const std::unique_ptr<UserScript>& script : scripts_) {
+    std::unique_ptr<ScriptInjection> injection = GetInjectionForScript(
+        script.get(), render_frame, tab_id, run_location, document_url,
+        /* is_declarative, */ log_activity);
+    if (injection.get())
+      injections->push_back(std::move(injection));
+  }
+}
+
+bool UserScriptSet::UpdateUserScripts(
+    base::ReadOnlySharedMemoryRegion shared_memory,
+    const std::set<HostID>& changed_hosts,
+    bool whitelisted_only) {
+  bool only_inject_incognito = false;
+      //ExtensionsRendererClient::Get()->IsIncognitoProcess();
+
+  // Create the shared memory mapping.
+  shared_memory_mapping_ = shared_memory.Map();
+  if (!shared_memory.IsValid())
+    return false;
+
+  // First get the size of the memory block.
+  const base::Pickle::Header* pickle_header =
+      shared_memory_mapping_.GetMemoryAs<base::Pickle::Header>();
+  if (!pickle_header)
+    return false;
+
+  // Now read in the rest of the block.
+  size_t pickle_size =
+      sizeof(base::Pickle::Header) + pickle_header->payload_size;
+
+  // Unpickle scripts.
+  uint32_t num_scripts = 0;
+  auto memory = shared_memory_mapping_.GetMemoryAsSpan<char>(pickle_size);
+  if (!memory.size())
+    return false;
+
+  base::Pickle pickle(memory.data(), pickle_size);
+  base::PickleIterator iter(pickle);
+  base::debug::Alias(&pickle_size);
+  CHECK(iter.ReadUInt32(&num_scripts));
+
+  // Sometimes the shared memory contents seem to be corrupted
+  // (https://crbug.com/723381). Set an arbitrary max limit to the number of
+  // scripts so that we don't add OOM noise to crash reports.
+  CHECK_LT(num_scripts, kNumScriptsArbitraryMax);
+
+  scripts_.clear();
+  script_sources_.clear();
+  scripts_.reserve(num_scripts);
+  for (uint32_t i = 0; i < num_scripts; ++i) {
+    std::unique_ptr<UserScript> script(new UserScript());
+    script->Unpickle(pickle, &iter);
+
+    // Note that this is a pointer into shared memory. We don't own it. It gets
+    // cleared up when the last renderer or browser process drops their
+    // reference to the shared memory.
+    for (size_t j = 0; j < script->js_scripts().size(); ++j) {
+      const char* body = NULL;
+      int body_length = 0;
+      CHECK(iter.ReadData(&body, &body_length));
+      script->js_scripts()[j]->set_external_content(
+          base::StringPiece(body, body_length));
+    }
+    for (size_t j = 0; j < script->css_scripts().size(); ++j) {
+      const char* body = NULL;
+      int body_length = 0;
+      CHECK(iter.ReadData(&body, &body_length));
+      script->css_scripts()[j]->set_external_content(
+          base::StringPiece(body, body_length));
+    }
+
+    if (only_inject_incognito && !script->is_incognito_enabled())
+      continue;  // This script shouldn't run in an incognito tab.
+
+    // const Extension* extension =
+    //     RendererExtensionRegistry::Get()->GetByID(script->extension_id());
+    // if (whitelisted_only &&
+    //     (!extension || !PermissionsData::CanExecuteScriptEverywhere(
+    //                        extension->id(), extension->location()))) {
+    //   continue;
+    // }
+
+    scripts_.push_back(std::move(script));
+  }
+
+  for (auto& observer : observers_)
+    observer.OnUserScriptsUpdated(changed_hosts, scripts_);
+  return true;
+}
+
+void UserScriptSet::AddScript(std::unique_ptr<UserScript> script) {
+  scripts_.push_back(std::move(script));
+}
+
+// std::unique_ptr<ScriptInjection> UserScriptSet::GetDeclarativeScriptInjection(
+//     int script_id,
+//     content::RenderFrame* render_frame,
+//     int tab_id,
+//     UserScript::RunLocation run_location,
+//     const GURL& document_url,
+//     bool log_activity) {
+//   for (const std::unique_ptr<UserScript>& script : scripts_) {
+//     if (script->id() == script_id) {
+//       return GetInjectionForScript(script.get(), render_frame, tab_id,
+//                                    run_location, document_url,
+//                                    /* is_declarative, */ log_activity);
+//     }
+//   }
+//   return std::unique_ptr<ScriptInjection>();
+// }
+
+std::unique_ptr<ScriptInjection> UserScriptSet::GetInjectionForScript(
+    const UserScript* script,
+    content::RenderFrame* render_frame,
+    int tab_id,
+    UserScript::RunLocation run_location,
+    const GURL& document_url,
+    //bool is_declarative,
+    bool log_activity) {
+  std::unique_ptr<ScriptInjection> injection;
+  std::unique_ptr<const InjectionHost> injection_host;
+  blink::WebLocalFrame* web_frame = render_frame->GetWebFrame();
+
+  const HostID& host_id = script->host_id();
+//  if (host_id.type() == HostID::EXTENSIONS) {
+//    injection_host = ExtensionInjectionHost::Create(host_id.id());
+//    if (!injection_host)
+//      return injection;
+//  } else {
+//    DCHECK_EQ(host_id.type(), HostID::WEBUI);
+    injection_host.reset(new WebUIInjectionHost(host_id));
+//  }
+
+  GURL effective_document_url =
+      ScriptContext::GetEffectiveDocumentURLForInjection(
+          web_frame, document_url, script->match_origin_as_fallback());
+
+  bool is_subframe = web_frame->Parent();
+  if (!script->MatchesDocument(effective_document_url, is_subframe))
+    return injection;
+
+  std::unique_ptr<ScriptInjector> injector(
+      new UserScriptInjector(script, this/*, is_declarative*/));
+
+  // if (injector->CanExecuteOnFrame(injection_host.get(), web_frame, tab_id) ==
+  //     PermissionsData::PageAccess::kDenied) {
+  //   return injection;
+  // }
+
+  bool inject_css = !script->css_scripts().empty() &&
+                    run_location == UserScript::DOCUMENT_START;
+  bool inject_js =
+      !script->js_scripts().empty() && script->run_location() == run_location;
+  if (inject_css || inject_js) {
+    injection.reset(new ScriptInjection(std::move(injector), render_frame,
+                                        std::move(injection_host), run_location,
+                                        log_activity));
+  }
+  return injection;
+}
+
+blink::WebString UserScriptSet::GetJsSource(const UserScript::File& file,
+                                            bool emulate_greasemonkey) {
+  const GURL& url = file.url();
+  auto iter = script_sources_.find(url);
+  if (iter != script_sources_.end()) {
+    LOG(INFO) << "---UserScriptSet::GetJsSource found " << url;
+    return iter->second;
+  }
+
+  base::StringPiece script_content = file.GetContent();
+  blink::WebString source;
+  if (emulate_greasemonkey) {
+    // We add this dumb function wrapper for user scripts to emulate what
+    // Greasemonkey does. |script_content| becomes:
+    // concat(kUserScriptHead, script_content, kUserScriptTail).
+    std::string content =
+        base::StrCat({kUserScriptHead, script_content, kUserScriptTail});
+    source = blink::WebString::FromUTF8(content);
+    LOG(INFO) << "---UserScriptSet::GetJsSource emu " << script_content;
+  } else {
+    source = blink::WebString::FromUTF8(script_content.data(),
+                                        script_content.length());
+    LOG(INFO) << "---UserScriptSet::GetJsSource " << source.Ascii();
+  }
+  script_sources_[url] = source;
+  return source;
+}
+
+blink::WebString UserScriptSet::GetCssSource(const UserScript::File& file) {
+  const GURL& url = file.url();
+  auto iter = script_sources_.find(url);
+  if (iter != script_sources_.end())
+    return iter->second;
+
+  base::StringPiece script_content = file.GetContent();
+  return script_sources_
+      .insert(std::make_pair(
+          url, blink::WebString::FromUTF8(script_content.data(),
+                                          script_content.length())))
+      .first->second;
+}
+
+}  // namespace extensions
diff --git a/components/user_scripts/content/renderer/user_script_set.h b/components/user_scripts/content/renderer/user_script_set.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/user_script_set.h
@@ -0,0 +1,113 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_USER_SCRIPT_SET_H_
+#define EXTENSIONS_RENDERER_USER_SCRIPT_SET_H_
+
+#include <map>
+#include <memory>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/memory/read_only_shared_memory_region.h"
+#include "base/observer_list.h"
+#include "../common/user_script.h"
+#include "third_party/blink/public/platform/web_string.h"
+
+class GURL;
+
+namespace content {
+class RenderFrame;
+}
+
+namespace user_scripts {
+class ScriptInjection;
+
+// The UserScriptSet is a collection of UserScripts which knows how to update
+// itself from SharedMemory and create ScriptInjections for UserScripts to
+// inject on a page.
+class UserScriptSet {
+ public:
+  class Observer {
+   public:
+    // Called when the set of user scripts is updated. |changed_hosts| contains
+    // the hosts whose scripts have been altered. Note that *all* script objects
+    // are invalidated, even if they aren't in |changed_hosts|.
+    virtual void OnUserScriptsUpdated(const std::set<HostID>& changed_hosts,
+                                      const UserScriptList& scripts) = 0;
+  };
+
+  UserScriptSet();
+  ~UserScriptSet();
+
+  // Adds or removes observers.
+  void AddObserver(Observer* observer);
+  void RemoveObserver(Observer* observer);
+  void AddScript(std::unique_ptr<UserScript> script);
+
+  // Appends the ids of the extensions that have user scripts to |ids|.
+  //void GetActiveExtensionIds(std::set<std::string>* ids) const;
+
+  // Append any ScriptInjections that should run on the given |render_frame| and
+  // |tab_id|, at the given |run_location|, to |injections|.
+  // |extensions| is passed in to verify the corresponding extension is still
+  // valid.
+  void GetInjections(std::vector<std::unique_ptr<ScriptInjection>>* injections,
+                     content::RenderFrame* render_frame,
+                     int tab_id,
+                     UserScript::RunLocation run_location,
+                     bool log_activity);
+
+//   std::unique_ptr<ScriptInjection> GetDeclarativeScriptInjection(
+//       int script_id,
+//       content::RenderFrame* render_frame,
+//       int tab_id,
+//       UserScript::RunLocation run_location,
+//       const GURL& document_url,
+//       bool log_activity);
+
+  // Updates scripts given the shared memory region containing user scripts.
+  // Returns true if the scripts were successfully updated.
+  bool UpdateUserScripts(base::ReadOnlySharedMemoryRegion shared_memory,
+                         const std::set<HostID>& changed_hosts,
+                         bool whitelisted_only);
+
+  // Returns the contents of a script file.
+  // Note that copying is cheap as this uses WebString.
+  blink::WebString GetJsSource(const UserScript::File& file,
+                               bool emulate_greasemonkey);
+  blink::WebString GetCssSource(const UserScript::File& file);
+
+ private:
+  // Returns a new ScriptInjection for the given |script| to execute in the
+  // |render_frame|, or NULL if the script should not execute.
+  std::unique_ptr<ScriptInjection> GetInjectionForScript(
+      const UserScript* script,
+      content::RenderFrame* render_frame,
+      int tab_id,
+      UserScript::RunLocation run_location,
+      const GURL& document_url,
+      //bool is_declarative,
+      bool log_activity);
+
+  // Shared memory mapping containing raw script data.
+  base::ReadOnlySharedMemoryMapping shared_memory_mapping_;
+
+  // The UserScripts this injector manages.
+  UserScriptList scripts_;
+
+  // Map of user script file url -> source.
+  std::map<GURL, blink::WebString> script_sources_;
+
+  // The associated observers.
+  base::ObserverList<Observer>::Unchecked observers_;
+
+  DISALLOW_COPY_AND_ASSIGN(UserScriptSet);
+};
+
+}  // namespace extensions
+
+#endif  // EXTENSIONS_RENDERER_USER_SCRIPT_SET_H_
diff --git a/components/user_scripts/content/renderer/user_script_set_manager.cc b/components/user_scripts/content/renderer/user_script_set_manager.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/user_script_set_manager.cc
@@ -0,0 +1,178 @@
+#include "user_script_set_manager.h"
+
+#include "base/logging.h"
+#include "content/public/renderer/render_thread.h"
+#include "../common/host_id.h"
+#include "../common/extension_messages.h"
+#include "user_script_set.h"
+
+namespace user_scripts {
+
+UserScriptSetManager::UserScriptSetManager() {
+
+  //UserScript script_;
+  std::unique_ptr<UserScript> script_(new UserScript());  
+  script_->set_id(UserScript::GenerateUserScriptID());
+  script_->set_host_id(HostID(HostID::HostType::WEBUI, "test"));
+  script_->set_run_location(UserScript::DOCUMENT_START);
+  script_->set_match_all_frames(false);
+  script_->set_match_origin_as_fallback(MatchOriginAsFallbackBehavior::kNever);
+  //script_->add_url_pattern(URLPattern(URLPattern::SCHEME_HTTPS, "*://*/*"));
+  script_->add_url_pattern(URLPattern(URLPattern::SCHEME_HTTPS, "*://*.google.com/*"));
+
+  // for (auto it = script_data.css_file_names.cbegin();
+  //      it != script_data.css_file_names.cend(); ++it) {
+  //   GURL url = extension->GetResourceURL(*it);
+  //   ExtensionResource resource = extension->GetResource(*it);
+  //   script_.css_scripts().push_back(std::make_unique<UserScript::File>(
+  //       resource.extension_root(), resource.relative_path(), url));
+  // }
+  // for (auto it = script_data.js_file_names.cbegin();
+  //      it != script_data.js_file_names.cend(); ++it) {
+  //   GURL url = extension->GetResourceURL(*it);
+  //   ExtensionResource resource = extension->GetResource(*it);
+  //   script_.js_scripts().push_back(std::make_unique<UserScript::File>(
+  //       resource.extension_root(), resource.relative_path(), url));
+  // }  
+
+  std::unique_ptr<UserScript::File> file(new UserScript::File());
+  //file->set_content("document.cookie = 'CONSENT=YES+IT.it+V13+BX;domain=.google.com'; document.cookie = '1P_JAR=2020-10-18-08;domain=.google.com'; console.log('aa');");
+  file->set_content("document.cookie = 'CONSENT=YES+IT.it+V13+BX;domain=.google.com'; console.log('aa');");
+  file->set_url(GURL("url"));
+  script_->js_scripts().push_back(std::move(file));
+
+  static_scripts_.AddScript(std::move(script_));
+
+  LOG(INFO) << "---UserScriptSetManager::UserScriptSetManager";
+
+  content::RenderThread::Get()->AddObserver(this);
+}
+
+UserScriptSetManager::~UserScriptSetManager() {
+}
+
+void UserScriptSetManager::AddObserver(Observer* observer) {
+  observers_.AddObserver(observer);
+}
+
+void UserScriptSetManager::RemoveObserver(Observer* observer) {
+  observers_.RemoveObserver(observer);
+}
+
+bool UserScriptSetManager::OnControlMessageReceived(
+    const IPC::Message& message) {
+  bool handled = true;
+  IPC_BEGIN_MESSAGE_MAP(UserScriptSetManager, message)
+    IPC_MESSAGE_HANDLER(ExtensionMsg_UpdateUserScripts, OnUpdateUserScripts)
+    IPC_MESSAGE_UNHANDLED(handled = false)
+  IPC_END_MESSAGE_MAP()
+  return handled;
+}
+
+// std::unique_ptr<ScriptInjection>
+// UserScriptSetManager::GetInjectionForDeclarativeScript(
+//     int script_id,
+//     content::RenderFrame* render_frame,
+//     int tab_id,
+//     const GURL& url,
+//     const std::string& extension_id) {
+// //  UserScriptSet* user_script_set =
+// //      GetProgrammaticScriptsByHostID(HostID(HostID::EXTENSIONS, extension_id));
+// //  if (!user_script_set)
+//     return std::unique_ptr<ScriptInjection>();
+
+// //  return user_script_set->GetDeclarativeScriptInjection(
+// //      script_id, render_frame, tab_id, UserScript::BROWSER_DRIVEN, url,
+// //      activity_logging_enabled_);
+// }
+
+//UserScriptSet* UserScriptSetManager::GetProgrammaticScriptsByHostID(
+//    const HostID& host_id) {
+//  UserScriptSetMap::const_iterator it = programmatic_scripts_.find(host_id);
+//  return it != programmatic_scripts_.end() ? it->second.get() : NULL;
+//}
+
+void UserScriptSetManager::GetAllInjections(
+    std::vector<std::unique_ptr<ScriptInjection>>* injections,
+    content::RenderFrame* render_frame,
+    int tab_id,
+    UserScript::RunLocation run_location) {
+
+  LOG(INFO) << "---UserScriptSetManager::GetAllInjections";
+
+  // static_scripts_ is UserScriptSet
+  static_scripts_.GetInjections(injections, render_frame, tab_id, run_location,
+                                activity_logging_enabled_);
+//  for (auto it = programmatic_scripts_.begin();
+//       it != programmatic_scripts_.end(); ++it) {
+//    it->second->GetInjections(injections, render_frame, tab_id, run_location,
+//                              activity_logging_enabled_);
+//  }
+}
+
+void UserScriptSetManager::OnUpdateUserScripts(
+    base::ReadOnlySharedMemoryRegion shared_memory,
+    const HostID& host_id,
+    const std::set<HostID>& changed_hosts,
+    bool whitelisted_only) {
+  if (!shared_memory.IsValid()) {
+    NOTREACHED() << "Bad scripts handle";
+    return;
+  }
+
+  // for (const HostID& host_id : changed_hosts) {
+  //   if (host_id.type() == HostID::EXTENSIONS &&
+  //       !crx_file::id_util::IdIsValid(host_id.id())) {
+  //     NOTREACHED() << "Invalid extension id: " << host_id.id();
+  //     return;
+  //   }
+  // }
+
+  UserScriptSet* scripts = NULL;
+  // if (!host_id.id().empty()) {
+  //   // The expectation when there is a host that "owns" this shared
+  //   // memory region is that the |changed_hosts| is either the empty list
+  //   // or just the owner.
+  //   CHECK(changed_hosts.size() <= 1);
+  //   if (programmatic_scripts_.find(host_id) == programmatic_scripts_.end()) {
+  //     scripts = programmatic_scripts_
+  //                   .insert(std::make_pair(host_id,
+  //                                          std::make_unique<UserScriptSet>()))
+  //                   .first->second.get();
+  //   } else {
+  //     scripts = programmatic_scripts_[host_id].get();
+  //   }
+  // } else {
+    scripts = &static_scripts_;
+  // }
+  DCHECK(scripts);
+
+  // If no hosts are included in the set, that indicates that all
+  // hosts were updated. Add them all to the set so that observers and
+  // individual UserScriptSets don't need to know this detail.
+  const std::set<HostID>* effective_hosts = &changed_hosts;
+  std::set<HostID> all_hosts;
+  if (changed_hosts.empty()) {
+    // // The meaning of "all hosts(extensions)" varies, depending on whether some
+    // // host "owns" this shared memory region.
+    // // No owner => all known hosts.
+    // // Owner    => just the owner host.
+    // if (host_id.id().empty()) {
+    //   std::set<std::string> extension_ids =
+    //       RendererExtensionRegistry::Get()->GetIDs();
+    //   for (const std::string& extension_id : extension_ids)
+    //     all_hosts.insert(HostID(HostID::EXTENSIONS, extension_id));
+    // } else {
+    //   all_hosts.insert(host_id);
+    // }
+    effective_hosts = &all_hosts;
+  }
+
+  if (scripts->UpdateUserScripts(std::move(shared_memory), *effective_hosts,
+                                 whitelisted_only)) {
+    for (auto& observer : observers_)
+      observer.OnUserScriptsUpdated(*effective_hosts);
+  }
+}
+
+}
\ No newline at end of file
diff --git a/components/user_scripts/content/renderer/user_script_set_manager.h b/components/user_scripts/content/renderer/user_script_set_manager.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/user_script_set_manager.h
@@ -0,0 +1,76 @@
+#ifndef COMPONENTS_USER_SCRIPTS_RENDER_SET_MANAGER_H_
+#define COMPONENTS_USER_SCRIPTS_RENDER_SET_MANAGER_H_
+
+#include <map>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/memory/read_only_shared_memory_region.h"
+#include "base/observer_list.h"
+#include "content/public/renderer/render_thread_observer.h"
+#include "../common/host_id.h"
+#include "user_script_set.h"
+#include "script_injection.h"
+
+namespace user_scripts {
+
+class UserScriptSetManager : public content::RenderThreadObserver {
+ public:
+  class Observer {
+   public:
+    virtual void OnUserScriptsUpdated(const std::set<HostID>& changed_hosts) = 0;
+  };
+
+  UserScriptSetManager();
+
+  ~UserScriptSetManager() override;
+
+  void AddObserver(Observer* observer);
+  void RemoveObserver(Observer* observer);
+
+  // // Looks up the script injection associated with |script_id| and
+  // // |extension_id| in the context of the given |web_frame|, |tab_id|,
+  // // and |url|.
+  // std::unique_ptr<ScriptInjection> GetInjectionForDeclarativeScript(
+  //     int script_id,
+  //     content::RenderFrame* render_frame,
+  //     int tab_id,
+  //     const GURL& url,
+  //     const std::string& extension_id);
+      
+  // Append all injections from |static_scripts| and each of
+  // |programmatic_scripts_| to |injections|.
+  void GetAllInjections(
+      std::vector<std::unique_ptr<ScriptInjection>>* injections,
+      content::RenderFrame* render_frame,
+      int tab_id,
+      UserScript::RunLocation run_location);
+
+private:
+  // content::RenderThreadObserver implementation.
+  bool OnControlMessageReceived(const IPC::Message& message) override;
+  
+  base::ObserverList<Observer>::Unchecked observers_;
+
+  // Scripts programmatically-defined through API calls (initialized and stored
+  // per-extension).
+  //UserScriptSetMap programmatic_scripts_;
+
+  // Handle the UpdateUserScripts extension message.
+  void OnUpdateUserScripts(base::ReadOnlySharedMemoryRegion shared_memory,
+                           const HostID& host_id,
+                           const std::set<HostID>& changed_hosts,
+                           bool whitelisted_only);
+                           
+  // Scripts statically defined in extension manifests.
+  UserScriptSet static_scripts_;
+
+  // Whether or not dom activity should be logged for scripts injected.
+  bool activity_logging_enabled_ = false;
+};
+
+}
+
+#endif
\ No newline at end of file
diff --git a/components/user_scripts/content/renderer/user_scripts_dispatcher.cc b/components/user_scripts/content/renderer/user_scripts_dispatcher.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/user_scripts_dispatcher.cc
@@ -0,0 +1,61 @@
+#include "user_scripts_dispatcher.h"
+
+#include <stddef.h>
+
+#include <algorithm>
+#include <memory>
+#include <utility>
+
+#include "content/public/renderer/render_thread.h"
+#include "extension_frame_helper.h"
+
+namespace user_scripts {
+
+// ex ChromeExtensionsDispatcherDelegate
+UserScriptsDispatcher::UserScriptsDispatcher()
+    : user_script_set_manager_observer_(this) {
+    //: delegate_(std::move(delegate))
+    //,
+    //  content_watcher_(new ContentWatcher()),
+    //  source_map_(&ui::ResourceBundle::GetSharedInstance()),
+    //  v8_schema_registry_(new V8SchemaRegistry),
+    //activity_logging_enabled_(false) 
+      user_script_set_manager_.reset(new UserScriptSetManager());
+      script_injection_manager_.reset(
+          new ScriptInjectionManager(user_script_set_manager_.get()));
+      user_script_set_manager_observer_.Add(user_script_set_manager_.get());
+}
+
+UserScriptsDispatcher::~UserScriptsDispatcher() {
+}
+
+void UserScriptsDispatcher::OnRenderThreadStarted(content::RenderThread* thread) {
+  //thread->RegisterExtension(extensions::SafeBuiltins::CreateV8Extension());
+}
+
+void UserScriptsDispatcher::OnUserScriptsUpdated(const std::set<HostID>& changed_hosts) {
+  //UpdateActiveExtensions();
+}
+
+void UserScriptsDispatcher::OnRenderFrameCreated(content::RenderFrame* render_frame) {
+  script_injection_manager_->OnRenderFrameCreated(render_frame);
+  //content_watcher_->OnRenderFrameCreated(render_frame);
+}
+
+//void Dispatcher::OnSetActivityLoggingEnabled(bool enabled) {
+//  activity_logging_enabled_ = enabled;
+//  if (enabled) {
+//    for (const std::string& id : active_extension_ids_)
+//      DOMActivityLogger::AttachToWorld(DOMActivityLogger::kMainWorldId, id);
+//  }
+//  script_injection_manager_->set_activity_logging_enabled(enabled);
+//  user_script_set_manager_->set_activity_logging_enabled(enabled);
+//}
+
+//void Dispatcher::UpdateActiveExtensions() {
+//  std::set<std::string> active_extensions = active_extension_ids_;
+//  user_script_set_manager_->GetAllActiveExtensionIds(&active_extensions);
+//  delegate_->OnActiveExtensionsUpdated(active_extensions);
+//}
+
+}
\ No newline at end of file
diff --git a/components/user_scripts/content/renderer/user_scripts_dispatcher.h b/components/user_scripts/content/renderer/user_scripts_dispatcher.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/user_scripts_dispatcher.h
@@ -0,0 +1,51 @@
+#ifndef COMPONENTS_USER_SCRIPTS_RENDER_DISPATCHER_H_
+#define COMPONENTS_USER_SCRIPTS_RENDER_DISPATCHER_H_
+
+#include "user_script_set_manager.h"
+#include "script_injection_manager.h"
+
+#include <stdint.h>
+
+#include <map>
+#include <memory>
+#include <set>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/scoped_observer.h"
+#include "content/public/renderer/render_thread_observer.h"
+#include "content/public/renderer/render_thread.h"
+#include "../common/host_id.h"
+#include "user_script_set_manager.h"
+#include "script_injection.h"
+
+namespace user_scripts {
+
+class UserScriptsDispatcher : public content::RenderThreadObserver,
+                              public UserScriptSetManager::Observer {
+
+ public:
+  explicit UserScriptsDispatcher();
+  ~UserScriptsDispatcher() override;
+
+  void OnRenderThreadStarted(content::RenderThread* thread);
+  void OnUserScriptsUpdated(const std::set<HostID>& changed_hosts) override;
+  void OnRenderFrameCreated(content::RenderFrame* render_frame);
+
+ private:
+  std::unique_ptr<UserScriptSetManager> user_script_set_manager_;
+
+  std::unique_ptr<ScriptInjectionManager> script_injection_manager_;  
+  
+  ScopedObserver<UserScriptSetManager, UserScriptSetManager::Observer>
+      user_script_set_manager_observer_;
+
+  // Whether or not extension activity is enabled.
+  //bool activity_logging_enabled_;      
+};
+
+}
+
+#endif
\ No newline at end of file
diff --git a/components/user_scripts/content/renderer/user_scripts_renderer_client.cc b/components/user_scripts/content/renderer/user_scripts_renderer_client.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/user_scripts_renderer_client.cc
@@ -0,0 +1,72 @@
+#include "user_scripts_renderer_client.h"
+
+#include <memory>
+#include <utility>
+
+#include "base/logging.h"
+#include "base/lazy_instance.h"
+#include "content/public/renderer/render_thread.h"
+#include "user_scripts_dispatcher.h"
+#include "extension_frame_helper.h"
+
+namespace user_scripts {
+
+// was ChromeExtensionsRendererClient
+UserScriptsRendererClient::UserScriptsRendererClient() {}
+
+UserScriptsRendererClient::~UserScriptsRendererClient() {}
+
+// static
+UserScriptsRendererClient* UserScriptsRendererClient::GetInstance() {
+  static base::LazyInstance<UserScriptsRendererClient>::Leaky client =
+      LAZY_INSTANCE_INITIALIZER;
+  return client.Pointer();
+}
+
+void UserScriptsRendererClient::RenderThreadStarted() {
+  LOG(INFO) << "---UserScriptsRendererClient::RenderThreadStarted";
+  content::RenderThread* thread = content::RenderThread::Get();
+
+  dispatcher_ = std::make_unique<UserScriptsDispatcher>();
+
+  dispatcher_->OnRenderThreadStarted(thread);
+  thread->AddObserver(dispatcher_.get());
+}
+
+void UserScriptsRendererClient::RenderFrameCreated(
+    content::RenderFrame* render_frame,
+    service_manager::BinderRegistry* registry) {
+  //new user_scripts::ExtensionsRenderFrameObserver(render_frame, registry);
+  new user_scripts::ExtensionFrameHelper(render_frame
+                                         /*,dispatcher_.get()*/);
+  dispatcher_->OnRenderFrameCreated(render_frame);
+}
+
+void UserScriptsRendererClient::RunScriptsAtDocumentStart(content::RenderFrame* render_frame) {
+  ExtensionFrameHelper* frame_helper = ExtensionFrameHelper::Get(render_frame);
+  if (!frame_helper)
+    return;  // The frame is invisible to extensions.
+
+  frame_helper->RunScriptsAtDocumentStart();
+  // |frame_helper| and |render_frame| might be dead by now.
+}
+
+void UserScriptsRendererClient::RunScriptsAtDocumentEnd(content::RenderFrame* render_frame) {
+  ExtensionFrameHelper* frame_helper = ExtensionFrameHelper::Get(render_frame);
+  if (!frame_helper)
+    return;  // The frame is invisible to extensions.
+
+  frame_helper->RunScriptsAtDocumentEnd();
+  // |frame_helper| and |render_frame| might be dead by now.
+}
+
+void UserScriptsRendererClient::RunScriptsAtDocumentIdle(content::RenderFrame* render_frame) {
+  ExtensionFrameHelper* frame_helper = ExtensionFrameHelper::Get(render_frame);
+  if (!frame_helper)
+    return;  // The frame is invisible to extensions.
+
+  frame_helper->RunScriptsAtDocumentIdle();
+  // |frame_helper| and |render_frame| might be dead by now.
+}
+
+}
\ No newline at end of file
diff --git a/components/user_scripts/content/renderer/user_scripts_renderer_client.h b/components/user_scripts/content/renderer/user_scripts_renderer_client.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/user_scripts_renderer_client.h
@@ -0,0 +1,33 @@
+#ifndef COMPONENTS_USER_SCRIPTS_RENDER_CLIENT_H_
+#define COMPONENTS_USER_SCRIPTS_RENDER_CLIENT_H_
+
+#include <memory>
+#include <string>
+
+#include "base/macros.h"
+#include "user_scripts_dispatcher.h"
+#include "services/service_manager/public/cpp/binder_registry.h"
+
+namespace user_scripts {
+
+class UserScriptsRendererClient {
+ public:
+  UserScriptsRendererClient();
+  ~UserScriptsRendererClient();
+
+  static UserScriptsRendererClient* GetInstance();
+
+  void RenderThreadStarted();
+  void RenderFrameCreated(content::RenderFrame* render_frame,
+    service_manager::BinderRegistry* registry);
+  void RunScriptsAtDocumentStart(content::RenderFrame* render_frame);
+  void RunScriptsAtDocumentEnd(content::RenderFrame* render_frame);
+  void RunScriptsAtDocumentIdle(content::RenderFrame* render_frame);
+
+ private:
+  std::unique_ptr<UserScriptsDispatcher> dispatcher_;
+};
+
+}
+
+#endif
\ No newline at end of file
diff --git a/components/user_scripts/content/renderer/web_ui_injection_host.cc b/components/user_scripts/content/renderer/web_ui_injection_host.cc
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/web_ui_injection_host.cc
@@ -0,0 +1,35 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "web_ui_injection_host.h"
+
+WebUIInjectionHost::WebUIInjectionHost(const HostID& host_id)
+  : InjectionHost(host_id),
+    url_(host_id.id()) {
+}
+
+WebUIInjectionHost::~WebUIInjectionHost() {
+}
+
+const std::string* WebUIInjectionHost::GetContentSecurityPolicy() const {
+  // Use the main world CSP.
+  return nullptr;
+}
+
+const GURL& WebUIInjectionHost::url() const {
+  return url_;
+}
+
+const std::string& WebUIInjectionHost::name() const {
+  return id().id();
+}
+
+//extensions::PermissionsData::PageAccess WebUIInjectionHost::CanExecuteOnFrame(
+//    const GURL& document_url,
+//    content::RenderFrame* render_frame,
+//    int tab_id,
+//    bool is_declarative) const {
+//  // Content scripts are allowed to inject on webviews created by WebUI.
+//  return extensions::PermissionsData::PageAccess::kAllowed;
+//}
diff --git a/components/user_scripts/content/renderer/web_ui_injection_host.h b/components/user_scripts/content/renderer/web_ui_injection_host.h
new file mode 100755
--- /dev/null
+++ b/components/user_scripts/content/renderer/web_ui_injection_host.h
@@ -0,0 +1,33 @@
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef EXTENSIONS_RENDERER_WEB_UI_INJECTION_HOST_H_
+#define EXTENSIONS_RENDERER_WEB_UI_INJECTION_HOST_H_
+
+#include "base/macros.h"
+#include "injection_host.h"
+
+class WebUIInjectionHost : public InjectionHost {
+ public:
+  WebUIInjectionHost(const HostID& host_id);
+  ~WebUIInjectionHost() override;
+
+ private:
+  // InjectionHost:
+  const std::string* GetContentSecurityPolicy() const override;
+  const GURL& url() const override;
+  const std::string& name() const override;
+//  extensions::PermissionsData::PageAccess CanExecuteOnFrame(
+//      const GURL& document_url,
+//      content::RenderFrame* render_frame,
+//      int tab_id,
+//      bool is_declarative) const override;
+
+ private:
+  GURL url_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebUIInjectionHost);
+};
+
+#endif  // EXTENSIONS_RENDERER_WEB_UI_INJECTION_HOST_H_
diff --git a/tools/gritsettings/resource_ids.spec b/tools/gritsettings/resource_ids.spec
--- a/tools/gritsettings/resource_ids.spec
+++ b/tools/gritsettings/resource_ids.spec
@@ -407,6 +407,9 @@
   "components/autofill/core/browser/autofill_address_rewriter_resources.grd":{
     "includes": [2880]
   },
+  "components/user_scripts/content/renderer/resources/user_scripts_renderer_resources.grd": {
+    "includes": [3000],
+  },  
   # END components/ section.
 
   # START ios/ section.
